// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:DbAthlete.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// DbAthlete TABLE
class TableDbAthlete extends SqfEntityTableBase {
  TableDbAthlete() {
    // declare properties of EntityTable
    tableName = 'athletes';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('state', DbType.text, defaultValue: 'new'),
      SqfEntityFieldBase('firstName', DbType.text),
      SqfEntityFieldBase('lastName', DbType.text),
      SqfEntityFieldBase('stravaUsername', DbType.text),
      SqfEntityFieldBase('photoPath', DbType.text),
      SqfEntityFieldBase('stravaId', DbType.integer),
      SqfEntityFieldBase('geoState', DbType.text),
      SqfEntityFieldBase('downloadInterval', DbType.integer),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbAthlete();
  }
}

// DbActivity TABLE
class TableDbActivity extends SqfEntityTableBase {
  TableDbActivity() {
    // declare properties of EntityTable
    tableName = 'activities';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('state', DbType.text, defaultValue: 'new'),
      SqfEntityFieldBase('path', DbType.text),
      SqfEntityFieldBase('stravaId', DbType.integer),
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('movingTime', DbType.integer),
      SqfEntityFieldBase('type', DbType.text),
      SqfEntityFieldBase('distance', DbType.integer),
      SqfEntityFieldBase('serialNumber', DbType.integer),
      SqfEntityFieldBase('timeCreated', DbType.datetime),
      SqfEntityFieldBase('sportName', DbType.text),
      SqfEntityFieldBase('sport', DbType.text),
      SqfEntityFieldBase('subSport', DbType.text),
      SqfEntityFieldBase('timeStamp', DbType.datetime),
      SqfEntityFieldBase('startTime', DbType.datetime),
      SqfEntityFieldBase('startPositionLat', DbType.real),
      SqfEntityFieldBase('startPositionLong', DbType.real),
      SqfEntityFieldBase('event', DbType.text),
      SqfEntityFieldBase('eventType', DbType.text),
      SqfEntityFieldBase('eventGroup', DbType.integer),
      SqfEntityFieldBase('totalDistance', DbType.integer),
      SqfEntityFieldBase('totalStrides', DbType.integer),
      SqfEntityFieldBase('totalCalories', DbType.integer),
      SqfEntityFieldBase('avgSpeed', DbType.real),
      SqfEntityFieldBase('maxSpeed', DbType.real),
      SqfEntityFieldBase('totalAscent', DbType.integer),
      SqfEntityFieldBase('totalDescent', DbType.integer),
      SqfEntityFieldBase('maxRunningCadence', DbType.integer),
      SqfEntityFieldBase('trigger', DbType.text),
      SqfEntityFieldBase('avgTemperature', DbType.integer),
      SqfEntityFieldBase('maxTemperature', DbType.integer),
      SqfEntityFieldBase('avgFractionalCadence', DbType.real),
      SqfEntityFieldBase('maxFractionalCadence', DbType.real),
      SqfEntityFieldBase('totalFractionalCycles', DbType.real),
      SqfEntityFieldBase('avgStanceTimePercent', DbType.real),
      SqfEntityFieldBase('avgStanceTime', DbType.real),
      SqfEntityFieldBase('avgHeartRate', DbType.integer),
      SqfEntityFieldBase('maxHeartRate', DbType.integer),
      SqfEntityFieldBase('avgRunningCadence', DbType.real),
      SqfEntityFieldBase('avgVerticalOscillation', DbType.real),
      SqfEntityFieldBase('totalElapsedTime', DbType.integer),
      SqfEntityFieldBase('totalTimerTime', DbType.integer),
      SqfEntityFieldBase('totalTrainingEffect', DbType.integer),
      SqfEntityFieldBase('necLat', DbType.real),
      SqfEntityFieldBase('necLong', DbType.real),
      SqfEntityFieldBase('swcLat', DbType.real),
      SqfEntityFieldBase('swcLong', DbType.real),
      SqfEntityFieldBase('firstLapIndex', DbType.integer),
      SqfEntityFieldBase('numLaps', DbType.integer),
      SqfEntityFieldBase('numSessions', DbType.integer),
      SqfEntityFieldBase('localTimestamp', DbType.datetime),
      SqfEntityFieldBase('avgPower', DbType.real),
      SqfEntityFieldBase('minPower', DbType.integer),
      SqfEntityFieldBase('maxPower', DbType.integer),
      SqfEntityFieldBase('sdevPower', DbType.real),
      SqfEntityFieldBase('avgGroundTime', DbType.real),
      SqfEntityFieldBase('sdevGroundTime', DbType.real),
      SqfEntityFieldBase('avgLegSpringStiffness', DbType.real),
      SqfEntityFieldBase('sdevLegSpringStiffness', DbType.real),
      SqfEntityFieldBase('avgFormPower', DbType.real),
      SqfEntityFieldBase('sdevFormPower', DbType.real),
      SqfEntityFieldBase('avgPowerRatio', DbType.real),
      SqfEntityFieldBase('sdevPowerRatio', DbType.real),
      SqfEntityFieldBase('avgStrydCadence', DbType.real),
      SqfEntityFieldBase('sdevStrydCadence', DbType.real),
      SqfEntityFieldBase('sdevVerticalOscillation', DbType.real),
      SqfEntityFieldRelationshipBase(
          TableDbAthlete.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'athletesId'),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbActivity();
  }
}

// DbEvent TABLE
class TableDbEvent extends SqfEntityTableBase {
  TableDbEvent() {
    // declare properties of EntityTable
    tableName = 'events';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('event', DbType.text),
      SqfEntityFieldBase('eventType', DbType.text),
      SqfEntityFieldBase('eventGroup', DbType.integer),
      SqfEntityFieldBase('timerTrigger', DbType.text),
      SqfEntityFieldBase('timeStamp', DbType.datetime),
      SqfEntityFieldBase('positionLat', DbType.real),
      SqfEntityFieldBase('positionLong', DbType.real),
      SqfEntityFieldBase('distance', DbType.real),
      SqfEntityFieldBase('altitude', DbType.real),
      SqfEntityFieldBase('speed', DbType.real),
      SqfEntityFieldBase('heartRate', DbType.integer),
      SqfEntityFieldBase('cadence', DbType.real),
      SqfEntityFieldBase('fractionalCadence', DbType.real),
      SqfEntityFieldBase('power', DbType.integer),
      SqfEntityFieldBase('strydCadence', DbType.real),
      SqfEntityFieldBase('groundTime', DbType.real),
      SqfEntityFieldBase('verticalOscillation', DbType.real),
      SqfEntityFieldBase('formPower', DbType.integer),
      SqfEntityFieldBase('legSpringStiffness', DbType.real),
      SqfEntityFieldBase('data', DbType.real),
      SqfEntityFieldRelationshipBase(
          TableDbActivity.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'activitiesId'),
      SqfEntityFieldRelationshipBase(TableDbLap.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'lapsId'),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbEvent();
  }
}

// DbLap TABLE
class TableDbLap extends SqfEntityTableBase {
  TableDbLap() {
    // declare properties of EntityTable
    tableName = 'laps';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('timeStamp', DbType.datetime),
      SqfEntityFieldBase('startTime', DbType.datetime),
      SqfEntityFieldBase('startPositionLat', DbType.real),
      SqfEntityFieldBase('startPositionLong', DbType.real),
      SqfEntityFieldBase('endPositionLat', DbType.real),
      SqfEntityFieldBase('endPositionLong', DbType.real),
      SqfEntityFieldBase('avgHeartRate', DbType.integer),
      SqfEntityFieldBase('maxHeartRate', DbType.integer),
      SqfEntityFieldBase('avgRunningCadence', DbType.real),
      SqfEntityFieldBase('event', DbType.text),
      SqfEntityFieldBase('eventType', DbType.text),
      SqfEntityFieldBase('eventGroup', DbType.integer),
      SqfEntityFieldBase('sport', DbType.text),
      SqfEntityFieldBase('subSport', DbType.text),
      SqfEntityFieldBase('avgVerticalOscillation', DbType.real),
      SqfEntityFieldBase('totalElapsedTime', DbType.integer),
      SqfEntityFieldBase('totalTimerTime', DbType.integer),
      SqfEntityFieldBase('totalDistance', DbType.integer),
      SqfEntityFieldBase('totalStrides', DbType.integer),
      SqfEntityFieldBase('totalCalories', DbType.integer),
      SqfEntityFieldBase('avgSpeed', DbType.real),
      SqfEntityFieldBase('maxSpeed', DbType.real),
      SqfEntityFieldBase('totalAscent', DbType.integer),
      SqfEntityFieldBase('totalDescent', DbType.integer),
      SqfEntityFieldBase('avgStanceTimePercent', DbType.real),
      SqfEntityFieldBase('avgStanceTime', DbType.real),
      SqfEntityFieldBase('maxRunningCadence', DbType.integer),
      SqfEntityFieldBase('intensity', DbType.integer),
      SqfEntityFieldBase('lapTrigger', DbType.text),
      SqfEntityFieldBase('avgTemperature', DbType.integer),
      SqfEntityFieldBase('maxTemperature', DbType.integer),
      SqfEntityFieldBase('avgFractionalCadence', DbType.real),
      SqfEntityFieldBase('maxFractionalCadence', DbType.real),
      SqfEntityFieldBase('totalFractionalCycles', DbType.real),
      SqfEntityFieldBase('avgPower', DbType.real),
      SqfEntityFieldBase('minPower', DbType.integer),
      SqfEntityFieldBase('maxPower', DbType.integer),
      SqfEntityFieldBase('sdevPower', DbType.real),
      SqfEntityFieldBase('avgGroundTime', DbType.real),
      SqfEntityFieldBase('sdevGroundTime', DbType.real),
      SqfEntityFieldBase('avgLegSpringStiffness', DbType.real),
      SqfEntityFieldBase('sdevLegSpringStiffness', DbType.real),
      SqfEntityFieldBase('avgFormPower', DbType.real),
      SqfEntityFieldBase('sdevFormPower', DbType.real),
      SqfEntityFieldBase('avgStrydCadence', DbType.real),
      SqfEntityFieldBase('sdevStrydCadence', DbType.real),
      SqfEntityFieldBase('sdevVerticalOscillation', DbType.real),
      SqfEntityFieldRelationshipBase(
          TableDbActivity.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'activitiesId'),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbLap();
  }
}
// END TABLES

// BEGIN SEQUENCES
// END SEQUENCES

// BEGIN DATABASE MODEL
class DbEncrateia extends SqfEntityModelProvider {
  DbEncrateia() {
    databaseName = encrateia.databaseName;
    databaseTables = [
      TableDbAthlete.getInstance,
      TableDbActivity.getInstance,
      TableDbEvent.getInstance,
      TableDbLap.getInstance,
    ];

    bundledDatabasePath = encrateia
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region DbAthlete
class DbAthlete {
  DbAthlete(
      {this.id,
      this.state,
      this.firstName,
      this.lastName,
      this.stravaUsername,
      this.photoPath,
      this.stravaId,
      this.geoState,
      this.downloadInterval}) {
    _setDefaultValues();
  }
  DbAthlete.withFields(
      this.state,
      this.firstName,
      this.lastName,
      this.stravaUsername,
      this.photoPath,
      this.stravaId,
      this.geoState,
      this.downloadInterval) {
    _setDefaultValues();
  }
  DbAthlete.withId(
      this.id,
      this.state,
      this.firstName,
      this.lastName,
      this.stravaUsername,
      this.photoPath,
      this.stravaId,
      this.geoState,
      this.downloadInterval) {
    _setDefaultValues();
  }
  DbAthlete.fromMap(Map<String, dynamic> o) {
    id = o['id'] as int;
    state = o['state'] as String;
    firstName = o['firstName'] as String;
    lastName = o['lastName'] as String;
    stravaUsername = o['stravaUsername'] as String;
    photoPath = o['photoPath'] as String;
    stravaId = o['stravaId'] as int;
    geoState = o['geoState'] as String;
    downloadInterval = o['downloadInterval'] as int;
  }
  // FIELDS (DbAthlete)
  int id;
  String state;
  String firstName;
  String lastName;
  String stravaUsername;
  String photoPath;
  int stravaId;
  String geoState;
  int downloadInterval;

  BoolResult saveResult;
  // end FIELDS (DbAthlete)

// COLLECTIONS (DbAthlete)
  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbActivity> plDbActivities;

  /// get DbActivity(s) filtered by athletesId=id
  DbActivityFilterBuilder getDbActivities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbActivity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .athletesId
        .equals(id)
        .and;
  }
// END COLLECTIONS (DbAthlete)

  static const bool _softDeleteActivated = false;
  DbAthleteManager __mnDbAthlete;

  DbAthleteManager get _mnDbAthlete {
    return __mnDbAthlete = __mnDbAthlete ?? DbAthleteManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (firstName != null) {
      map['firstName'] = firstName;
    }

    if (lastName != null) {
      map['lastName'] = lastName;
    }

    if (stravaUsername != null) {
      map['stravaUsername'] = stravaUsername;
    }

    if (photoPath != null) {
      map['photoPath'] = photoPath;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (geoState != null) {
      map['geoState'] = geoState;
    }

    if (downloadInterval != null) {
      map['downloadInterval'] = downloadInterval;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (firstName != null) {
      map['firstName'] = firstName;
    }

    if (lastName != null) {
      map['lastName'] = lastName;
    }

    if (stravaUsername != null) {
      map['stravaUsername'] = stravaUsername;
    }

    if (photoPath != null) {
      map['photoPath'] = photoPath;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (geoState != null) {
      map['geoState'] = geoState;
    }

    if (downloadInterval != null) {
      map['downloadInterval'] = downloadInterval;
    }

// COLLECTIONS (DbAthlete)
    if (!forQuery) {
      map['DbActivities'] = await getDbActivities().toMapList();
    }
// END COLLECTIONS (DbAthlete)

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      state,
      firstName,
      lastName,
      stravaUsername,
      photoPath,
      stravaId,
      geoState,
      downloadInterval
    ];
  }

  static Future<List<DbAthlete>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbAthlete.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbAthlete>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbAthlete>[];
    try {
      objList = list
          .map((dbathlete) =>
              DbAthlete.fromMap(dbathlete as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbAthlete.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbAthlete>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbAthlete.fromMapList(data);
    } 
    */

  static Future<List<DbAthlete>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbAthlete> objList = <DbAthlete>[];
    for (final map in data) {
      final obj = DbAthlete.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivities')) {
          obj.plDbActivities = await obj.getDbActivities().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbAthlete by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbAthlete if exist, otherwise returns null
  Future<DbAthlete> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbAthlete obj;
    final data = await _mnDbAthlete.getById(id);
    if (data.length != 0) {
      obj = DbAthlete.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbAthlete.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbAthlete. Returns a new Primary Key value of DbAthlete

  /// <returns>Returns a new Primary Key value of DbAthlete
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbAthlete> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(List<DbAthlete> dbathletes) async {
    final results = _mnDbAthlete.saveAll(
        'INSERT OR REPLACE INTO athletes (id,  state, firstName, lastName, stravaUsername, photoPath, stravaId, geoState, downloadInterval)  VALUES (?,?,?,?,?,?,?,?,?)',
        dbathletes);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbAthlete.rawInsert(
              'INSERT OR REPLACE INTO athletes (id,  state, firstName, lastName, stravaUsername, photoPath, stravaId, geoState, downloadInterval)  VALUES (?,?,?,?,?,?,?,?,?)',
              [
                id,
                state,
                firstName,
                lastName,
                stravaUsername,
                photoPath,
                stravaId,
                geoState,
                downloadInterval
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbAthlete id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbAthlete id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbAthlete Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbAthlete>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(List<DbAthlete> dbathletes) async {
    final results = await _mnDbAthlete.rawInsertAll(
        'INSERT OR REPLACE INTO athletes (id,  state, firstName, lastName, stravaUsername, photoPath, stravaId, geoState, downloadInterval)  VALUES (?,?,?,?,?,?,?,?,?)',
        dbathletes);
    return results;
  }

  /// Deletes DbAthlete

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbAthlete invoked (id=$id)');
    var result = BoolResult();
    {
      result =
          await DbActivity().select().athletesId.equals(id).delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbAthlete
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbAthlete.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbAthleteFilterBuilder _Select;
  DbAthleteFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbAthleteFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbAthleteFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbAthleteFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    state = state ?? 'new';
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbathlete

// region DbAthleteField
class DbAthleteField extends SearchCriteria {
  DbAthleteField(this.dbathleteFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbAthleteFilterBuilder dbathleteFB;

  DbAthleteField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbAthleteFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param, SqlSyntax.EQuals,
            dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.NotEQuals, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder isNull() {
    dbathleteFB._addedBlocks = setCriteria(
        0,
        dbathleteFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbathleteFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbathleteFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks);
      _waitingNot = '';
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
    }
    return dbathleteFB;
  }

  DbAthleteFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbathleteFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbathleteFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks);
      _waitingNot = '';
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
    }
    return dbathleteFB;
  }

  DbAthleteFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbathleteFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbathleteFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks);
      _waitingNot = '';
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
    }
    return dbathleteFB;
  }

  DbAthleteFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbathleteFB._addedBlocks = setCriteria(
          pFirst,
          dbathleteFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbathleteFB._addedBlocks = setCriteria(pFirst, dbathleteFB.parameters,
            param, SqlSyntax.LessThan, dbathleteFB._addedBlocks);
      } else {
        dbathleteFB._addedBlocks = setCriteria(pFirst, dbathleteFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbathleteFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbathleteFB._addedBlocks = setCriteria(pLast, dbathleteFB.parameters,
            param, SqlSyntax.GreaterThan, dbathleteFB._addedBlocks);
      } else {
        dbathleteFB._addedBlocks = setCriteria(pLast, dbathleteFB.parameters,
            param, SqlSyntax.LessThanOrEquals, dbathleteFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThan, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param, SqlSyntax.LessThan,
            dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param, SqlSyntax.LessThan,
            dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThan, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder inValues(dynamic pValue) {
    dbathleteFB._addedBlocks = setCriteria(
        pValue,
        dbathleteFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }
}
// endregion DbAthleteField

// region DbAthleteFilterBuilder
class DbAthleteFilterBuilder extends SearchCriteria {
  DbAthleteFilterBuilder(DbAthlete obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbAthlete _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbAthleteFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbAthleteFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbAthleteFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbAthleteFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbAthleteFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbAthleteFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbAthleteFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbAthleteFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbAthleteFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbAthleteFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbAthleteField setField(DbAthleteField field, String colName, DbType dbtype) {
    return DbAthleteField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbAthleteField _id;
  DbAthleteField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbAthleteField _state;
  DbAthleteField get state {
    return _state = setField(_state, 'state', DbType.text);
  }

  DbAthleteField _firstName;
  DbAthleteField get firstName {
    return _firstName = setField(_firstName, 'firstName', DbType.text);
  }

  DbAthleteField _lastName;
  DbAthleteField get lastName {
    return _lastName = setField(_lastName, 'lastName', DbType.text);
  }

  DbAthleteField _stravaUsername;
  DbAthleteField get stravaUsername {
    return _stravaUsername =
        setField(_stravaUsername, 'stravaUsername', DbType.text);
  }

  DbAthleteField _photoPath;
  DbAthleteField get photoPath {
    return _photoPath = setField(_photoPath, 'photoPath', DbType.text);
  }

  DbAthleteField _stravaId;
  DbAthleteField get stravaId {
    return _stravaId = setField(_stravaId, 'stravaId', DbType.integer);
  }

  DbAthleteField _geoState;
  DbAthleteField get geoState {
    return _geoState = setField(_geoState, 'geoState', DbType.text);
  }

  DbAthleteField _downloadInterval;
  DbAthleteField get downloadInterval {
    return _downloadInterval =
        setField(_downloadInterval, 'downloadInterval', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbAthlete._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbAthlete> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbAthlete._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbAthlete.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbAthlete.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from athletes ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbAthlete.updateBatch(qparams, values);
  }

  /// This method always returns DbAthleteObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbAthlete>
  Future<DbAthlete> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbAthlete.toList(qparams);
    final data = await objFuture;
    DbAthlete obj;
    if (data.isNotEmpty) {
      obj = DbAthlete.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivities')) {
          obj.plDbActivities = await obj.getDbActivities().toList();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbathleteCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbathletesFuture = await _obj._mnDbAthlete.toList(qparams);
    final int count = dbathletesFuture[0]['CNT'] as int;
    if (dbathleteCount != null) {
      dbathleteCount(count);
    }
    return count;
  }

  /// This method always returns List<DbAthlete>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbAthlete>
  Future<List<DbAthlete>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbAthlete> dbathletesData =
        await DbAthlete.fromMapList(data, preload: preload);
    return dbathletesData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbAthlete.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbAthlete>>
  Future<List<DropdownMenuItem<DbAthlete>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbAthlete>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dbathletesFuture = _obj._mnDbAthlete.toList(qparams);

    final data = await dbathletesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbAthlete>> items = []..add(DropdownMenuItem(
        value: DbAthlete(),
        child: Text('Select DbAthlete'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbAthlete.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dbathletesFuture = _obj._mnDbAthlete.toList(qparams);

    final data = await dbathletesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbAthlete'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbAthlete.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbAthlete.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbAthlete.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbAthlete.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbAthleteFilterBuilder

// region DbAthleteFields
class DbAthleteFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fState;
  static TableField get state {
    return _fState =
        _fState ?? SqlSyntax.setField(_fState, 'state', DbType.text);
  }

  static TableField _fFirstName;
  static TableField get firstName {
    return _fFirstName = _fFirstName ??
        SqlSyntax.setField(_fFirstName, 'firstName', DbType.text);
  }

  static TableField _fLastName;
  static TableField get lastName {
    return _fLastName =
        _fLastName ?? SqlSyntax.setField(_fLastName, 'lastName', DbType.text);
  }

  static TableField _fStravaUsername;
  static TableField get stravaUsername {
    return _fStravaUsername = _fStravaUsername ??
        SqlSyntax.setField(_fStravaUsername, 'stravaUsername', DbType.text);
  }

  static TableField _fPhotoPath;
  static TableField get photoPath {
    return _fPhotoPath = _fPhotoPath ??
        SqlSyntax.setField(_fPhotoPath, 'photoPath', DbType.text);
  }

  static TableField _fStravaId;
  static TableField get stravaId {
    return _fStravaId = _fStravaId ??
        SqlSyntax.setField(_fStravaId, 'stravaId', DbType.integer);
  }

  static TableField _fGeoState;
  static TableField get geoState {
    return _fGeoState =
        _fGeoState ?? SqlSyntax.setField(_fGeoState, 'geoState', DbType.text);
  }

  static TableField _fDownloadInterval;
  static TableField get downloadInterval {
    return _fDownloadInterval = _fDownloadInterval ??
        SqlSyntax.setField(
            _fDownloadInterval, 'downloadInterval', DbType.integer);
  }
}
// endregion DbAthleteFields

//region DbAthleteManager
class DbAthleteManager extends SqfEntityProvider {
  DbAthleteManager()
      : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'athletes';
  static String _colId = 'id';
}

//endregion DbAthleteManager
// region DbActivity
class DbActivity {
  DbActivity(
      {this.id,
      this.state,
      this.path,
      this.stravaId,
      this.name,
      this.movingTime,
      this.type,
      this.distance,
      this.serialNumber,
      this.timeCreated,
      this.sportName,
      this.sport,
      this.subSport,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.event,
      this.eventType,
      this.eventGroup,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.maxRunningCadence,
      this.trigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalTrainingEffect,
      this.necLat,
      this.necLong,
      this.swcLat,
      this.swcLong,
      this.firstLapIndex,
      this.numLaps,
      this.numSessions,
      this.localTimestamp,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.athletesId}) {
    _setDefaultValues();
  }
  DbActivity.withFields(
      this.state,
      this.path,
      this.stravaId,
      this.name,
      this.movingTime,
      this.type,
      this.distance,
      this.serialNumber,
      this.timeCreated,
      this.sportName,
      this.sport,
      this.subSport,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.event,
      this.eventType,
      this.eventGroup,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.maxRunningCadence,
      this.trigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalTrainingEffect,
      this.necLat,
      this.necLong,
      this.swcLat,
      this.swcLong,
      this.firstLapIndex,
      this.numLaps,
      this.numSessions,
      this.localTimestamp,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.athletesId) {
    _setDefaultValues();
  }
  DbActivity.withId(
      this.id,
      this.state,
      this.path,
      this.stravaId,
      this.name,
      this.movingTime,
      this.type,
      this.distance,
      this.serialNumber,
      this.timeCreated,
      this.sportName,
      this.sport,
      this.subSport,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.event,
      this.eventType,
      this.eventGroup,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.maxRunningCadence,
      this.trigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalTrainingEffect,
      this.necLat,
      this.necLong,
      this.swcLat,
      this.swcLong,
      this.firstLapIndex,
      this.numLaps,
      this.numSessions,
      this.localTimestamp,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.athletesId) {
    _setDefaultValues();
  }
  DbActivity.fromMap(Map<String, dynamic> o) {
    id = o['id'] as int;
    state = o['state'] as String;
    path = o['path'] as String;
    stravaId = o['stravaId'] as int;
    name = o['name'] as String;
    movingTime = o['movingTime'] as int;
    type = o['type'] as String;
    distance = o['distance'] as int;
    serialNumber = o['serialNumber'] as int;
    timeCreated = o['timeCreated'] != null
        ? int.tryParse(o['timeCreated'].toString()) != null
            ? DateTime.fromMillisecondsSinceEpoch(o['timeCreated'] as int)
            : DateTime.tryParse(o['timeCreated'].toString())
        : null;
    sportName = o['sportName'] as String;
    sport = o['sport'] as String;
    subSport = o['subSport'] as String;
    timeStamp = o['timeStamp'] != null
        ? int.tryParse(o['timeStamp'].toString()) != null
            ? DateTime.fromMillisecondsSinceEpoch(o['timeStamp'] as int)
            : DateTime.tryParse(o['timeStamp'].toString())
        : null;
    startTime = o['startTime'] != null
        ? int.tryParse(o['startTime'].toString()) != null
            ? DateTime.fromMillisecondsSinceEpoch(o['startTime'] as int)
            : DateTime.tryParse(o['startTime'].toString())
        : null;
    startPositionLat = double.tryParse(o['startPositionLat'].toString());
    startPositionLong = double.tryParse(o['startPositionLong'].toString());
    event = o['event'] as String;
    eventType = o['eventType'] as String;
    eventGroup = o['eventGroup'] as int;
    totalDistance = o['totalDistance'] as int;
    totalStrides = o['totalStrides'] as int;
    totalCalories = o['totalCalories'] as int;
    avgSpeed = double.tryParse(o['avgSpeed'].toString());
    maxSpeed = double.tryParse(o['maxSpeed'].toString());
    totalAscent = o['totalAscent'] as int;
    totalDescent = o['totalDescent'] as int;
    maxRunningCadence = o['maxRunningCadence'] as int;
    trigger = o['trigger'] as String;
    avgTemperature = o['avgTemperature'] as int;
    maxTemperature = o['maxTemperature'] as int;
    avgFractionalCadence =
        double.tryParse(o['avgFractionalCadence'].toString());
    maxFractionalCadence =
        double.tryParse(o['maxFractionalCadence'].toString());
    totalFractionalCycles =
        double.tryParse(o['totalFractionalCycles'].toString());
    avgStanceTimePercent =
        double.tryParse(o['avgStanceTimePercent'].toString());
    avgStanceTime = double.tryParse(o['avgStanceTime'].toString());
    avgHeartRate = o['avgHeartRate'] as int;
    maxHeartRate = o['maxHeartRate'] as int;
    avgRunningCadence = double.tryParse(o['avgRunningCadence'].toString());
    avgVerticalOscillation =
        double.tryParse(o['avgVerticalOscillation'].toString());
    totalElapsedTime = o['totalElapsedTime'] as int;
    totalTimerTime = o['totalTimerTime'] as int;
    totalTrainingEffect = o['totalTrainingEffect'] as int;
    necLat = double.tryParse(o['necLat'].toString());
    necLong = double.tryParse(o['necLong'].toString());
    swcLat = double.tryParse(o['swcLat'].toString());
    swcLong = double.tryParse(o['swcLong'].toString());
    firstLapIndex = o['firstLapIndex'] as int;
    numLaps = o['numLaps'] as int;
    numSessions = o['numSessions'] as int;
    localTimestamp = o['localTimestamp'] != null
        ? int.tryParse(o['localTimestamp'].toString()) != null
            ? DateTime.fromMillisecondsSinceEpoch(o['localTimestamp'] as int)
            : DateTime.tryParse(o['localTimestamp'].toString())
        : null;
    avgPower = double.tryParse(o['avgPower'].toString());
    minPower = o['minPower'] as int;
    maxPower = o['maxPower'] as int;
    sdevPower = double.tryParse(o['sdevPower'].toString());
    avgGroundTime = double.tryParse(o['avgGroundTime'].toString());
    sdevGroundTime = double.tryParse(o['sdevGroundTime'].toString());
    avgLegSpringStiffness =
        double.tryParse(o['avgLegSpringStiffness'].toString());
    sdevLegSpringStiffness =
        double.tryParse(o['sdevLegSpringStiffness'].toString());
    avgFormPower = double.tryParse(o['avgFormPower'].toString());
    sdevFormPower = double.tryParse(o['sdevFormPower'].toString());
    avgPowerRatio = double.tryParse(o['avgPowerRatio'].toString());
    sdevPowerRatio = double.tryParse(o['sdevPowerRatio'].toString());
    avgStrydCadence = double.tryParse(o['avgStrydCadence'].toString());
    sdevStrydCadence = double.tryParse(o['sdevStrydCadence'].toString());
    sdevVerticalOscillation =
        double.tryParse(o['sdevVerticalOscillation'].toString());
    athletesId = o['athletesId'] as int;
  }
  // FIELDS (DbActivity)
  int id;
  String state;
  String path;
  int stravaId;
  String name;
  int movingTime;
  String type;
  int distance;
  int serialNumber;
  DateTime timeCreated;
  String sportName;
  String sport;
  String subSport;
  DateTime timeStamp;
  DateTime startTime;
  double startPositionLat;
  double startPositionLong;
  String event;
  String eventType;
  int eventGroup;
  int totalDistance;
  int totalStrides;
  int totalCalories;
  double avgSpeed;
  double maxSpeed;
  int totalAscent;
  int totalDescent;
  int maxRunningCadence;
  String trigger;
  int avgTemperature;
  int maxTemperature;
  double avgFractionalCadence;
  double maxFractionalCadence;
  double totalFractionalCycles;
  double avgStanceTimePercent;
  double avgStanceTime;
  int avgHeartRate;
  int maxHeartRate;
  double avgRunningCadence;
  double avgVerticalOscillation;
  int totalElapsedTime;
  int totalTimerTime;
  int totalTrainingEffect;
  double necLat;
  double necLong;
  double swcLat;
  double swcLong;
  int firstLapIndex;
  int numLaps;
  int numSessions;
  DateTime localTimestamp;
  double avgPower;
  int minPower;
  int maxPower;
  double sdevPower;
  double avgGroundTime;
  double sdevGroundTime;
  double avgLegSpringStiffness;
  double sdevLegSpringStiffness;
  double avgFormPower;
  double sdevFormPower;
  double avgPowerRatio;
  double sdevPowerRatio;
  double avgStrydCadence;
  double sdevStrydCadence;
  double sdevVerticalOscillation;
  int athletesId;

  BoolResult saveResult;
  // end FIELDS (DbActivity)

// RELATIONSHIPS (DbActivity)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbAthlete plDbAthlete;

  /// get DbAthlete By AthletesId

  Future<DbAthlete> getDbAthlete(
      [VoidCallback Function(DbAthlete o) dbathlete]) async {
    final _obj = await DbAthlete().getById(athletesId);
    if (dbathlete != null) {
      dbathlete(_obj);
    }
    return _obj;
  }
  // END RELATIONSHIPS (DbActivity)

// COLLECTIONS (DbActivity)
  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbEvent> plDbEvents;

  /// get DbEvent(s) filtered by activitiesId=id
  DbEventFilterBuilder getDbEvents(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbEvent()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .activitiesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbLap> plDbLaps;

  /// get DbLap(s) filtered by activitiesId=id
  DbLapFilterBuilder getDbLaps(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLap()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .activitiesId
        .equals(id)
        .and;
  }
// END COLLECTIONS (DbActivity)

  static const bool _softDeleteActivated = false;
  DbActivityManager __mnDbActivity;

  DbActivityManager get _mnDbActivity {
    return __mnDbActivity = __mnDbActivity ?? DbActivityManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (path != null) {
      map['path'] = path;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (movingTime != null) {
      map['movingTime'] = movingTime;
    }

    if (type != null) {
      map['type'] = type;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (serialNumber != null) {
      map['serialNumber'] = serialNumber;
    }

    if (timeCreated != null) {
      map['timeCreated'] = forJson
          ? timeCreated.toUtc().toString()
          : forQuery ? timeCreated.millisecondsSinceEpoch : timeCreated;
    }

    if (sportName != null) {
      map['sportName'] = sportName;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toUtc().toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (trigger != null) {
      map['trigger'] = trigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalTrainingEffect != null) {
      map['totalTrainingEffect'] = totalTrainingEffect;
    }

    if (necLat != null) {
      map['necLat'] = necLat;
    }

    if (necLong != null) {
      map['necLong'] = necLong;
    }

    if (swcLat != null) {
      map['swcLat'] = swcLat;
    }

    if (swcLong != null) {
      map['swcLong'] = swcLong;
    }

    if (firstLapIndex != null) {
      map['firstLapIndex'] = firstLapIndex;
    }

    if (numLaps != null) {
      map['numLaps'] = numLaps;
    }

    if (numSessions != null) {
      map['numSessions'] = numSessions;
    }

    if (localTimestamp != null) {
      map['localTimestamp'] = forJson
          ? localTimestamp.toUtc().toString()
          : forQuery ? localTimestamp.millisecondsSinceEpoch : localTimestamp;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgPowerRatio != null) {
      map['avgPowerRatio'] = avgPowerRatio;
    }

    if (sdevPowerRatio != null) {
      map['sdevPowerRatio'] = sdevPowerRatio;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (athletesId != null) {
      map['athletesId'] = athletesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (path != null) {
      map['path'] = path;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (movingTime != null) {
      map['movingTime'] = movingTime;
    }

    if (type != null) {
      map['type'] = type;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (serialNumber != null) {
      map['serialNumber'] = serialNumber;
    }

    if (timeCreated != null) {
      map['timeCreated'] = forJson
          ? timeCreated.toUtc().toString()
          : forQuery ? timeCreated.millisecondsSinceEpoch : timeCreated;
    }

    if (sportName != null) {
      map['sportName'] = sportName;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toUtc().toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (trigger != null) {
      map['trigger'] = trigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalTrainingEffect != null) {
      map['totalTrainingEffect'] = totalTrainingEffect;
    }

    if (necLat != null) {
      map['necLat'] = necLat;
    }

    if (necLong != null) {
      map['necLong'] = necLong;
    }

    if (swcLat != null) {
      map['swcLat'] = swcLat;
    }

    if (swcLong != null) {
      map['swcLong'] = swcLong;
    }

    if (firstLapIndex != null) {
      map['firstLapIndex'] = firstLapIndex;
    }

    if (numLaps != null) {
      map['numLaps'] = numLaps;
    }

    if (numSessions != null) {
      map['numSessions'] = numSessions;
    }

    if (localTimestamp != null) {
      map['localTimestamp'] = forJson
          ? localTimestamp.toUtc().toString()
          : forQuery ? localTimestamp.millisecondsSinceEpoch : localTimestamp;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgPowerRatio != null) {
      map['avgPowerRatio'] = avgPowerRatio;
    }

    if (sdevPowerRatio != null) {
      map['sdevPowerRatio'] = sdevPowerRatio;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (athletesId != null) {
      map['athletesId'] = athletesId;
    }

// COLLECTIONS (DbActivity)
    if (!forQuery) {
      map['DbEvents'] = await getDbEvents().toMapList();
    }
    if (!forQuery) {
      map['DbLaps'] = await getDbLaps().toMapList();
    }
// END COLLECTIONS (DbActivity)

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      state,
      path,
      stravaId,
      name,
      movingTime,
      type,
      distance,
      serialNumber,
      timeCreated != null ? timeCreated.millisecondsSinceEpoch : null,
      sportName,
      sport,
      subSport,
      timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
      startTime != null ? startTime.millisecondsSinceEpoch : null,
      startPositionLat,
      startPositionLong,
      event,
      eventType,
      eventGroup,
      totalDistance,
      totalStrides,
      totalCalories,
      avgSpeed,
      maxSpeed,
      totalAscent,
      totalDescent,
      maxRunningCadence,
      trigger,
      avgTemperature,
      maxTemperature,
      avgFractionalCadence,
      maxFractionalCadence,
      totalFractionalCycles,
      avgStanceTimePercent,
      avgStanceTime,
      avgHeartRate,
      maxHeartRate,
      avgRunningCadence,
      avgVerticalOscillation,
      totalElapsedTime,
      totalTimerTime,
      totalTrainingEffect,
      necLat,
      necLong,
      swcLat,
      swcLong,
      firstLapIndex,
      numLaps,
      numSessions,
      localTimestamp != null ? localTimestamp.millisecondsSinceEpoch : null,
      avgPower,
      minPower,
      maxPower,
      sdevPower,
      avgGroundTime,
      sdevGroundTime,
      avgLegSpringStiffness,
      sdevLegSpringStiffness,
      avgFormPower,
      sdevFormPower,
      avgPowerRatio,
      sdevPowerRatio,
      avgStrydCadence,
      sdevStrydCadence,
      sdevVerticalOscillation,
      athletesId
    ];
  }

  static Future<List<DbActivity>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbActivity.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbActivity>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbActivity>[];
    try {
      objList = list
          .map((dbactivity) =>
              DbActivity.fromMap(dbactivity as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbActivity.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbActivity>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbActivity.fromMapList(data);
    } 
    */

  static Future<List<DbActivity>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbActivity> objList = <DbActivity>[];
    for (final map in data) {
      final obj = DbActivity.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbEvents')) {
          obj.plDbEvents = await obj.getDbEvents().toList();
        }
        if (preloadFields == null || preloadFields.contains('plDbLaps')) {
          obj.plDbLaps = await obj.getDbLaps().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbAthlete')) {
          obj.plDbAthlete = await obj.getDbAthlete();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbActivity by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbActivity if exist, otherwise returns null
  Future<DbActivity> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbActivity obj;
    final data = await _mnDbActivity.getById(id);
    if (data.length != 0) {
      obj = DbActivity.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbActivity.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbActivity. Returns a new Primary Key value of DbActivity

  /// <returns>Returns a new Primary Key value of DbActivity
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbActivity> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(List<DbActivity> dbactivities) async {
    final results = _mnDbActivity.saveAll(
        'INSERT OR REPLACE INTO activities (id,  state, path, stravaId, name, movingTime, type, distance, serialNumber, timeCreated, sportName, sport, subSport, timeStamp, startTime, startPositionLat, startPositionLong, event, eventType, eventGroup, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, maxRunningCadence, trigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgStanceTimePercent, avgStanceTime, avgHeartRate, maxHeartRate, avgRunningCadence, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalTrainingEffect, necLat, necLong, swcLat, swcLong, firstLapIndex, numLaps, numSessions, localTimestamp, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgPowerRatio, sdevPowerRatio, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, athletesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbactivities);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbActivity.rawInsert(
              'INSERT OR REPLACE INTO activities (id,  state, path, stravaId, name, movingTime, type, distance, serialNumber, timeCreated, sportName, sport, subSport, timeStamp, startTime, startPositionLat, startPositionLong, event, eventType, eventGroup, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, maxRunningCadence, trigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgStanceTimePercent, avgStanceTime, avgHeartRate, maxHeartRate, avgRunningCadence, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalTrainingEffect, necLat, necLong, swcLat, swcLong, firstLapIndex, numLaps, numSessions, localTimestamp, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgPowerRatio, sdevPowerRatio, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, athletesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                state,
                path,
                stravaId,
                name,
                movingTime,
                type,
                distance,
                serialNumber,
                timeCreated != null ? timeCreated.millisecondsSinceEpoch : null,
                sportName,
                sport,
                subSport,
                timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
                startTime != null ? startTime.millisecondsSinceEpoch : null,
                startPositionLat,
                startPositionLong,
                event,
                eventType,
                eventGroup,
                totalDistance,
                totalStrides,
                totalCalories,
                avgSpeed,
                maxSpeed,
                totalAscent,
                totalDescent,
                maxRunningCadence,
                trigger,
                avgTemperature,
                maxTemperature,
                avgFractionalCadence,
                maxFractionalCadence,
                totalFractionalCycles,
                avgStanceTimePercent,
                avgStanceTime,
                avgHeartRate,
                maxHeartRate,
                avgRunningCadence,
                avgVerticalOscillation,
                totalElapsedTime,
                totalTimerTime,
                totalTrainingEffect,
                necLat,
                necLong,
                swcLat,
                swcLong,
                firstLapIndex,
                numLaps,
                numSessions,
                localTimestamp != null
                    ? localTimestamp.millisecondsSinceEpoch
                    : null,
                avgPower,
                minPower,
                maxPower,
                sdevPower,
                avgGroundTime,
                sdevGroundTime,
                avgLegSpringStiffness,
                sdevLegSpringStiffness,
                avgFormPower,
                sdevFormPower,
                avgPowerRatio,
                sdevPowerRatio,
                avgStrydCadence,
                sdevStrydCadence,
                sdevVerticalOscillation,
                athletesId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbActivity id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbActivity id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbActivity Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbActivity>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(List<DbActivity> dbactivities) async {
    final results = await _mnDbActivity.rawInsertAll(
        'INSERT OR REPLACE INTO activities (id,  state, path, stravaId, name, movingTime, type, distance, serialNumber, timeCreated, sportName, sport, subSport, timeStamp, startTime, startPositionLat, startPositionLong, event, eventType, eventGroup, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, maxRunningCadence, trigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgStanceTimePercent, avgStanceTime, avgHeartRate, maxHeartRate, avgRunningCadence, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalTrainingEffect, necLat, necLong, swcLat, swcLong, firstLapIndex, numLaps, numSessions, localTimestamp, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgPowerRatio, sdevPowerRatio, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, athletesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbactivities);
    return results;
  }

  /// Deletes DbActivity

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbActivity invoked (id=$id)');
    var result = BoolResult();
    {
      result =
          await DbEvent().select().activitiesId.equals(id).delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result =
          await DbLap().select().activitiesId.equals(id).delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbActivity
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbActivity.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbActivityFilterBuilder _Select;
  DbActivityFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbActivityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbActivityFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbActivityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    state = state ?? 'new';
    athletesId = athletesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbactivity

// region DbActivityField
class DbActivityField extends SearchCriteria {
  DbActivityField(this.dbactivityFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbActivityFilterBuilder dbactivityFB;

  DbActivityField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbActivityFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param, SqlSyntax.EQuals,
            dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.NotEQuals, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder isNull() {
    dbactivityFB._addedBlocks = setCriteria(
        0,
        dbactivityFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbactivityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbactivityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks);
      _waitingNot = '';
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
    }
    return dbactivityFB;
  }

  DbActivityFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbactivityFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbactivityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks);
      _waitingNot = '';
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
    }
    return dbactivityFB;
  }

  DbActivityFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbactivityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbactivityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks);
      _waitingNot = '';
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
    }
    return dbactivityFB;
  }

  DbActivityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbactivityFB._addedBlocks = setCriteria(
          pFirst,
          dbactivityFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbactivityFB._addedBlocks = setCriteria(pFirst, dbactivityFB.parameters,
            param, SqlSyntax.LessThan, dbactivityFB._addedBlocks);
      } else {
        dbactivityFB._addedBlocks = setCriteria(pFirst, dbactivityFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbactivityFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbactivityFB._addedBlocks = setCriteria(pLast, dbactivityFB.parameters,
            param, SqlSyntax.GreaterThan, dbactivityFB._addedBlocks);
      } else {
        dbactivityFB._addedBlocks = setCriteria(pLast, dbactivityFB.parameters,
            param, SqlSyntax.LessThanOrEquals, dbactivityFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThan, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThan, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThan, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThan, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder inValues(dynamic pValue) {
    dbactivityFB._addedBlocks = setCriteria(
        pValue,
        dbactivityFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }
}
// endregion DbActivityField

// region DbActivityFilterBuilder
class DbActivityFilterBuilder extends SearchCriteria {
  DbActivityFilterBuilder(DbActivity obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbActivity _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbActivityFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbActivityFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbActivityFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbActivityFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbActivityFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbActivityFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbActivityFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbActivityFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbActivityFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbActivityFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbActivityField setField(
      DbActivityField field, String colName, DbType dbtype) {
    return DbActivityField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbActivityField _id;
  DbActivityField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbActivityField _state;
  DbActivityField get state {
    return _state = setField(_state, 'state', DbType.text);
  }

  DbActivityField _path;
  DbActivityField get path {
    return _path = setField(_path, 'path', DbType.text);
  }

  DbActivityField _stravaId;
  DbActivityField get stravaId {
    return _stravaId = setField(_stravaId, 'stravaId', DbType.integer);
  }

  DbActivityField _name;
  DbActivityField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbActivityField _movingTime;
  DbActivityField get movingTime {
    return _movingTime = setField(_movingTime, 'movingTime', DbType.integer);
  }

  DbActivityField _type;
  DbActivityField get type {
    return _type = setField(_type, 'type', DbType.text);
  }

  DbActivityField _distance;
  DbActivityField get distance {
    return _distance = setField(_distance, 'distance', DbType.integer);
  }

  DbActivityField _serialNumber;
  DbActivityField get serialNumber {
    return _serialNumber =
        setField(_serialNumber, 'serialNumber', DbType.integer);
  }

  DbActivityField _timeCreated;
  DbActivityField get timeCreated {
    return _timeCreated =
        setField(_timeCreated, 'timeCreated', DbType.datetime);
  }

  DbActivityField _sportName;
  DbActivityField get sportName {
    return _sportName = setField(_sportName, 'sportName', DbType.text);
  }

  DbActivityField _sport;
  DbActivityField get sport {
    return _sport = setField(_sport, 'sport', DbType.text);
  }

  DbActivityField _subSport;
  DbActivityField get subSport {
    return _subSport = setField(_subSport, 'subSport', DbType.text);
  }

  DbActivityField _timeStamp;
  DbActivityField get timeStamp {
    return _timeStamp = setField(_timeStamp, 'timeStamp', DbType.datetime);
  }

  DbActivityField _startTime;
  DbActivityField get startTime {
    return _startTime = setField(_startTime, 'startTime', DbType.datetime);
  }

  DbActivityField _startPositionLat;
  DbActivityField get startPositionLat {
    return _startPositionLat =
        setField(_startPositionLat, 'startPositionLat', DbType.real);
  }

  DbActivityField _startPositionLong;
  DbActivityField get startPositionLong {
    return _startPositionLong =
        setField(_startPositionLong, 'startPositionLong', DbType.real);
  }

  DbActivityField _event;
  DbActivityField get event {
    return _event = setField(_event, 'event', DbType.text);
  }

  DbActivityField _eventType;
  DbActivityField get eventType {
    return _eventType = setField(_eventType, 'eventType', DbType.text);
  }

  DbActivityField _eventGroup;
  DbActivityField get eventGroup {
    return _eventGroup = setField(_eventGroup, 'eventGroup', DbType.integer);
  }

  DbActivityField _totalDistance;
  DbActivityField get totalDistance {
    return _totalDistance =
        setField(_totalDistance, 'totalDistance', DbType.integer);
  }

  DbActivityField _totalStrides;
  DbActivityField get totalStrides {
    return _totalStrides =
        setField(_totalStrides, 'totalStrides', DbType.integer);
  }

  DbActivityField _totalCalories;
  DbActivityField get totalCalories {
    return _totalCalories =
        setField(_totalCalories, 'totalCalories', DbType.integer);
  }

  DbActivityField _avgSpeed;
  DbActivityField get avgSpeed {
    return _avgSpeed = setField(_avgSpeed, 'avgSpeed', DbType.real);
  }

  DbActivityField _maxSpeed;
  DbActivityField get maxSpeed {
    return _maxSpeed = setField(_maxSpeed, 'maxSpeed', DbType.real);
  }

  DbActivityField _totalAscent;
  DbActivityField get totalAscent {
    return _totalAscent = setField(_totalAscent, 'totalAscent', DbType.integer);
  }

  DbActivityField _totalDescent;
  DbActivityField get totalDescent {
    return _totalDescent =
        setField(_totalDescent, 'totalDescent', DbType.integer);
  }

  DbActivityField _maxRunningCadence;
  DbActivityField get maxRunningCadence {
    return _maxRunningCadence =
        setField(_maxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  DbActivityField _trigger;
  DbActivityField get trigger {
    return _trigger = setField(_trigger, 'trigger', DbType.text);
  }

  DbActivityField _avgTemperature;
  DbActivityField get avgTemperature {
    return _avgTemperature =
        setField(_avgTemperature, 'avgTemperature', DbType.integer);
  }

  DbActivityField _maxTemperature;
  DbActivityField get maxTemperature {
    return _maxTemperature =
        setField(_maxTemperature, 'maxTemperature', DbType.integer);
  }

  DbActivityField _avgFractionalCadence;
  DbActivityField get avgFractionalCadence {
    return _avgFractionalCadence =
        setField(_avgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  DbActivityField _maxFractionalCadence;
  DbActivityField get maxFractionalCadence {
    return _maxFractionalCadence =
        setField(_maxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  DbActivityField _totalFractionalCycles;
  DbActivityField get totalFractionalCycles {
    return _totalFractionalCycles =
        setField(_totalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  DbActivityField _avgStanceTimePercent;
  DbActivityField get avgStanceTimePercent {
    return _avgStanceTimePercent =
        setField(_avgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  DbActivityField _avgStanceTime;
  DbActivityField get avgStanceTime {
    return _avgStanceTime =
        setField(_avgStanceTime, 'avgStanceTime', DbType.real);
  }

  DbActivityField _avgHeartRate;
  DbActivityField get avgHeartRate {
    return _avgHeartRate =
        setField(_avgHeartRate, 'avgHeartRate', DbType.integer);
  }

  DbActivityField _maxHeartRate;
  DbActivityField get maxHeartRate {
    return _maxHeartRate =
        setField(_maxHeartRate, 'maxHeartRate', DbType.integer);
  }

  DbActivityField _avgRunningCadence;
  DbActivityField get avgRunningCadence {
    return _avgRunningCadence =
        setField(_avgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  DbActivityField _avgVerticalOscillation;
  DbActivityField get avgVerticalOscillation {
    return _avgVerticalOscillation = setField(
        _avgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  DbActivityField _totalElapsedTime;
  DbActivityField get totalElapsedTime {
    return _totalElapsedTime =
        setField(_totalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  DbActivityField _totalTimerTime;
  DbActivityField get totalTimerTime {
    return _totalTimerTime =
        setField(_totalTimerTime, 'totalTimerTime', DbType.integer);
  }

  DbActivityField _totalTrainingEffect;
  DbActivityField get totalTrainingEffect {
    return _totalTrainingEffect =
        setField(_totalTrainingEffect, 'totalTrainingEffect', DbType.integer);
  }

  DbActivityField _necLat;
  DbActivityField get necLat {
    return _necLat = setField(_necLat, 'necLat', DbType.real);
  }

  DbActivityField _necLong;
  DbActivityField get necLong {
    return _necLong = setField(_necLong, 'necLong', DbType.real);
  }

  DbActivityField _swcLat;
  DbActivityField get swcLat {
    return _swcLat = setField(_swcLat, 'swcLat', DbType.real);
  }

  DbActivityField _swcLong;
  DbActivityField get swcLong {
    return _swcLong = setField(_swcLong, 'swcLong', DbType.real);
  }

  DbActivityField _firstLapIndex;
  DbActivityField get firstLapIndex {
    return _firstLapIndex =
        setField(_firstLapIndex, 'firstLapIndex', DbType.integer);
  }

  DbActivityField _numLaps;
  DbActivityField get numLaps {
    return _numLaps = setField(_numLaps, 'numLaps', DbType.integer);
  }

  DbActivityField _numSessions;
  DbActivityField get numSessions {
    return _numSessions = setField(_numSessions, 'numSessions', DbType.integer);
  }

  DbActivityField _localTimestamp;
  DbActivityField get localTimestamp {
    return _localTimestamp =
        setField(_localTimestamp, 'localTimestamp', DbType.datetime);
  }

  DbActivityField _avgPower;
  DbActivityField get avgPower {
    return _avgPower = setField(_avgPower, 'avgPower', DbType.real);
  }

  DbActivityField _minPower;
  DbActivityField get minPower {
    return _minPower = setField(_minPower, 'minPower', DbType.integer);
  }

  DbActivityField _maxPower;
  DbActivityField get maxPower {
    return _maxPower = setField(_maxPower, 'maxPower', DbType.integer);
  }

  DbActivityField _sdevPower;
  DbActivityField get sdevPower {
    return _sdevPower = setField(_sdevPower, 'sdevPower', DbType.real);
  }

  DbActivityField _avgGroundTime;
  DbActivityField get avgGroundTime {
    return _avgGroundTime =
        setField(_avgGroundTime, 'avgGroundTime', DbType.real);
  }

  DbActivityField _sdevGroundTime;
  DbActivityField get sdevGroundTime {
    return _sdevGroundTime =
        setField(_sdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  DbActivityField _avgLegSpringStiffness;
  DbActivityField get avgLegSpringStiffness {
    return _avgLegSpringStiffness =
        setField(_avgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  DbActivityField _sdevLegSpringStiffness;
  DbActivityField get sdevLegSpringStiffness {
    return _sdevLegSpringStiffness = setField(
        _sdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  DbActivityField _avgFormPower;
  DbActivityField get avgFormPower {
    return _avgFormPower = setField(_avgFormPower, 'avgFormPower', DbType.real);
  }

  DbActivityField _sdevFormPower;
  DbActivityField get sdevFormPower {
    return _sdevFormPower =
        setField(_sdevFormPower, 'sdevFormPower', DbType.real);
  }

  DbActivityField _avgPowerRatio;
  DbActivityField get avgPowerRatio {
    return _avgPowerRatio =
        setField(_avgPowerRatio, 'avgPowerRatio', DbType.real);
  }

  DbActivityField _sdevPowerRatio;
  DbActivityField get sdevPowerRatio {
    return _sdevPowerRatio =
        setField(_sdevPowerRatio, 'sdevPowerRatio', DbType.real);
  }

  DbActivityField _avgStrydCadence;
  DbActivityField get avgStrydCadence {
    return _avgStrydCadence =
        setField(_avgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  DbActivityField _sdevStrydCadence;
  DbActivityField get sdevStrydCadence {
    return _sdevStrydCadence =
        setField(_sdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  DbActivityField _sdevVerticalOscillation;
  DbActivityField get sdevVerticalOscillation {
    return _sdevVerticalOscillation = setField(
        _sdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  DbActivityField _athletesId;
  DbActivityField get athletesId {
    return _athletesId = setField(_athletesId, 'athletesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbActivity._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbActivity> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbActivity._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbActivity.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbActivity.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from activities ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbActivity.updateBatch(qparams, values);
  }

  /// This method always returns DbActivityObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbActivity>
  Future<DbActivity> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbActivity.toList(qparams);
    final data = await objFuture;
    DbActivity obj;
    if (data.isNotEmpty) {
      obj = DbActivity.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbEvents')) {
          obj.plDbEvents = await obj.getDbEvents().toList();
        }
        if (preloadFields == null || preloadFields.contains('plDbLaps')) {
          obj.plDbLaps = await obj.getDbLaps().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbAthlete')) {
          obj.plDbAthlete = await obj.getDbAthlete();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbactivityCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbactivitiesFuture = await _obj._mnDbActivity.toList(qparams);
    final int count = dbactivitiesFuture[0]['CNT'] as int;
    if (dbactivityCount != null) {
      dbactivityCount(count);
    }
    return count;
  }

  /// This method always returns List<DbActivity>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbActivity>
  Future<List<DbActivity>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbActivity> dbactivitiesData =
        await DbActivity.fromMapList(data, preload: preload);
    return dbactivitiesData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbActivity.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbActivity>>
  Future<List<DropdownMenuItem<DbActivity>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbActivity>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dbactivitiesFuture = _obj._mnDbActivity.toList(qparams);

    final data = await dbactivitiesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbActivity>> items = []..add(DropdownMenuItem(
        value: DbActivity(),
        child: Text('Select DbActivity'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbActivity.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dbactivitiesFuture = _obj._mnDbActivity.toList(qparams);

    final data = await dbactivitiesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbActivity'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbActivity.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbActivity.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbActivity.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbActivity.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbActivityFilterBuilder

// region DbActivityFields
class DbActivityFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fState;
  static TableField get state {
    return _fState =
        _fState ?? SqlSyntax.setField(_fState, 'state', DbType.text);
  }

  static TableField _fPath;
  static TableField get path {
    return _fPath = _fPath ?? SqlSyntax.setField(_fPath, 'path', DbType.text);
  }

  static TableField _fStravaId;
  static TableField get stravaId {
    return _fStravaId = _fStravaId ??
        SqlSyntax.setField(_fStravaId, 'stravaId', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fMovingTime;
  static TableField get movingTime {
    return _fMovingTime = _fMovingTime ??
        SqlSyntax.setField(_fMovingTime, 'movingTime', DbType.integer);
  }

  static TableField _fType;
  static TableField get type {
    return _fType = _fType ?? SqlSyntax.setField(_fType, 'type', DbType.text);
  }

  static TableField _fDistance;
  static TableField get distance {
    return _fDistance = _fDistance ??
        SqlSyntax.setField(_fDistance, 'distance', DbType.integer);
  }

  static TableField _fSerialNumber;
  static TableField get serialNumber {
    return _fSerialNumber = _fSerialNumber ??
        SqlSyntax.setField(_fSerialNumber, 'serialNumber', DbType.integer);
  }

  static TableField _fTimeCreated;
  static TableField get timeCreated {
    return _fTimeCreated = _fTimeCreated ??
        SqlSyntax.setField(_fTimeCreated, 'timeCreated', DbType.datetime);
  }

  static TableField _fSportName;
  static TableField get sportName {
    return _fSportName = _fSportName ??
        SqlSyntax.setField(_fSportName, 'sportName', DbType.text);
  }

  static TableField _fSport;
  static TableField get sport {
    return _fSport =
        _fSport ?? SqlSyntax.setField(_fSport, 'sport', DbType.text);
  }

  static TableField _fSubSport;
  static TableField get subSport {
    return _fSubSport =
        _fSubSport ?? SqlSyntax.setField(_fSubSport, 'subSport', DbType.text);
  }

  static TableField _fTimeStamp;
  static TableField get timeStamp {
    return _fTimeStamp = _fTimeStamp ??
        SqlSyntax.setField(_fTimeStamp, 'timeStamp', DbType.datetime);
  }

  static TableField _fStartTime;
  static TableField get startTime {
    return _fStartTime = _fStartTime ??
        SqlSyntax.setField(_fStartTime, 'startTime', DbType.datetime);
  }

  static TableField _fStartPositionLat;
  static TableField get startPositionLat {
    return _fStartPositionLat = _fStartPositionLat ??
        SqlSyntax.setField(_fStartPositionLat, 'startPositionLat', DbType.real);
  }

  static TableField _fStartPositionLong;
  static TableField get startPositionLong {
    return _fStartPositionLong = _fStartPositionLong ??
        SqlSyntax.setField(
            _fStartPositionLong, 'startPositionLong', DbType.real);
  }

  static TableField _fEvent;
  static TableField get event {
    return _fEvent =
        _fEvent ?? SqlSyntax.setField(_fEvent, 'event', DbType.text);
  }

  static TableField _fEventType;
  static TableField get eventType {
    return _fEventType = _fEventType ??
        SqlSyntax.setField(_fEventType, 'eventType', DbType.text);
  }

  static TableField _fEventGroup;
  static TableField get eventGroup {
    return _fEventGroup = _fEventGroup ??
        SqlSyntax.setField(_fEventGroup, 'eventGroup', DbType.integer);
  }

  static TableField _fTotalDistance;
  static TableField get totalDistance {
    return _fTotalDistance = _fTotalDistance ??
        SqlSyntax.setField(_fTotalDistance, 'totalDistance', DbType.integer);
  }

  static TableField _fTotalStrides;
  static TableField get totalStrides {
    return _fTotalStrides = _fTotalStrides ??
        SqlSyntax.setField(_fTotalStrides, 'totalStrides', DbType.integer);
  }

  static TableField _fTotalCalories;
  static TableField get totalCalories {
    return _fTotalCalories = _fTotalCalories ??
        SqlSyntax.setField(_fTotalCalories, 'totalCalories', DbType.integer);
  }

  static TableField _fAvgSpeed;
  static TableField get avgSpeed {
    return _fAvgSpeed =
        _fAvgSpeed ?? SqlSyntax.setField(_fAvgSpeed, 'avgSpeed', DbType.real);
  }

  static TableField _fMaxSpeed;
  static TableField get maxSpeed {
    return _fMaxSpeed =
        _fMaxSpeed ?? SqlSyntax.setField(_fMaxSpeed, 'maxSpeed', DbType.real);
  }

  static TableField _fTotalAscent;
  static TableField get totalAscent {
    return _fTotalAscent = _fTotalAscent ??
        SqlSyntax.setField(_fTotalAscent, 'totalAscent', DbType.integer);
  }

  static TableField _fTotalDescent;
  static TableField get totalDescent {
    return _fTotalDescent = _fTotalDescent ??
        SqlSyntax.setField(_fTotalDescent, 'totalDescent', DbType.integer);
  }

  static TableField _fMaxRunningCadence;
  static TableField get maxRunningCadence {
    return _fMaxRunningCadence = _fMaxRunningCadence ??
        SqlSyntax.setField(
            _fMaxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  static TableField _fTrigger;
  static TableField get trigger {
    return _fTrigger =
        _fTrigger ?? SqlSyntax.setField(_fTrigger, 'trigger', DbType.text);
  }

  static TableField _fAvgTemperature;
  static TableField get avgTemperature {
    return _fAvgTemperature = _fAvgTemperature ??
        SqlSyntax.setField(_fAvgTemperature, 'avgTemperature', DbType.integer);
  }

  static TableField _fMaxTemperature;
  static TableField get maxTemperature {
    return _fMaxTemperature = _fMaxTemperature ??
        SqlSyntax.setField(_fMaxTemperature, 'maxTemperature', DbType.integer);
  }

  static TableField _fAvgFractionalCadence;
  static TableField get avgFractionalCadence {
    return _fAvgFractionalCadence = _fAvgFractionalCadence ??
        SqlSyntax.setField(
            _fAvgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  static TableField _fMaxFractionalCadence;
  static TableField get maxFractionalCadence {
    return _fMaxFractionalCadence = _fMaxFractionalCadence ??
        SqlSyntax.setField(
            _fMaxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  static TableField _fTotalFractionalCycles;
  static TableField get totalFractionalCycles {
    return _fTotalFractionalCycles = _fTotalFractionalCycles ??
        SqlSyntax.setField(
            _fTotalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  static TableField _fAvgStanceTimePercent;
  static TableField get avgStanceTimePercent {
    return _fAvgStanceTimePercent = _fAvgStanceTimePercent ??
        SqlSyntax.setField(
            _fAvgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  static TableField _fAvgStanceTime;
  static TableField get avgStanceTime {
    return _fAvgStanceTime = _fAvgStanceTime ??
        SqlSyntax.setField(_fAvgStanceTime, 'avgStanceTime', DbType.real);
  }

  static TableField _fAvgHeartRate;
  static TableField get avgHeartRate {
    return _fAvgHeartRate = _fAvgHeartRate ??
        SqlSyntax.setField(_fAvgHeartRate, 'avgHeartRate', DbType.integer);
  }

  static TableField _fMaxHeartRate;
  static TableField get maxHeartRate {
    return _fMaxHeartRate = _fMaxHeartRate ??
        SqlSyntax.setField(_fMaxHeartRate, 'maxHeartRate', DbType.integer);
  }

  static TableField _fAvgRunningCadence;
  static TableField get avgRunningCadence {
    return _fAvgRunningCadence = _fAvgRunningCadence ??
        SqlSyntax.setField(
            _fAvgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  static TableField _fAvgVerticalOscillation;
  static TableField get avgVerticalOscillation {
    return _fAvgVerticalOscillation = _fAvgVerticalOscillation ??
        SqlSyntax.setField(
            _fAvgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  static TableField _fTotalElapsedTime;
  static TableField get totalElapsedTime {
    return _fTotalElapsedTime = _fTotalElapsedTime ??
        SqlSyntax.setField(
            _fTotalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  static TableField _fTotalTimerTime;
  static TableField get totalTimerTime {
    return _fTotalTimerTime = _fTotalTimerTime ??
        SqlSyntax.setField(_fTotalTimerTime, 'totalTimerTime', DbType.integer);
  }

  static TableField _fTotalTrainingEffect;
  static TableField get totalTrainingEffect {
    return _fTotalTrainingEffect = _fTotalTrainingEffect ??
        SqlSyntax.setField(
            _fTotalTrainingEffect, 'totalTrainingEffect', DbType.integer);
  }

  static TableField _fNecLat;
  static TableField get necLat {
    return _fNecLat =
        _fNecLat ?? SqlSyntax.setField(_fNecLat, 'necLat', DbType.real);
  }

  static TableField _fNecLong;
  static TableField get necLong {
    return _fNecLong =
        _fNecLong ?? SqlSyntax.setField(_fNecLong, 'necLong', DbType.real);
  }

  static TableField _fSwcLat;
  static TableField get swcLat {
    return _fSwcLat =
        _fSwcLat ?? SqlSyntax.setField(_fSwcLat, 'swcLat', DbType.real);
  }

  static TableField _fSwcLong;
  static TableField get swcLong {
    return _fSwcLong =
        _fSwcLong ?? SqlSyntax.setField(_fSwcLong, 'swcLong', DbType.real);
  }

  static TableField _fFirstLapIndex;
  static TableField get firstLapIndex {
    return _fFirstLapIndex = _fFirstLapIndex ??
        SqlSyntax.setField(_fFirstLapIndex, 'firstLapIndex', DbType.integer);
  }

  static TableField _fNumLaps;
  static TableField get numLaps {
    return _fNumLaps =
        _fNumLaps ?? SqlSyntax.setField(_fNumLaps, 'numLaps', DbType.integer);
  }

  static TableField _fNumSessions;
  static TableField get numSessions {
    return _fNumSessions = _fNumSessions ??
        SqlSyntax.setField(_fNumSessions, 'numSessions', DbType.integer);
  }

  static TableField _fLocalTimestamp;
  static TableField get localTimestamp {
    return _fLocalTimestamp = _fLocalTimestamp ??
        SqlSyntax.setField(_fLocalTimestamp, 'localTimestamp', DbType.datetime);
  }

  static TableField _fAvgPower;
  static TableField get avgPower {
    return _fAvgPower =
        _fAvgPower ?? SqlSyntax.setField(_fAvgPower, 'avgPower', DbType.real);
  }

  static TableField _fMinPower;
  static TableField get minPower {
    return _fMinPower = _fMinPower ??
        SqlSyntax.setField(_fMinPower, 'minPower', DbType.integer);
  }

  static TableField _fMaxPower;
  static TableField get maxPower {
    return _fMaxPower = _fMaxPower ??
        SqlSyntax.setField(_fMaxPower, 'maxPower', DbType.integer);
  }

  static TableField _fSdevPower;
  static TableField get sdevPower {
    return _fSdevPower = _fSdevPower ??
        SqlSyntax.setField(_fSdevPower, 'sdevPower', DbType.real);
  }

  static TableField _fAvgGroundTime;
  static TableField get avgGroundTime {
    return _fAvgGroundTime = _fAvgGroundTime ??
        SqlSyntax.setField(_fAvgGroundTime, 'avgGroundTime', DbType.real);
  }

  static TableField _fSdevGroundTime;
  static TableField get sdevGroundTime {
    return _fSdevGroundTime = _fSdevGroundTime ??
        SqlSyntax.setField(_fSdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  static TableField _fAvgLegSpringStiffness;
  static TableField get avgLegSpringStiffness {
    return _fAvgLegSpringStiffness = _fAvgLegSpringStiffness ??
        SqlSyntax.setField(
            _fAvgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  static TableField _fSdevLegSpringStiffness;
  static TableField get sdevLegSpringStiffness {
    return _fSdevLegSpringStiffness = _fSdevLegSpringStiffness ??
        SqlSyntax.setField(
            _fSdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  static TableField _fAvgFormPower;
  static TableField get avgFormPower {
    return _fAvgFormPower = _fAvgFormPower ??
        SqlSyntax.setField(_fAvgFormPower, 'avgFormPower', DbType.real);
  }

  static TableField _fSdevFormPower;
  static TableField get sdevFormPower {
    return _fSdevFormPower = _fSdevFormPower ??
        SqlSyntax.setField(_fSdevFormPower, 'sdevFormPower', DbType.real);
  }

  static TableField _fAvgPowerRatio;
  static TableField get avgPowerRatio {
    return _fAvgPowerRatio = _fAvgPowerRatio ??
        SqlSyntax.setField(_fAvgPowerRatio, 'avgPowerRatio', DbType.real);
  }

  static TableField _fSdevPowerRatio;
  static TableField get sdevPowerRatio {
    return _fSdevPowerRatio = _fSdevPowerRatio ??
        SqlSyntax.setField(_fSdevPowerRatio, 'sdevPowerRatio', DbType.real);
  }

  static TableField _fAvgStrydCadence;
  static TableField get avgStrydCadence {
    return _fAvgStrydCadence = _fAvgStrydCadence ??
        SqlSyntax.setField(_fAvgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  static TableField _fSdevStrydCadence;
  static TableField get sdevStrydCadence {
    return _fSdevStrydCadence = _fSdevStrydCadence ??
        SqlSyntax.setField(_fSdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  static TableField _fSdevVerticalOscillation;
  static TableField get sdevVerticalOscillation {
    return _fSdevVerticalOscillation = _fSdevVerticalOscillation ??
        SqlSyntax.setField(
            _fSdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  static TableField _fAthletesId;
  static TableField get athletesId {
    return _fAthletesId = _fAthletesId ??
        SqlSyntax.setField(_fAthletesId, 'athletesId', DbType.integer);
  }
}
// endregion DbActivityFields

//region DbActivityManager
class DbActivityManager extends SqfEntityProvider {
  DbActivityManager()
      : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'activities';
  static String _colId = 'id';
}

//endregion DbActivityManager
// region DbEvent
class DbEvent {
  DbEvent(
      {this.id,
      this.event,
      this.eventType,
      this.eventGroup,
      this.timerTrigger,
      this.timeStamp,
      this.positionLat,
      this.positionLong,
      this.distance,
      this.altitude,
      this.speed,
      this.heartRate,
      this.cadence,
      this.fractionalCadence,
      this.power,
      this.strydCadence,
      this.groundTime,
      this.verticalOscillation,
      this.formPower,
      this.legSpringStiffness,
      this.data,
      this.activitiesId,
      this.lapsId}) {
    _setDefaultValues();
  }
  DbEvent.withFields(
      this.event,
      this.eventType,
      this.eventGroup,
      this.timerTrigger,
      this.timeStamp,
      this.positionLat,
      this.positionLong,
      this.distance,
      this.altitude,
      this.speed,
      this.heartRate,
      this.cadence,
      this.fractionalCadence,
      this.power,
      this.strydCadence,
      this.groundTime,
      this.verticalOscillation,
      this.formPower,
      this.legSpringStiffness,
      this.data,
      this.activitiesId,
      this.lapsId) {
    _setDefaultValues();
  }
  DbEvent.withId(
      this.id,
      this.event,
      this.eventType,
      this.eventGroup,
      this.timerTrigger,
      this.timeStamp,
      this.positionLat,
      this.positionLong,
      this.distance,
      this.altitude,
      this.speed,
      this.heartRate,
      this.cadence,
      this.fractionalCadence,
      this.power,
      this.strydCadence,
      this.groundTime,
      this.verticalOscillation,
      this.formPower,
      this.legSpringStiffness,
      this.data,
      this.activitiesId,
      this.lapsId) {
    _setDefaultValues();
  }
  DbEvent.fromMap(Map<String, dynamic> o) {
    id = o['id'] as int;
    event = o['event'] as String;
    eventType = o['eventType'] as String;
    eventGroup = o['eventGroup'] as int;
    timerTrigger = o['timerTrigger'] as String;
    timeStamp = o['timeStamp'] != null
        ? int.tryParse(o['timeStamp'].toString()) != null
            ? DateTime.fromMillisecondsSinceEpoch(o['timeStamp'] as int)
            : DateTime.tryParse(o['timeStamp'].toString())
        : null;
    positionLat = double.tryParse(o['positionLat'].toString());
    positionLong = double.tryParse(o['positionLong'].toString());
    distance = double.tryParse(o['distance'].toString());
    altitude = double.tryParse(o['altitude'].toString());
    speed = double.tryParse(o['speed'].toString());
    heartRate = o['heartRate'] as int;
    cadence = double.tryParse(o['cadence'].toString());
    fractionalCadence = double.tryParse(o['fractionalCadence'].toString());
    power = o['power'] as int;
    strydCadence = double.tryParse(o['strydCadence'].toString());
    groundTime = double.tryParse(o['groundTime'].toString());
    verticalOscillation = double.tryParse(o['verticalOscillation'].toString());
    formPower = o['formPower'] as int;
    legSpringStiffness = double.tryParse(o['legSpringStiffness'].toString());
    data = double.tryParse(o['data'].toString());
    activitiesId = o['activitiesId'] as int;

    lapsId = o['lapsId'] as int;
  }
  // FIELDS (DbEvent)
  int id;
  String event;
  String eventType;
  int eventGroup;
  String timerTrigger;
  DateTime timeStamp;
  double positionLat;
  double positionLong;
  double distance;
  double altitude;
  double speed;
  int heartRate;
  double cadence;
  double fractionalCadence;
  int power;
  double strydCadence;
  double groundTime;
  double verticalOscillation;
  int formPower;
  double legSpringStiffness;
  double data;
  int activitiesId;
  int lapsId;

  BoolResult saveResult;
  // end FIELDS (DbEvent)

// RELATIONSHIPS (DbEvent)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbActivity plDbActivity;

  /// get DbActivity By ActivitiesId

  Future<DbActivity> getDbActivity(
      [VoidCallback Function(DbActivity o) dbactivity]) async {
    final _obj = await DbActivity().getById(activitiesId);
    if (dbactivity != null) {
      dbactivity(_obj);
    }
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbLap plDbLap;

  /// get DbLap By LapsId

  Future<DbLap> getDbLap([VoidCallback Function(DbLap o) dblap]) async {
    final _obj = await DbLap().getById(lapsId);
    if (dblap != null) {
      dblap(_obj);
    }
    return _obj;
  }
  // END RELATIONSHIPS (DbEvent)

  static const bool _softDeleteActivated = false;
  DbEventManager __mnDbEvent;

  DbEventManager get _mnDbEvent {
    return __mnDbEvent = __mnDbEvent ?? DbEventManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (timerTrigger != null) {
      map['timerTrigger'] = timerTrigger;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (positionLat != null) {
      map['positionLat'] = positionLat;
    }

    if (positionLong != null) {
      map['positionLong'] = positionLong;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (altitude != null) {
      map['altitude'] = altitude;
    }

    if (speed != null) {
      map['speed'] = speed;
    }

    if (heartRate != null) {
      map['heartRate'] = heartRate;
    }

    if (cadence != null) {
      map['cadence'] = cadence;
    }

    if (fractionalCadence != null) {
      map['fractionalCadence'] = fractionalCadence;
    }

    if (power != null) {
      map['power'] = power;
    }

    if (strydCadence != null) {
      map['strydCadence'] = strydCadence;
    }

    if (groundTime != null) {
      map['groundTime'] = groundTime;
    }

    if (verticalOscillation != null) {
      map['verticalOscillation'] = verticalOscillation;
    }

    if (formPower != null) {
      map['formPower'] = formPower;
    }

    if (legSpringStiffness != null) {
      map['legSpringStiffness'] = legSpringStiffness;
    }

    if (data != null) {
      map['data'] = data;
    }

    if (activitiesId != null) {
      map['activitiesId'] = activitiesId;
    }

    if (lapsId != null) {
      map['lapsId'] = lapsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (timerTrigger != null) {
      map['timerTrigger'] = timerTrigger;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (positionLat != null) {
      map['positionLat'] = positionLat;
    }

    if (positionLong != null) {
      map['positionLong'] = positionLong;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (altitude != null) {
      map['altitude'] = altitude;
    }

    if (speed != null) {
      map['speed'] = speed;
    }

    if (heartRate != null) {
      map['heartRate'] = heartRate;
    }

    if (cadence != null) {
      map['cadence'] = cadence;
    }

    if (fractionalCadence != null) {
      map['fractionalCadence'] = fractionalCadence;
    }

    if (power != null) {
      map['power'] = power;
    }

    if (strydCadence != null) {
      map['strydCadence'] = strydCadence;
    }

    if (groundTime != null) {
      map['groundTime'] = groundTime;
    }

    if (verticalOscillation != null) {
      map['verticalOscillation'] = verticalOscillation;
    }

    if (formPower != null) {
      map['formPower'] = formPower;
    }

    if (legSpringStiffness != null) {
      map['legSpringStiffness'] = legSpringStiffness;
    }

    if (data != null) {
      map['data'] = data;
    }

    if (activitiesId != null) {
      map['activitiesId'] = activitiesId;
    }

    if (lapsId != null) {
      map['lapsId'] = lapsId;
    }

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      event,
      eventType,
      eventGroup,
      timerTrigger,
      timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
      positionLat,
      positionLong,
      distance,
      altitude,
      speed,
      heartRate,
      cadence,
      fractionalCadence,
      power,
      strydCadence,
      groundTime,
      verticalOscillation,
      formPower,
      legSpringStiffness,
      data,
      activitiesId,
      lapsId
    ];
  }

  static Future<List<DbEvent>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbEvent.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbEvent>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbEvent>[];
    try {
      objList = list
          .map((dbevent) => DbEvent.fromMap(dbevent as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR DbEvent.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbEvent>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbEvent.fromMapList(data);
    } 
    */

  static Future<List<DbEvent>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbEvent> objList = <DbEvent>[];
    for (final map in data) {
      final obj = DbEvent.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivity')) {
          obj.plDbActivity = await obj.getDbActivity();
        }
        if (preloadFields == null || preloadFields.contains('plDbLap')) {
          obj.plDbLap = await obj.getDbLap();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbEvent by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbEvent if exist, otherwise returns null
  Future<DbEvent> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbEvent obj;
    final data = await _mnDbEvent.getById(id);
    if (data.length != 0) {
      obj = DbEvent.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbEvent.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbEvent. Returns a new Primary Key value of DbEvent

  /// <returns>Returns a new Primary Key value of DbEvent
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbEvent> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(List<DbEvent> dbevents) async {
    final results = _mnDbEvent.saveAll(
        'INSERT OR REPLACE INTO events (id,  event, eventType, eventGroup, timerTrigger, timeStamp, positionLat, positionLong, distance, altitude, speed, heartRate, cadence, fractionalCadence, power, strydCadence, groundTime, verticalOscillation, formPower, legSpringStiffness, data, activitiesId, lapsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbevents);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbEvent.rawInsert(
              'INSERT OR REPLACE INTO events (id,  event, eventType, eventGroup, timerTrigger, timeStamp, positionLat, positionLong, distance, altitude, speed, heartRate, cadence, fractionalCadence, power, strydCadence, groundTime, verticalOscillation, formPower, legSpringStiffness, data, activitiesId, lapsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                event,
                eventType,
                eventGroup,
                timerTrigger,
                timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
                positionLat,
                positionLong,
                distance,
                altitude,
                speed,
                heartRate,
                cadence,
                fractionalCadence,
                power,
                strydCadence,
                groundTime,
                verticalOscillation,
                formPower,
                legSpringStiffness,
                data,
                activitiesId,
                lapsId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbEvent id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbEvent id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbEvent Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbEvent>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(List<DbEvent> dbevents) async {
    final results = await _mnDbEvent.rawInsertAll(
        'INSERT OR REPLACE INTO events (id,  event, eventType, eventGroup, timerTrigger, timeStamp, positionLat, positionLong, distance, altitude, speed, heartRate, cadence, fractionalCadence, power, strydCadence, groundTime, verticalOscillation, formPower, legSpringStiffness, data, activitiesId, lapsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbevents);
    return results;
  }

  /// Deletes DbEvent

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbEvent invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbEvent
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbEvent.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbEventFilterBuilder _Select;
  DbEventFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbEventFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbEventFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbEventFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    activitiesId = activitiesId ?? 0;
    lapsId = lapsId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbevent

// region DbEventField
class DbEventField extends SearchCriteria {
  DbEventField(this.dbeventFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbEventFilterBuilder dbeventFB;

  DbEventField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbEventFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.EQuals,
            dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.NotEQuals,
            dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder isNull() {
    dbeventFB._addedBlocks = setCriteria(
        0,
        dbeventFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbeventFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbeventFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks);
      _waitingNot = '';
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
    }
    return dbeventFB;
  }

  DbEventFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbeventFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbeventFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks);
      _waitingNot = '';
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
    }
    return dbeventFB;
  }

  DbEventFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbeventFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbeventFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks);
      _waitingNot = '';
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
    }
    return dbeventFB;
  }

  DbEventFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbeventFB._addedBlocks = setCriteria(
          pFirst,
          dbeventFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbeventFB._addedBlocks = setCriteria(pFirst, dbeventFB.parameters,
            param, SqlSyntax.LessThan, dbeventFB._addedBlocks);
      } else {
        dbeventFB._addedBlocks = setCriteria(pFirst, dbeventFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbeventFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbeventFB._addedBlocks = setCriteria(pLast, dbeventFB.parameters, param,
            SqlSyntax.GreaterThan, dbeventFB._addedBlocks);
      } else {
        dbeventFB._addedBlocks = setCriteria(pLast, dbeventFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbeventFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThan, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.LessThan,
            dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.LessThan,
            dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThan, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder inValues(dynamic pValue) {
    dbeventFB._addedBlocks = setCriteria(
        pValue,
        dbeventFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }
}
// endregion DbEventField

// region DbEventFilterBuilder
class DbEventFilterBuilder extends SearchCriteria {
  DbEventFilterBuilder(DbEvent obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbEvent _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbEventFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbEventFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbEventFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbEventFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbEventFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbEventFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbEventFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbEventFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbEventFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbEventFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbEventField setField(DbEventField field, String colName, DbType dbtype) {
    return DbEventField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbEventField _id;
  DbEventField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbEventField _event;
  DbEventField get event {
    return _event = setField(_event, 'event', DbType.text);
  }

  DbEventField _eventType;
  DbEventField get eventType {
    return _eventType = setField(_eventType, 'eventType', DbType.text);
  }

  DbEventField _eventGroup;
  DbEventField get eventGroup {
    return _eventGroup = setField(_eventGroup, 'eventGroup', DbType.integer);
  }

  DbEventField _timerTrigger;
  DbEventField get timerTrigger {
    return _timerTrigger = setField(_timerTrigger, 'timerTrigger', DbType.text);
  }

  DbEventField _timeStamp;
  DbEventField get timeStamp {
    return _timeStamp = setField(_timeStamp, 'timeStamp', DbType.datetime);
  }

  DbEventField _positionLat;
  DbEventField get positionLat {
    return _positionLat = setField(_positionLat, 'positionLat', DbType.real);
  }

  DbEventField _positionLong;
  DbEventField get positionLong {
    return _positionLong = setField(_positionLong, 'positionLong', DbType.real);
  }

  DbEventField _distance;
  DbEventField get distance {
    return _distance = setField(_distance, 'distance', DbType.real);
  }

  DbEventField _altitude;
  DbEventField get altitude {
    return _altitude = setField(_altitude, 'altitude', DbType.real);
  }

  DbEventField _speed;
  DbEventField get speed {
    return _speed = setField(_speed, 'speed', DbType.real);
  }

  DbEventField _heartRate;
  DbEventField get heartRate {
    return _heartRate = setField(_heartRate, 'heartRate', DbType.integer);
  }

  DbEventField _cadence;
  DbEventField get cadence {
    return _cadence = setField(_cadence, 'cadence', DbType.real);
  }

  DbEventField _fractionalCadence;
  DbEventField get fractionalCadence {
    return _fractionalCadence =
        setField(_fractionalCadence, 'fractionalCadence', DbType.real);
  }

  DbEventField _power;
  DbEventField get power {
    return _power = setField(_power, 'power', DbType.integer);
  }

  DbEventField _strydCadence;
  DbEventField get strydCadence {
    return _strydCadence = setField(_strydCadence, 'strydCadence', DbType.real);
  }

  DbEventField _groundTime;
  DbEventField get groundTime {
    return _groundTime = setField(_groundTime, 'groundTime', DbType.real);
  }

  DbEventField _verticalOscillation;
  DbEventField get verticalOscillation {
    return _verticalOscillation =
        setField(_verticalOscillation, 'verticalOscillation', DbType.real);
  }

  DbEventField _formPower;
  DbEventField get formPower {
    return _formPower = setField(_formPower, 'formPower', DbType.integer);
  }

  DbEventField _legSpringStiffness;
  DbEventField get legSpringStiffness {
    return _legSpringStiffness =
        setField(_legSpringStiffness, 'legSpringStiffness', DbType.real);
  }

  DbEventField _data;
  DbEventField get data {
    return _data = setField(_data, 'data', DbType.real);
  }

  DbEventField _activitiesId;
  DbEventField get activitiesId {
    return _activitiesId =
        setField(_activitiesId, 'activitiesId', DbType.integer);
  }

  DbEventField _lapsId;
  DbEventField get lapsId {
    return _lapsId = setField(_lapsId, 'lapsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbEvent._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbEvent> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbEvent._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbEvent.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbEvent.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from events ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbEvent.updateBatch(qparams, values);
  }

  /// This method always returns DbEventObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbEvent>
  Future<DbEvent> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbEvent.toList(qparams);
    final data = await objFuture;
    DbEvent obj;
    if (data.isNotEmpty) {
      obj = DbEvent.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivity')) {
          obj.plDbActivity = await obj.getDbActivity();
        }
        if (preloadFields == null || preloadFields.contains('plDbLap')) {
          obj.plDbLap = await obj.getDbLap();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbeventCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbeventsFuture = await _obj._mnDbEvent.toList(qparams);
    final int count = dbeventsFuture[0]['CNT'] as int;
    if (dbeventCount != null) {
      dbeventCount(count);
    }
    return count;
  }

  /// This method always returns List<DbEvent>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbEvent>
  Future<List<DbEvent>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbEvent> dbeventsData =
        await DbEvent.fromMapList(data, preload: preload);
    return dbeventsData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbEvent.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbEvent>>
  Future<List<DropdownMenuItem<DbEvent>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbEvent>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dbeventsFuture = _obj._mnDbEvent.toList(qparams);

    final data = await dbeventsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbEvent>> items = []..add(DropdownMenuItem(
        value: DbEvent(),
        child: Text('Select DbEvent'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbEvent.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dbeventsFuture = _obj._mnDbEvent.toList(qparams);

    final data = await dbeventsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbEvent'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbEvent.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbEvent.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbEvent.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbEvent.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbEventFilterBuilder

// region DbEventFields
class DbEventFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fEvent;
  static TableField get event {
    return _fEvent =
        _fEvent ?? SqlSyntax.setField(_fEvent, 'event', DbType.text);
  }

  static TableField _fEventType;
  static TableField get eventType {
    return _fEventType = _fEventType ??
        SqlSyntax.setField(_fEventType, 'eventType', DbType.text);
  }

  static TableField _fEventGroup;
  static TableField get eventGroup {
    return _fEventGroup = _fEventGroup ??
        SqlSyntax.setField(_fEventGroup, 'eventGroup', DbType.integer);
  }

  static TableField _fTimerTrigger;
  static TableField get timerTrigger {
    return _fTimerTrigger = _fTimerTrigger ??
        SqlSyntax.setField(_fTimerTrigger, 'timerTrigger', DbType.text);
  }

  static TableField _fTimeStamp;
  static TableField get timeStamp {
    return _fTimeStamp = _fTimeStamp ??
        SqlSyntax.setField(_fTimeStamp, 'timeStamp', DbType.datetime);
  }

  static TableField _fPositionLat;
  static TableField get positionLat {
    return _fPositionLat = _fPositionLat ??
        SqlSyntax.setField(_fPositionLat, 'positionLat', DbType.real);
  }

  static TableField _fPositionLong;
  static TableField get positionLong {
    return _fPositionLong = _fPositionLong ??
        SqlSyntax.setField(_fPositionLong, 'positionLong', DbType.real);
  }

  static TableField _fDistance;
  static TableField get distance {
    return _fDistance =
        _fDistance ?? SqlSyntax.setField(_fDistance, 'distance', DbType.real);
  }

  static TableField _fAltitude;
  static TableField get altitude {
    return _fAltitude =
        _fAltitude ?? SqlSyntax.setField(_fAltitude, 'altitude', DbType.real);
  }

  static TableField _fSpeed;
  static TableField get speed {
    return _fSpeed =
        _fSpeed ?? SqlSyntax.setField(_fSpeed, 'speed', DbType.real);
  }

  static TableField _fHeartRate;
  static TableField get heartRate {
    return _fHeartRate = _fHeartRate ??
        SqlSyntax.setField(_fHeartRate, 'heartRate', DbType.integer);
  }

  static TableField _fCadence;
  static TableField get cadence {
    return _fCadence =
        _fCadence ?? SqlSyntax.setField(_fCadence, 'cadence', DbType.real);
  }

  static TableField _fFractionalCadence;
  static TableField get fractionalCadence {
    return _fFractionalCadence = _fFractionalCadence ??
        SqlSyntax.setField(
            _fFractionalCadence, 'fractionalCadence', DbType.real);
  }

  static TableField _fPower;
  static TableField get power {
    return _fPower =
        _fPower ?? SqlSyntax.setField(_fPower, 'power', DbType.integer);
  }

  static TableField _fStrydCadence;
  static TableField get strydCadence {
    return _fStrydCadence = _fStrydCadence ??
        SqlSyntax.setField(_fStrydCadence, 'strydCadence', DbType.real);
  }

  static TableField _fGroundTime;
  static TableField get groundTime {
    return _fGroundTime = _fGroundTime ??
        SqlSyntax.setField(_fGroundTime, 'groundTime', DbType.real);
  }

  static TableField _fVerticalOscillation;
  static TableField get verticalOscillation {
    return _fVerticalOscillation = _fVerticalOscillation ??
        SqlSyntax.setField(
            _fVerticalOscillation, 'verticalOscillation', DbType.real);
  }

  static TableField _fFormPower;
  static TableField get formPower {
    return _fFormPower = _fFormPower ??
        SqlSyntax.setField(_fFormPower, 'formPower', DbType.integer);
  }

  static TableField _fLegSpringStiffness;
  static TableField get legSpringStiffness {
    return _fLegSpringStiffness = _fLegSpringStiffness ??
        SqlSyntax.setField(
            _fLegSpringStiffness, 'legSpringStiffness', DbType.real);
  }

  static TableField _fData;
  static TableField get data {
    return _fData = _fData ?? SqlSyntax.setField(_fData, 'data', DbType.real);
  }

  static TableField _fActivitiesId;
  static TableField get activitiesId {
    return _fActivitiesId = _fActivitiesId ??
        SqlSyntax.setField(_fActivitiesId, 'activitiesId', DbType.integer);
  }

  static TableField _fLapsId;
  static TableField get lapsId {
    return _fLapsId =
        _fLapsId ?? SqlSyntax.setField(_fLapsId, 'lapsId', DbType.integer);
  }
}
// endregion DbEventFields

//region DbEventManager
class DbEventManager extends SqfEntityProvider {
  DbEventManager() : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'events';
  static String _colId = 'id';
}

//endregion DbEventManager
// region DbLap
class DbLap {
  DbLap(
      {this.id,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.endPositionLat,
      this.endPositionLong,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.event,
      this.eventType,
      this.eventGroup,
      this.sport,
      this.subSport,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.maxRunningCadence,
      this.intensity,
      this.lapTrigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.activitiesId}) {
    _setDefaultValues();
  }
  DbLap.withFields(
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.endPositionLat,
      this.endPositionLong,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.event,
      this.eventType,
      this.eventGroup,
      this.sport,
      this.subSport,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.maxRunningCadence,
      this.intensity,
      this.lapTrigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.activitiesId) {
    _setDefaultValues();
  }
  DbLap.withId(
      this.id,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.endPositionLat,
      this.endPositionLong,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.event,
      this.eventType,
      this.eventGroup,
      this.sport,
      this.subSport,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.maxRunningCadence,
      this.intensity,
      this.lapTrigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.activitiesId) {
    _setDefaultValues();
  }
  DbLap.fromMap(Map<String, dynamic> o) {
    id = o['id'] as int;
    timeStamp = o['timeStamp'] != null
        ? int.tryParse(o['timeStamp'].toString()) != null
            ? DateTime.fromMillisecondsSinceEpoch(o['timeStamp'] as int)
            : DateTime.tryParse(o['timeStamp'].toString())
        : null;
    startTime = o['startTime'] != null
        ? int.tryParse(o['startTime'].toString()) != null
            ? DateTime.fromMillisecondsSinceEpoch(o['startTime'] as int)
            : DateTime.tryParse(o['startTime'].toString())
        : null;
    startPositionLat = double.tryParse(o['startPositionLat'].toString());
    startPositionLong = double.tryParse(o['startPositionLong'].toString());
    endPositionLat = double.tryParse(o['endPositionLat'].toString());
    endPositionLong = double.tryParse(o['endPositionLong'].toString());
    avgHeartRate = o['avgHeartRate'] as int;
    maxHeartRate = o['maxHeartRate'] as int;
    avgRunningCadence = double.tryParse(o['avgRunningCadence'].toString());
    event = o['event'] as String;
    eventType = o['eventType'] as String;
    eventGroup = o['eventGroup'] as int;
    sport = o['sport'] as String;
    subSport = o['subSport'] as String;
    avgVerticalOscillation =
        double.tryParse(o['avgVerticalOscillation'].toString());
    totalElapsedTime = o['totalElapsedTime'] as int;
    totalTimerTime = o['totalTimerTime'] as int;
    totalDistance = o['totalDistance'] as int;
    totalStrides = o['totalStrides'] as int;
    totalCalories = o['totalCalories'] as int;
    avgSpeed = double.tryParse(o['avgSpeed'].toString());
    maxSpeed = double.tryParse(o['maxSpeed'].toString());
    totalAscent = o['totalAscent'] as int;
    totalDescent = o['totalDescent'] as int;
    avgStanceTimePercent =
        double.tryParse(o['avgStanceTimePercent'].toString());
    avgStanceTime = double.tryParse(o['avgStanceTime'].toString());
    maxRunningCadence = o['maxRunningCadence'] as int;
    intensity = o['intensity'] as int;
    lapTrigger = o['lapTrigger'] as String;
    avgTemperature = o['avgTemperature'] as int;
    maxTemperature = o['maxTemperature'] as int;
    avgFractionalCadence =
        double.tryParse(o['avgFractionalCadence'].toString());
    maxFractionalCadence =
        double.tryParse(o['maxFractionalCadence'].toString());
    totalFractionalCycles =
        double.tryParse(o['totalFractionalCycles'].toString());
    avgPower = double.tryParse(o['avgPower'].toString());
    minPower = o['minPower'] as int;
    maxPower = o['maxPower'] as int;
    sdevPower = double.tryParse(o['sdevPower'].toString());
    avgGroundTime = double.tryParse(o['avgGroundTime'].toString());
    sdevGroundTime = double.tryParse(o['sdevGroundTime'].toString());
    avgLegSpringStiffness =
        double.tryParse(o['avgLegSpringStiffness'].toString());
    sdevLegSpringStiffness =
        double.tryParse(o['sdevLegSpringStiffness'].toString());
    avgFormPower = double.tryParse(o['avgFormPower'].toString());
    sdevFormPower = double.tryParse(o['sdevFormPower'].toString());
    avgStrydCadence = double.tryParse(o['avgStrydCadence'].toString());
    sdevStrydCadence = double.tryParse(o['sdevStrydCadence'].toString());
    sdevVerticalOscillation =
        double.tryParse(o['sdevVerticalOscillation'].toString());
    activitiesId = o['activitiesId'] as int;
  }
  // FIELDS (DbLap)
  int id;
  DateTime timeStamp;
  DateTime startTime;
  double startPositionLat;
  double startPositionLong;
  double endPositionLat;
  double endPositionLong;
  int avgHeartRate;
  int maxHeartRate;
  double avgRunningCadence;
  String event;
  String eventType;
  int eventGroup;
  String sport;
  String subSport;
  double avgVerticalOscillation;
  int totalElapsedTime;
  int totalTimerTime;
  int totalDistance;
  int totalStrides;
  int totalCalories;
  double avgSpeed;
  double maxSpeed;
  int totalAscent;
  int totalDescent;
  double avgStanceTimePercent;
  double avgStanceTime;
  int maxRunningCadence;
  int intensity;
  String lapTrigger;
  int avgTemperature;
  int maxTemperature;
  double avgFractionalCadence;
  double maxFractionalCadence;
  double totalFractionalCycles;
  double avgPower;
  int minPower;
  int maxPower;
  double sdevPower;
  double avgGroundTime;
  double sdevGroundTime;
  double avgLegSpringStiffness;
  double sdevLegSpringStiffness;
  double avgFormPower;
  double sdevFormPower;
  double avgStrydCadence;
  double sdevStrydCadence;
  double sdevVerticalOscillation;
  int activitiesId;

  BoolResult saveResult;
  // end FIELDS (DbLap)

// RELATIONSHIPS (DbLap)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbActivity plDbActivity;

  /// get DbActivity By ActivitiesId

  Future<DbActivity> getDbActivity(
      [VoidCallback Function(DbActivity o) dbactivity]) async {
    final _obj = await DbActivity().getById(activitiesId);
    if (dbactivity != null) {
      dbactivity(_obj);
    }
    return _obj;
  }
  // END RELATIONSHIPS (DbLap)

// COLLECTIONS (DbLap)
  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbEvent> plDbEvents;

  /// get DbEvent(s) filtered by lapsId=id
  DbEventFilterBuilder getDbEvents(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbEvent()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .lapsId
        .equals(id)
        .and;
  }
// END COLLECTIONS (DbLap)

  static const bool _softDeleteActivated = false;
  DbLapManager __mnDbLap;

  DbLapManager get _mnDbLap {
    return __mnDbLap = __mnDbLap ?? DbLapManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toUtc().toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (endPositionLat != null) {
      map['endPositionLat'] = endPositionLat;
    }

    if (endPositionLong != null) {
      map['endPositionLong'] = endPositionLong;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (intensity != null) {
      map['intensity'] = intensity;
    }

    if (lapTrigger != null) {
      map['lapTrigger'] = lapTrigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (activitiesId != null) {
      map['activitiesId'] = activitiesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toUtc().toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (endPositionLat != null) {
      map['endPositionLat'] = endPositionLat;
    }

    if (endPositionLong != null) {
      map['endPositionLong'] = endPositionLong;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (intensity != null) {
      map['intensity'] = intensity;
    }

    if (lapTrigger != null) {
      map['lapTrigger'] = lapTrigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (activitiesId != null) {
      map['activitiesId'] = activitiesId;
    }

// COLLECTIONS (DbLap)
    if (!forQuery) {
      map['DbEvents'] = await getDbEvents().toMapList();
    }
// END COLLECTIONS (DbLap)

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
      startTime != null ? startTime.millisecondsSinceEpoch : null,
      startPositionLat,
      startPositionLong,
      endPositionLat,
      endPositionLong,
      avgHeartRate,
      maxHeartRate,
      avgRunningCadence,
      event,
      eventType,
      eventGroup,
      sport,
      subSport,
      avgVerticalOscillation,
      totalElapsedTime,
      totalTimerTime,
      totalDistance,
      totalStrides,
      totalCalories,
      avgSpeed,
      maxSpeed,
      totalAscent,
      totalDescent,
      avgStanceTimePercent,
      avgStanceTime,
      maxRunningCadence,
      intensity,
      lapTrigger,
      avgTemperature,
      maxTemperature,
      avgFractionalCadence,
      maxFractionalCadence,
      totalFractionalCycles,
      avgPower,
      minPower,
      maxPower,
      sdevPower,
      avgGroundTime,
      sdevGroundTime,
      avgLegSpringStiffness,
      sdevLegSpringStiffness,
      avgFormPower,
      sdevFormPower,
      avgStrydCadence,
      sdevStrydCadence,
      sdevVerticalOscillation,
      activitiesId
    ];
  }

  static Future<List<DbLap>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR DbLap.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbLap>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbLap>[];
    try {
      objList = list
          .map((dblap) => DbLap.fromMap(dblap as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR DbLap.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbLap>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbLap.fromMapList(data);
    } 
    */

  static Future<List<DbLap>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbLap> objList = <DbLap>[];
    for (final map in data) {
      final obj = DbLap.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbEvents')) {
          obj.plDbEvents = await obj.getDbEvents().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivity')) {
          obj.plDbActivity = await obj.getDbActivity();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbLap by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbLap if exist, otherwise returns null
  Future<DbLap> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbLap obj;
    final data = await _mnDbLap.getById(id);
    if (data.length != 0) {
      obj = DbLap.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbLap.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbLap. Returns a new Primary Key value of DbLap

  /// <returns>Returns a new Primary Key value of DbLap
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbLap> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(List<DbLap> dblaps) async {
    final results = _mnDbLap.saveAll(
        'INSERT OR REPLACE INTO laps (id,  timeStamp, startTime, startPositionLat, startPositionLong, endPositionLat, endPositionLong, avgHeartRate, maxHeartRate, avgRunningCadence, event, eventType, eventGroup, sport, subSport, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, avgStanceTimePercent, avgStanceTime, maxRunningCadence, intensity, lapTrigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dblaps);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbLap.rawInsert(
              'INSERT OR REPLACE INTO laps (id,  timeStamp, startTime, startPositionLat, startPositionLong, endPositionLat, endPositionLong, avgHeartRate, maxHeartRate, avgRunningCadence, event, eventType, eventGroup, sport, subSport, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, avgStanceTimePercent, avgStanceTime, maxRunningCadence, intensity, lapTrigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
                startTime != null ? startTime.millisecondsSinceEpoch : null,
                startPositionLat,
                startPositionLong,
                endPositionLat,
                endPositionLong,
                avgHeartRate,
                maxHeartRate,
                avgRunningCadence,
                event,
                eventType,
                eventGroup,
                sport,
                subSport,
                avgVerticalOscillation,
                totalElapsedTime,
                totalTimerTime,
                totalDistance,
                totalStrides,
                totalCalories,
                avgSpeed,
                maxSpeed,
                totalAscent,
                totalDescent,
                avgStanceTimePercent,
                avgStanceTime,
                maxRunningCadence,
                intensity,
                lapTrigger,
                avgTemperature,
                maxTemperature,
                avgFractionalCadence,
                maxFractionalCadence,
                totalFractionalCycles,
                avgPower,
                minPower,
                maxPower,
                sdevPower,
                avgGroundTime,
                sdevGroundTime,
                avgLegSpringStiffness,
                sdevLegSpringStiffness,
                avgFormPower,
                sdevFormPower,
                avgStrydCadence,
                sdevStrydCadence,
                sdevVerticalOscillation,
                activitiesId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true, successMessage: 'DbLap id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbLap id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbLap Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbLap>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(List<DbLap> dblaps) async {
    final results = await _mnDbLap.rawInsertAll(
        'INSERT OR REPLACE INTO laps (id,  timeStamp, startTime, startPositionLat, startPositionLong, endPositionLat, endPositionLong, avgHeartRate, maxHeartRate, avgRunningCadence, event, eventType, eventGroup, sport, subSport, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, avgStanceTimePercent, avgStanceTime, maxRunningCadence, intensity, lapTrigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dblaps);
    return results;
  }

  /// Deletes DbLap

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbLap invoked (id=$id)');
    var result = BoolResult();
    {
      result = await DbEvent().select().lapsId.equals(id).delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbLap
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbLap.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbLapFilterBuilder _Select;
  DbLapFilterBuilder select({List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLapFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbLapFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLapFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    activitiesId = activitiesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dblap

// region DbLapField
class DbLapField extends SearchCriteria {
  DbLapField(this.dblapFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbLapFilterBuilder dblapFB;

  DbLapField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbLapFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.EQuals,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.NotEQuals,
            dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.EQualsOrNull,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder isNull() {
    dblapFB._addedBlocks = setCriteria(
        0,
        dblapFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dblapFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dblapFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks);
      _waitingNot = '';
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
    }
    return dblapFB;
  }

  DbLapFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dblapFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dblapFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks);
      _waitingNot = '';
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
    }
    return dblapFB;
  }

  DbLapFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dblapFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dblapFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks);
      _waitingNot = '';
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
    }
    return dblapFB;
  }

  DbLapFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dblapFB._addedBlocks = setCriteria(
          pFirst,
          dblapFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dblapFB._addedBlocks = setCriteria(pFirst, dblapFB.parameters, param,
            SqlSyntax.LessThan, dblapFB._addedBlocks);
      } else {
        dblapFB._addedBlocks = setCriteria(pFirst, dblapFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblapFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dblapFB._addedBlocks = setCriteria(pLast, dblapFB.parameters, param,
            SqlSyntax.GreaterThan, dblapFB._addedBlocks);
      } else {
        dblapFB._addedBlocks = setCriteria(pLast, dblapFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblapFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.GreaterThan,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.LessThan,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.LessThan,
            dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.GreaterThan,
            dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder inValues(dynamic pValue) {
    dblapFB._addedBlocks = setCriteria(
        pValue,
        dblapFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }
}
// endregion DbLapField

// region DbLapFilterBuilder
class DbLapFilterBuilder extends SearchCriteria {
  DbLapFilterBuilder(DbLap obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbLap _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbLapFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbLapFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbLapFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbLapFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbLapFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbLapFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbLapFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbLapFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbLapFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbLapFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbLapField setField(DbLapField field, String colName, DbType dbtype) {
    return DbLapField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbLapField _id;
  DbLapField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbLapField _timeStamp;
  DbLapField get timeStamp {
    return _timeStamp = setField(_timeStamp, 'timeStamp', DbType.datetime);
  }

  DbLapField _startTime;
  DbLapField get startTime {
    return _startTime = setField(_startTime, 'startTime', DbType.datetime);
  }

  DbLapField _startPositionLat;
  DbLapField get startPositionLat {
    return _startPositionLat =
        setField(_startPositionLat, 'startPositionLat', DbType.real);
  }

  DbLapField _startPositionLong;
  DbLapField get startPositionLong {
    return _startPositionLong =
        setField(_startPositionLong, 'startPositionLong', DbType.real);
  }

  DbLapField _endPositionLat;
  DbLapField get endPositionLat {
    return _endPositionLat =
        setField(_endPositionLat, 'endPositionLat', DbType.real);
  }

  DbLapField _endPositionLong;
  DbLapField get endPositionLong {
    return _endPositionLong =
        setField(_endPositionLong, 'endPositionLong', DbType.real);
  }

  DbLapField _avgHeartRate;
  DbLapField get avgHeartRate {
    return _avgHeartRate =
        setField(_avgHeartRate, 'avgHeartRate', DbType.integer);
  }

  DbLapField _maxHeartRate;
  DbLapField get maxHeartRate {
    return _maxHeartRate =
        setField(_maxHeartRate, 'maxHeartRate', DbType.integer);
  }

  DbLapField _avgRunningCadence;
  DbLapField get avgRunningCadence {
    return _avgRunningCadence =
        setField(_avgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  DbLapField _event;
  DbLapField get event {
    return _event = setField(_event, 'event', DbType.text);
  }

  DbLapField _eventType;
  DbLapField get eventType {
    return _eventType = setField(_eventType, 'eventType', DbType.text);
  }

  DbLapField _eventGroup;
  DbLapField get eventGroup {
    return _eventGroup = setField(_eventGroup, 'eventGroup', DbType.integer);
  }

  DbLapField _sport;
  DbLapField get sport {
    return _sport = setField(_sport, 'sport', DbType.text);
  }

  DbLapField _subSport;
  DbLapField get subSport {
    return _subSport = setField(_subSport, 'subSport', DbType.text);
  }

  DbLapField _avgVerticalOscillation;
  DbLapField get avgVerticalOscillation {
    return _avgVerticalOscillation = setField(
        _avgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  DbLapField _totalElapsedTime;
  DbLapField get totalElapsedTime {
    return _totalElapsedTime =
        setField(_totalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  DbLapField _totalTimerTime;
  DbLapField get totalTimerTime {
    return _totalTimerTime =
        setField(_totalTimerTime, 'totalTimerTime', DbType.integer);
  }

  DbLapField _totalDistance;
  DbLapField get totalDistance {
    return _totalDistance =
        setField(_totalDistance, 'totalDistance', DbType.integer);
  }

  DbLapField _totalStrides;
  DbLapField get totalStrides {
    return _totalStrides =
        setField(_totalStrides, 'totalStrides', DbType.integer);
  }

  DbLapField _totalCalories;
  DbLapField get totalCalories {
    return _totalCalories =
        setField(_totalCalories, 'totalCalories', DbType.integer);
  }

  DbLapField _avgSpeed;
  DbLapField get avgSpeed {
    return _avgSpeed = setField(_avgSpeed, 'avgSpeed', DbType.real);
  }

  DbLapField _maxSpeed;
  DbLapField get maxSpeed {
    return _maxSpeed = setField(_maxSpeed, 'maxSpeed', DbType.real);
  }

  DbLapField _totalAscent;
  DbLapField get totalAscent {
    return _totalAscent = setField(_totalAscent, 'totalAscent', DbType.integer);
  }

  DbLapField _totalDescent;
  DbLapField get totalDescent {
    return _totalDescent =
        setField(_totalDescent, 'totalDescent', DbType.integer);
  }

  DbLapField _avgStanceTimePercent;
  DbLapField get avgStanceTimePercent {
    return _avgStanceTimePercent =
        setField(_avgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  DbLapField _avgStanceTime;
  DbLapField get avgStanceTime {
    return _avgStanceTime =
        setField(_avgStanceTime, 'avgStanceTime', DbType.real);
  }

  DbLapField _maxRunningCadence;
  DbLapField get maxRunningCadence {
    return _maxRunningCadence =
        setField(_maxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  DbLapField _intensity;
  DbLapField get intensity {
    return _intensity = setField(_intensity, 'intensity', DbType.integer);
  }

  DbLapField _lapTrigger;
  DbLapField get lapTrigger {
    return _lapTrigger = setField(_lapTrigger, 'lapTrigger', DbType.text);
  }

  DbLapField _avgTemperature;
  DbLapField get avgTemperature {
    return _avgTemperature =
        setField(_avgTemperature, 'avgTemperature', DbType.integer);
  }

  DbLapField _maxTemperature;
  DbLapField get maxTemperature {
    return _maxTemperature =
        setField(_maxTemperature, 'maxTemperature', DbType.integer);
  }

  DbLapField _avgFractionalCadence;
  DbLapField get avgFractionalCadence {
    return _avgFractionalCadence =
        setField(_avgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  DbLapField _maxFractionalCadence;
  DbLapField get maxFractionalCadence {
    return _maxFractionalCadence =
        setField(_maxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  DbLapField _totalFractionalCycles;
  DbLapField get totalFractionalCycles {
    return _totalFractionalCycles =
        setField(_totalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  DbLapField _avgPower;
  DbLapField get avgPower {
    return _avgPower = setField(_avgPower, 'avgPower', DbType.real);
  }

  DbLapField _minPower;
  DbLapField get minPower {
    return _minPower = setField(_minPower, 'minPower', DbType.integer);
  }

  DbLapField _maxPower;
  DbLapField get maxPower {
    return _maxPower = setField(_maxPower, 'maxPower', DbType.integer);
  }

  DbLapField _sdevPower;
  DbLapField get sdevPower {
    return _sdevPower = setField(_sdevPower, 'sdevPower', DbType.real);
  }

  DbLapField _avgGroundTime;
  DbLapField get avgGroundTime {
    return _avgGroundTime =
        setField(_avgGroundTime, 'avgGroundTime', DbType.real);
  }

  DbLapField _sdevGroundTime;
  DbLapField get sdevGroundTime {
    return _sdevGroundTime =
        setField(_sdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  DbLapField _avgLegSpringStiffness;
  DbLapField get avgLegSpringStiffness {
    return _avgLegSpringStiffness =
        setField(_avgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  DbLapField _sdevLegSpringStiffness;
  DbLapField get sdevLegSpringStiffness {
    return _sdevLegSpringStiffness = setField(
        _sdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  DbLapField _avgFormPower;
  DbLapField get avgFormPower {
    return _avgFormPower = setField(_avgFormPower, 'avgFormPower', DbType.real);
  }

  DbLapField _sdevFormPower;
  DbLapField get sdevFormPower {
    return _sdevFormPower =
        setField(_sdevFormPower, 'sdevFormPower', DbType.real);
  }

  DbLapField _avgStrydCadence;
  DbLapField get avgStrydCadence {
    return _avgStrydCadence =
        setField(_avgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  DbLapField _sdevStrydCadence;
  DbLapField get sdevStrydCadence {
    return _sdevStrydCadence =
        setField(_sdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  DbLapField _sdevVerticalOscillation;
  DbLapField get sdevVerticalOscillation {
    return _sdevVerticalOscillation = setField(
        _sdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  DbLapField _activitiesId;
  DbLapField get activitiesId {
    return _activitiesId =
        setField(_activitiesId, 'activitiesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbLap._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbLap> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbLap._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbLap.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbLap.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from laps ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbLap.updateBatch(qparams, values);
  }

  /// This method always returns DbLapObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbLap>
  Future<DbLap> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbLap.toList(qparams);
    final data = await objFuture;
    DbLap obj;
    if (data.isNotEmpty) {
      obj = DbLap.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbEvents')) {
          obj.plDbEvents = await obj.getDbEvents().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivity')) {
          obj.plDbActivity = await obj.getDbActivity();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dblapCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dblapsFuture = await _obj._mnDbLap.toList(qparams);
    final int count = dblapsFuture[0]['CNT'] as int;
    if (dblapCount != null) {
      dblapCount(count);
    }
    return count;
  }

  /// This method always returns List<DbLap>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbLap>
  Future<List<DbLap>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbLap> dblapsData =
        await DbLap.fromMapList(data, preload: preload);
    return dblapsData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbLap.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbLap>>
  Future<List<DropdownMenuItem<DbLap>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbLap>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dblapsFuture = _obj._mnDbLap.toList(qparams);

    final data = await dblapsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbLap>> items = []..add(DropdownMenuItem(
        value: DbLap(),
        child: Text('Select DbLap'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbLap.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dblapsFuture = _obj._mnDbLap.toList(qparams);

    final data = await dblapsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbLap'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbLap.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbLap.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbLap.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbLap.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbLapFilterBuilder

// region DbLapFields
class DbLapFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fTimeStamp;
  static TableField get timeStamp {
    return _fTimeStamp = _fTimeStamp ??
        SqlSyntax.setField(_fTimeStamp, 'timeStamp', DbType.datetime);
  }

  static TableField _fStartTime;
  static TableField get startTime {
    return _fStartTime = _fStartTime ??
        SqlSyntax.setField(_fStartTime, 'startTime', DbType.datetime);
  }

  static TableField _fStartPositionLat;
  static TableField get startPositionLat {
    return _fStartPositionLat = _fStartPositionLat ??
        SqlSyntax.setField(_fStartPositionLat, 'startPositionLat', DbType.real);
  }

  static TableField _fStartPositionLong;
  static TableField get startPositionLong {
    return _fStartPositionLong = _fStartPositionLong ??
        SqlSyntax.setField(
            _fStartPositionLong, 'startPositionLong', DbType.real);
  }

  static TableField _fEndPositionLat;
  static TableField get endPositionLat {
    return _fEndPositionLat = _fEndPositionLat ??
        SqlSyntax.setField(_fEndPositionLat, 'endPositionLat', DbType.real);
  }

  static TableField _fEndPositionLong;
  static TableField get endPositionLong {
    return _fEndPositionLong = _fEndPositionLong ??
        SqlSyntax.setField(_fEndPositionLong, 'endPositionLong', DbType.real);
  }

  static TableField _fAvgHeartRate;
  static TableField get avgHeartRate {
    return _fAvgHeartRate = _fAvgHeartRate ??
        SqlSyntax.setField(_fAvgHeartRate, 'avgHeartRate', DbType.integer);
  }

  static TableField _fMaxHeartRate;
  static TableField get maxHeartRate {
    return _fMaxHeartRate = _fMaxHeartRate ??
        SqlSyntax.setField(_fMaxHeartRate, 'maxHeartRate', DbType.integer);
  }

  static TableField _fAvgRunningCadence;
  static TableField get avgRunningCadence {
    return _fAvgRunningCadence = _fAvgRunningCadence ??
        SqlSyntax.setField(
            _fAvgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  static TableField _fEvent;
  static TableField get event {
    return _fEvent =
        _fEvent ?? SqlSyntax.setField(_fEvent, 'event', DbType.text);
  }

  static TableField _fEventType;
  static TableField get eventType {
    return _fEventType = _fEventType ??
        SqlSyntax.setField(_fEventType, 'eventType', DbType.text);
  }

  static TableField _fEventGroup;
  static TableField get eventGroup {
    return _fEventGroup = _fEventGroup ??
        SqlSyntax.setField(_fEventGroup, 'eventGroup', DbType.integer);
  }

  static TableField _fSport;
  static TableField get sport {
    return _fSport =
        _fSport ?? SqlSyntax.setField(_fSport, 'sport', DbType.text);
  }

  static TableField _fSubSport;
  static TableField get subSport {
    return _fSubSport =
        _fSubSport ?? SqlSyntax.setField(_fSubSport, 'subSport', DbType.text);
  }

  static TableField _fAvgVerticalOscillation;
  static TableField get avgVerticalOscillation {
    return _fAvgVerticalOscillation = _fAvgVerticalOscillation ??
        SqlSyntax.setField(
            _fAvgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  static TableField _fTotalElapsedTime;
  static TableField get totalElapsedTime {
    return _fTotalElapsedTime = _fTotalElapsedTime ??
        SqlSyntax.setField(
            _fTotalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  static TableField _fTotalTimerTime;
  static TableField get totalTimerTime {
    return _fTotalTimerTime = _fTotalTimerTime ??
        SqlSyntax.setField(_fTotalTimerTime, 'totalTimerTime', DbType.integer);
  }

  static TableField _fTotalDistance;
  static TableField get totalDistance {
    return _fTotalDistance = _fTotalDistance ??
        SqlSyntax.setField(_fTotalDistance, 'totalDistance', DbType.integer);
  }

  static TableField _fTotalStrides;
  static TableField get totalStrides {
    return _fTotalStrides = _fTotalStrides ??
        SqlSyntax.setField(_fTotalStrides, 'totalStrides', DbType.integer);
  }

  static TableField _fTotalCalories;
  static TableField get totalCalories {
    return _fTotalCalories = _fTotalCalories ??
        SqlSyntax.setField(_fTotalCalories, 'totalCalories', DbType.integer);
  }

  static TableField _fAvgSpeed;
  static TableField get avgSpeed {
    return _fAvgSpeed =
        _fAvgSpeed ?? SqlSyntax.setField(_fAvgSpeed, 'avgSpeed', DbType.real);
  }

  static TableField _fMaxSpeed;
  static TableField get maxSpeed {
    return _fMaxSpeed =
        _fMaxSpeed ?? SqlSyntax.setField(_fMaxSpeed, 'maxSpeed', DbType.real);
  }

  static TableField _fTotalAscent;
  static TableField get totalAscent {
    return _fTotalAscent = _fTotalAscent ??
        SqlSyntax.setField(_fTotalAscent, 'totalAscent', DbType.integer);
  }

  static TableField _fTotalDescent;
  static TableField get totalDescent {
    return _fTotalDescent = _fTotalDescent ??
        SqlSyntax.setField(_fTotalDescent, 'totalDescent', DbType.integer);
  }

  static TableField _fAvgStanceTimePercent;
  static TableField get avgStanceTimePercent {
    return _fAvgStanceTimePercent = _fAvgStanceTimePercent ??
        SqlSyntax.setField(
            _fAvgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  static TableField _fAvgStanceTime;
  static TableField get avgStanceTime {
    return _fAvgStanceTime = _fAvgStanceTime ??
        SqlSyntax.setField(_fAvgStanceTime, 'avgStanceTime', DbType.real);
  }

  static TableField _fMaxRunningCadence;
  static TableField get maxRunningCadence {
    return _fMaxRunningCadence = _fMaxRunningCadence ??
        SqlSyntax.setField(
            _fMaxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  static TableField _fIntensity;
  static TableField get intensity {
    return _fIntensity = _fIntensity ??
        SqlSyntax.setField(_fIntensity, 'intensity', DbType.integer);
  }

  static TableField _fLapTrigger;
  static TableField get lapTrigger {
    return _fLapTrigger = _fLapTrigger ??
        SqlSyntax.setField(_fLapTrigger, 'lapTrigger', DbType.text);
  }

  static TableField _fAvgTemperature;
  static TableField get avgTemperature {
    return _fAvgTemperature = _fAvgTemperature ??
        SqlSyntax.setField(_fAvgTemperature, 'avgTemperature', DbType.integer);
  }

  static TableField _fMaxTemperature;
  static TableField get maxTemperature {
    return _fMaxTemperature = _fMaxTemperature ??
        SqlSyntax.setField(_fMaxTemperature, 'maxTemperature', DbType.integer);
  }

  static TableField _fAvgFractionalCadence;
  static TableField get avgFractionalCadence {
    return _fAvgFractionalCadence = _fAvgFractionalCadence ??
        SqlSyntax.setField(
            _fAvgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  static TableField _fMaxFractionalCadence;
  static TableField get maxFractionalCadence {
    return _fMaxFractionalCadence = _fMaxFractionalCadence ??
        SqlSyntax.setField(
            _fMaxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  static TableField _fTotalFractionalCycles;
  static TableField get totalFractionalCycles {
    return _fTotalFractionalCycles = _fTotalFractionalCycles ??
        SqlSyntax.setField(
            _fTotalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  static TableField _fAvgPower;
  static TableField get avgPower {
    return _fAvgPower =
        _fAvgPower ?? SqlSyntax.setField(_fAvgPower, 'avgPower', DbType.real);
  }

  static TableField _fMinPower;
  static TableField get minPower {
    return _fMinPower = _fMinPower ??
        SqlSyntax.setField(_fMinPower, 'minPower', DbType.integer);
  }

  static TableField _fMaxPower;
  static TableField get maxPower {
    return _fMaxPower = _fMaxPower ??
        SqlSyntax.setField(_fMaxPower, 'maxPower', DbType.integer);
  }

  static TableField _fSdevPower;
  static TableField get sdevPower {
    return _fSdevPower = _fSdevPower ??
        SqlSyntax.setField(_fSdevPower, 'sdevPower', DbType.real);
  }

  static TableField _fAvgGroundTime;
  static TableField get avgGroundTime {
    return _fAvgGroundTime = _fAvgGroundTime ??
        SqlSyntax.setField(_fAvgGroundTime, 'avgGroundTime', DbType.real);
  }

  static TableField _fSdevGroundTime;
  static TableField get sdevGroundTime {
    return _fSdevGroundTime = _fSdevGroundTime ??
        SqlSyntax.setField(_fSdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  static TableField _fAvgLegSpringStiffness;
  static TableField get avgLegSpringStiffness {
    return _fAvgLegSpringStiffness = _fAvgLegSpringStiffness ??
        SqlSyntax.setField(
            _fAvgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  static TableField _fSdevLegSpringStiffness;
  static TableField get sdevLegSpringStiffness {
    return _fSdevLegSpringStiffness = _fSdevLegSpringStiffness ??
        SqlSyntax.setField(
            _fSdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  static TableField _fAvgFormPower;
  static TableField get avgFormPower {
    return _fAvgFormPower = _fAvgFormPower ??
        SqlSyntax.setField(_fAvgFormPower, 'avgFormPower', DbType.real);
  }

  static TableField _fSdevFormPower;
  static TableField get sdevFormPower {
    return _fSdevFormPower = _fSdevFormPower ??
        SqlSyntax.setField(_fSdevFormPower, 'sdevFormPower', DbType.real);
  }

  static TableField _fAvgStrydCadence;
  static TableField get avgStrydCadence {
    return _fAvgStrydCadence = _fAvgStrydCadence ??
        SqlSyntax.setField(_fAvgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  static TableField _fSdevStrydCadence;
  static TableField get sdevStrydCadence {
    return _fSdevStrydCadence = _fSdevStrydCadence ??
        SqlSyntax.setField(_fSdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  static TableField _fSdevVerticalOscillation;
  static TableField get sdevVerticalOscillation {
    return _fSdevVerticalOscillation = _fSdevVerticalOscillation ??
        SqlSyntax.setField(
            _fSdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  static TableField _fActivitiesId;
  static TableField get activitiesId {
    return _fActivitiesId = _fActivitiesId ??
        SqlSyntax.setField(_fActivitiesId, 'activitiesId', DbType.integer);
  }
}
// endregion DbLapFields

//region DbLapManager
class DbLapManager extends SqfEntityProvider {
  DbLapManager() : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'laps';
  static String _colId = 'id';
}

//endregion DbLapManager
class DbEncrateiaSequenceManager extends SqfEntityProvider {
  DbEncrateiaSequenceManager() : super(DbEncrateia());
}
// END OF ENTITIES
