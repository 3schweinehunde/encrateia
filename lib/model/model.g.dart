// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:DbAthlete.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// ignore_for_file:
// BEGIN TABLES
// DbAthlete TABLE
class TableDbAthlete extends SqfEntityTableBase {
  TableDbAthlete() {
    // declare properties of EntityTable
    tableName = 'athletes';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('state', DbType.text,
          defaultValue: 'new', isNotNull: false),
      SqfEntityFieldBase('firstName', DbType.text, isNotNull: false),
      SqfEntityFieldBase('lastName', DbType.text, isNotNull: false),
      SqfEntityFieldBase('stravaUsername', DbType.text, isNotNull: false),
      SqfEntityFieldBase('photoPath', DbType.text, isNotNull: false),
      SqfEntityFieldBase('stravaId', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('geoState', DbType.text, isNotNull: false),
      SqfEntityFieldBase('downloadInterval', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('recordAggregationCount', DbType.integer,
          isNotNull: false),
      SqfEntityFieldBase('stravaAccessToken', DbType.text, isNotNull: false),
      SqfEntityFieldBase('stravaScope', DbType.text, isNotNull: false),
      SqfEntityFieldBase('stravaRefreshToken', DbType.text, isNotNull: false),
      SqfEntityFieldBase('stravaExpire', DbType.integer, isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbAthlete();
  }
}

// DbActivity TABLE
class TableDbActivity extends SqfEntityTableBase {
  TableDbActivity() {
    // declare properties of EntityTable
    tableName = 'activities';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('state', DbType.text,
          defaultValue: 'new', isNotNull: false),
      SqfEntityFieldBase('path', DbType.text, isNotNull: false),
      SqfEntityFieldBase('stravaId', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('movingTime', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('type', DbType.text, isNotNull: false),
      SqfEntityFieldBase('distance', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('serialNumber', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('timeCreated', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('sportName', DbType.text, isNotNull: false),
      SqfEntityFieldBase('sport', DbType.text, isNotNull: false),
      SqfEntityFieldBase('subSport', DbType.text, isNotNull: false),
      SqfEntityFieldBase('timeStamp', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('startTime', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('startPositionLat', DbType.real, isNotNull: false),
      SqfEntityFieldBase('startPositionLong', DbType.real, isNotNull: false),
      SqfEntityFieldBase('event', DbType.text, isNotNull: false),
      SqfEntityFieldBase('eventType', DbType.text, isNotNull: false),
      SqfEntityFieldBase('eventGroup', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalDistance', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalStrides', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalCalories', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('avgSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgSpeedByMeasurements', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('avgSpeedBySpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgSpeedByDistance', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevPace', DbType.real, isNotNull: false),
      SqfEntityFieldBase('minSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('maxSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('totalAscent', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalDescent', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('maxRunningCadence', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('trigger', DbType.text, isNotNull: false),
      SqfEntityFieldBase('avgTemperature', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('maxTemperature', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('avgFractionalCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('maxFractionalCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('totalFractionalCycles', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('avgStanceTimePercent', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgStanceTime', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgHeartRate', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('maxHeartRate', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('avgRunningCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgVerticalOscillation', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('totalElapsedTime', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalTimerTime', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalTrainingEffect', DbType.integer,
          isNotNull: false),
      SqfEntityFieldBase('necLat', DbType.real, isNotNull: false),
      SqfEntityFieldBase('necLong', DbType.real, isNotNull: false),
      SqfEntityFieldBase('swcLat', DbType.real, isNotNull: false),
      SqfEntityFieldBase('swcLong', DbType.real, isNotNull: false),
      SqfEntityFieldBase('firstLapIndex', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('numLaps', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('numSessions', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('localTimestamp', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('avgPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('minPower', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('maxPower', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('minHeartRate', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('sdevHeartRate', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgGroundTime', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevGroundTime', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgLegSpringStiffness', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('sdevLegSpringStiffness', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('avgFormPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevFormPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgPowerRatio', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevPowerRatio', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgStrideRatio', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevStrideRatio', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgStrydCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevStrydCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevVerticalOscillation', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('cp', DbType.real, isNotNull: false),
      SqfEntityFieldBase('ftp', DbType.real, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbAthlete.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'athletesId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbActivity();
  }
}

// DbEvent TABLE
class TableDbEvent extends SqfEntityTableBase {
  TableDbEvent() {
    // declare properties of EntityTable
    tableName = 'events';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('event', DbType.text, isNotNull: false),
      SqfEntityFieldBase('eventType', DbType.text, isNotNull: false),
      SqfEntityFieldBase('eventGroup', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('timerTrigger', DbType.text, isNotNull: false),
      SqfEntityFieldBase('timeStamp', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('positionLat', DbType.real, isNotNull: false),
      SqfEntityFieldBase('positionLong', DbType.real, isNotNull: false),
      SqfEntityFieldBase('distance', DbType.real, isNotNull: false),
      SqfEntityFieldBase('altitude', DbType.real, isNotNull: false),
      SqfEntityFieldBase('speed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('heartRate', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('cadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('fractionalCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('power', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('strydCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('groundTime', DbType.real, isNotNull: false),
      SqfEntityFieldBase('verticalOscillation', DbType.real, isNotNull: false),
      SqfEntityFieldBase('formPower', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('legSpringStiffness', DbType.real, isNotNull: false),
      SqfEntityFieldBase('data', DbType.real, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbActivity.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'activitiesId',
          defaultValue: 0,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(TableDbLap.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'lapsId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbEvent();
  }
}

// DbLap TABLE
class TableDbLap extends SqfEntityTableBase {
  TableDbLap() {
    // declare properties of EntityTable
    tableName = 'laps';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('timeStamp', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('startTime', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('startPositionLat', DbType.real, isNotNull: false),
      SqfEntityFieldBase('startPositionLong', DbType.real, isNotNull: false),
      SqfEntityFieldBase('endPositionLat', DbType.real, isNotNull: false),
      SqfEntityFieldBase('endPositionLong', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgHeartRate', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('maxHeartRate', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('avgRunningCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('event', DbType.text, isNotNull: false),
      SqfEntityFieldBase('eventType', DbType.text, isNotNull: false),
      SqfEntityFieldBase('eventGroup', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('sport', DbType.text, isNotNull: false),
      SqfEntityFieldBase('subSport', DbType.text, isNotNull: false),
      SqfEntityFieldBase('avgVerticalOscillation', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('totalElapsedTime', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalTimerTime', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalDistance', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalStrides', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalCalories', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('avgSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgSpeedByMeasurements', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('avgSpeedBySpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgSpeedByDistance', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevPace', DbType.real, isNotNull: false),
      SqfEntityFieldBase('minSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('maxSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('totalAscent', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalDescent', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('avgStanceTimePercent', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgStanceTime', DbType.real, isNotNull: false),
      SqfEntityFieldBase('maxRunningCadence', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('intensity', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('lapTrigger', DbType.text, isNotNull: false),
      SqfEntityFieldBase('avgTemperature', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('maxTemperature', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('avgFractionalCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('maxFractionalCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('totalFractionalCycles', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('avgPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('minPower', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('maxPower', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('sdevPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('minHeartRate', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('sdevHeartRate', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgGroundTime', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevGroundTime', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgLegSpringStiffness', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('sdevLegSpringStiffness', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('avgFormPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevFormPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgStrydCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevStrydCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevVerticalOscillation', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('avgPowerRatio', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevPowerRatio', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgStrideRatio', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevStrideRatio', DbType.real, isNotNull: false),
      SqfEntityFieldBase('cp', DbType.real, isNotNull: false),
      SqfEntityFieldBase('ftp', DbType.real, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbActivity.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'activitiesId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbLap();
  }
}

// DbInterval TABLE
class TableDbInterval extends SqfEntityTableBase {
  TableDbInterval() {
    // declare properties of EntityTable
    tableName = 'intervals';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('timeStamp', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('duration', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('avgPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('minPower', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('maxPower', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('sdevPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgSpeedByMeasurements', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('avgSpeedBySpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgSpeedByDistance', DbType.real, isNotNull: false),
      SqfEntityFieldBase('minSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('maxSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevSpeed', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevPace', DbType.real, isNotNull: false),
      SqfEntityFieldBase('distance', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('avgHeartRate', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('minHeartRate', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('maxHeartRate', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('sdevHeartRate', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('minCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('maxCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgStrydCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('minStrydCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('maxStrydCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevStrydCadence', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgGroundTime', DbType.real, isNotNull: false),
      SqfEntityFieldBase('minGroundTime', DbType.real, isNotNull: false),
      SqfEntityFieldBase('maxGroundTime', DbType.real, isNotNull: false),
      SqfEntityFieldBase('sdevGroundTime', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgVerticalOscillation', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('minVerticalOscillation', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('maxVerticalOscillation', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('sdevVerticalOscillation', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('avgFormPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('maxFormPower', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('minFormPower', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('sdevFormPower', DbType.real, isNotNull: false),
      SqfEntityFieldBase('avgLegSpringStiffness', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('maxLegSpringStiffness', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('minLegSpringStiffness', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('sdevLegSpringStiffness', DbType.real,
          isNotNull: false),
      SqfEntityFieldBase('totalAscent', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('totalDescent', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('cp', DbType.real, isNotNull: false),
      SqfEntityFieldBase('ftp', DbType.real, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbEvent.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'firstRecordId',
          defaultValue: 0,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbEvent.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'lastRecordId',
          defaultValue: 0,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbAthlete.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'athletesId',
          defaultValue: 0,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbActivity.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'activitiesId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbInterval();
  }
}

// DbWeight TABLE
class TableDbWeight extends SqfEntityTableBase {
  TableDbWeight() {
    // declare properties of EntityTable
    tableName = 'weights';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('date', DbType.date,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('value', DbType.real, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbAthlete.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'athletesId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbWeight();
  }
}

// DbHeartRateZoneSchema TABLE
class TableDbHeartRateZoneSchema extends SqfEntityTableBase {
  TableDbHeartRateZoneSchema() {
    // declare properties of EntityTable
    tableName = 'heartRateZoneSchemata';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('date', DbType.date,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('base', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbAthlete.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'athletesId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbHeartRateZoneSchema();
  }
}

// DbHeartRateZone TABLE
class TableDbHeartRateZone extends SqfEntityTableBase {
  TableDbHeartRateZone() {
    // declare properties of EntityTable
    tableName = 'heartRateZone';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('lowerPercentage', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('upperPercentage', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('lowerLimit', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('upperLimit', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('color', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbHeartRateZoneSchema.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'heartRateZoneSchemataId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbHeartRateZone();
  }
}

// DbPowerZoneSchema TABLE
class TableDbPowerZoneSchema extends SqfEntityTableBase {
  TableDbPowerZoneSchema() {
    // declare properties of EntityTable
    tableName = 'powerZoneSchemata';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('date', DbType.date,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('base', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbAthlete.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'athletesId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbPowerZoneSchema();
  }
}

// DbPowerZone TABLE
class TableDbPowerZone extends SqfEntityTableBase {
  TableDbPowerZone() {
    // declare properties of EntityTable
    tableName = 'powerZone';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('lowerPercentage', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('upperPercentage', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('lowerLimit', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('upperLimit', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('color', DbType.integer, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbPowerZoneSchema.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'powerZoneSchemataId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbPowerZone();
  }
}

// DbTag TABLE
class TableDbTag extends SqfEntityTableBase {
  TableDbTag() {
    // declare properties of EntityTable
    tableName = 'tags';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('color', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('sortOrder', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('system', DbType.bool, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbTagGroup.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'tagGroupsId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbTag();
  }
}

// DbTagGroup TABLE
class TableDbTagGroup extends SqfEntityTableBase {
  TableDbTagGroup() {
    // declare properties of EntityTable
    tableName = 'tagGroups';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text, isNotNull: false),
      SqfEntityFieldBase('color', DbType.integer, isNotNull: false),
      SqfEntityFieldBase('system', DbType.bool, isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbAthlete.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'athletesId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbTagGroup();
  }
}

// DbLapTagging TABLE
class TableDbLapTagging extends SqfEntityTableBase {
  TableDbLapTagging() {
    // declare properties of EntityTable
    tableName = 'lapTaggings';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('system', DbType.bool, isNotNull: false),
      SqfEntityFieldRelationshipBase(TableDbTag.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'tagsId',
          defaultValue: 0,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(TableDbLap.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'lapsId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbLapTagging();
  }
}

// DbActivityTagging TABLE
class TableDbActivityTagging extends SqfEntityTableBase {
  TableDbActivityTagging() {
    // declare properties of EntityTable
    tableName = 'activityTaggings';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('system', DbType.bool, isNotNull: false),
      SqfEntityFieldRelationshipBase(TableDbTag.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'tagsId',
          defaultValue: 0,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbActivity.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'activitiesId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbActivityTagging();
  }
}

// DbIntervalTagging TABLE
class TableDbIntervalTagging extends SqfEntityTableBase {
  TableDbIntervalTagging() {
    // declare properties of EntityTable
    tableName = 'intervalTaggings';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('system', DbType.bool, isNotNull: false),
      SqfEntityFieldRelationshipBase(TableDbTag.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'tagsId',
          defaultValue: 0,
          isNotNull: false),
      SqfEntityFieldRelationshipBase(
          TableDbInterval.getInstance, DeleteRule.CASCADE,
          relationType: RelationType.ONE_TO_MANY,
          fieldName: 'intervalsId',
          defaultValue: 0,
          isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbIntervalTagging();
  }
}

// DbLog TABLE
class TableDbLog extends SqfEntityTableBase {
  TableDbLog() {
    // declare properties of EntityTable
    tableName = 'logs';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('dateTime', DbType.datetime,
          isNotNull: false, minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('message', DbType.text, isNotNull: false),
      SqfEntityFieldBase('method', DbType.text, isNotNull: false),
      SqfEntityFieldBase('comment', DbType.text, isNotNull: false),
      SqfEntityFieldBase('stackTrace', DbType.text, isNotNull: false),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbLog();
  }
}
// END TABLES

// BEGIN SEQUENCES
// END SEQUENCES

// BEGIN DATABASE MODEL
class DbEncrateia extends SqfEntityModelProvider {
  DbEncrateia() {
    databaseName = encrateia.databaseName;
    password = encrateia.password;
    dbVersion = encrateia.dbVersion;
    databaseTables = [
      TableDbAthlete.getInstance,
      TableDbActivity.getInstance,
      TableDbEvent.getInstance,
      TableDbLap.getInstance,
      TableDbInterval.getInstance,
      TableDbWeight.getInstance,
      TableDbHeartRateZoneSchema.getInstance,
      TableDbHeartRateZone.getInstance,
      TableDbPowerZoneSchema.getInstance,
      TableDbPowerZone.getInstance,
      TableDbTag.getInstance,
      TableDbTagGroup.getInstance,
      TableDbLapTagging.getInstance,
      TableDbActivityTagging.getInstance,
      TableDbIntervalTagging.getInstance,
      TableDbLog.getInstance,
    ];

    bundledDatabasePath = encrateia
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region DbAthlete
class DbAthlete {
  DbAthlete(
      {this.id,
      this.state,
      this.firstName,
      this.lastName,
      this.stravaUsername,
      this.photoPath,
      this.stravaId,
      this.geoState,
      this.downloadInterval,
      this.recordAggregationCount,
      this.stravaAccessToken,
      this.stravaScope,
      this.stravaRefreshToken,
      this.stravaExpire}) {
    _setDefaultValues();
  }
  DbAthlete.withFields(
      this.state,
      this.firstName,
      this.lastName,
      this.stravaUsername,
      this.photoPath,
      this.stravaId,
      this.geoState,
      this.downloadInterval,
      this.recordAggregationCount,
      this.stravaAccessToken,
      this.stravaScope,
      this.stravaRefreshToken,
      this.stravaExpire) {
    _setDefaultValues();
  }
  DbAthlete.withId(
      this.id,
      this.state,
      this.firstName,
      this.lastName,
      this.stravaUsername,
      this.photoPath,
      this.stravaId,
      this.geoState,
      this.downloadInterval,
      this.recordAggregationCount,
      this.stravaAccessToken,
      this.stravaScope,
      this.stravaRefreshToken,
      this.stravaExpire) {
    _setDefaultValues();
  }
  DbAthlete.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['state'] != null) {
      state = o['state'] as String;
    }
    if (o['firstName'] != null) {
      firstName = o['firstName'] as String;
    }
    if (o['lastName'] != null) {
      lastName = o['lastName'] as String;
    }
    if (o['stravaUsername'] != null) {
      stravaUsername = o['stravaUsername'] as String;
    }
    if (o['photoPath'] != null) {
      photoPath = o['photoPath'] as String;
    }
    if (o['stravaId'] != null) {
      stravaId = int.tryParse(o['stravaId'].toString());
    }
    if (o['geoState'] != null) {
      geoState = o['geoState'] as String;
    }
    if (o['downloadInterval'] != null) {
      downloadInterval = int.tryParse(o['downloadInterval'].toString());
    }
    if (o['recordAggregationCount'] != null) {
      recordAggregationCount =
          int.tryParse(o['recordAggregationCount'].toString());
    }
    if (o['stravaAccessToken'] != null) {
      stravaAccessToken = o['stravaAccessToken'] as String;
    }
    if (o['stravaScope'] != null) {
      stravaScope = o['stravaScope'] as String;
    }
    if (o['stravaRefreshToken'] != null) {
      stravaRefreshToken = o['stravaRefreshToken'] as String;
    }
    if (o['stravaExpire'] != null) {
      stravaExpire = int.tryParse(o['stravaExpire'].toString());
    }
  }
  // FIELDS (DbAthlete)
  int id;
  String state;
  String firstName;
  String lastName;
  String stravaUsername;
  String photoPath;
  int stravaId;
  String geoState;
  int downloadInterval;
  int recordAggregationCount;
  String stravaAccessToken;
  String stravaScope;
  String stravaRefreshToken;
  int stravaExpire;

  BoolResult saveResult;
  // end FIELDS (DbAthlete)

// COLLECTIONS & VIRTUALS (DbAthlete)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbActivities', 'plField2'..]) or so on..
  List<DbActivity> plDbActivities;

  /// get DbActivity(s) filtered by id=athletesId
  DbActivityFilterBuilder getDbActivities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbActivity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .athletesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbIntervals', 'plField2'..]) or so on..
  List<DbInterval> plDbIntervals;

  /// get DbInterval(s) filtered by id=athletesId
  DbIntervalFilterBuilder getDbIntervals(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbInterval()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .athletesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbWeights', 'plField2'..]) or so on..
  List<DbWeight> plDbWeights;

  /// get DbWeight(s) filtered by id=athletesId
  DbWeightFilterBuilder getDbWeights(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbWeight()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .athletesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbHeartRateZoneSchemas', 'plField2'..]) or so on..
  List<DbHeartRateZoneSchema> plDbHeartRateZoneSchemas;

  /// get DbHeartRateZoneSchema(s) filtered by id=athletesId
  DbHeartRateZoneSchemaFilterBuilder getDbHeartRateZoneSchemas(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbHeartRateZoneSchema()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .athletesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbPowerZoneSchemas', 'plField2'..]) or so on..
  List<DbPowerZoneSchema> plDbPowerZoneSchemas;

  /// get DbPowerZoneSchema(s) filtered by id=athletesId
  DbPowerZoneSchemaFilterBuilder getDbPowerZoneSchemas(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbPowerZoneSchema()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .athletesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbTagGroups', 'plField2'..]) or so on..
  List<DbTagGroup> plDbTagGroups;

  /// get DbTagGroup(s) filtered by id=athletesId
  DbTagGroupFilterBuilder getDbTagGroups(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbTagGroup()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .athletesId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (DbAthlete)

  static const bool _softDeleteActivated = false;
  DbAthleteManager __mnDbAthlete;

  DbAthleteManager get _mnDbAthlete {
    return __mnDbAthlete = __mnDbAthlete ?? DbAthleteManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (firstName != null) {
      map['firstName'] = firstName;
    }

    if (lastName != null) {
      map['lastName'] = lastName;
    }

    if (stravaUsername != null) {
      map['stravaUsername'] = stravaUsername;
    }

    if (photoPath != null) {
      map['photoPath'] = photoPath;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (geoState != null) {
      map['geoState'] = geoState;
    }

    if (downloadInterval != null) {
      map['downloadInterval'] = downloadInterval;
    }

    if (recordAggregationCount != null) {
      map['recordAggregationCount'] = recordAggregationCount;
    }

    if (stravaAccessToken != null) {
      map['stravaAccessToken'] = stravaAccessToken;
    }

    if (stravaScope != null) {
      map['stravaScope'] = stravaScope;
    }

    if (stravaRefreshToken != null) {
      map['stravaRefreshToken'] = stravaRefreshToken;
    }

    if (stravaExpire != null) {
      map['stravaExpire'] = stravaExpire;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (firstName != null) {
      map['firstName'] = firstName;
    }

    if (lastName != null) {
      map['lastName'] = lastName;
    }

    if (stravaUsername != null) {
      map['stravaUsername'] = stravaUsername;
    }

    if (photoPath != null) {
      map['photoPath'] = photoPath;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (geoState != null) {
      map['geoState'] = geoState;
    }

    if (downloadInterval != null) {
      map['downloadInterval'] = downloadInterval;
    }

    if (recordAggregationCount != null) {
      map['recordAggregationCount'] = recordAggregationCount;
    }

    if (stravaAccessToken != null) {
      map['stravaAccessToken'] = stravaAccessToken;
    }

    if (stravaScope != null) {
      map['stravaScope'] = stravaScope;
    }

    if (stravaRefreshToken != null) {
      map['stravaRefreshToken'] = stravaRefreshToken;
    }

    if (stravaExpire != null) {
      map['stravaExpire'] = stravaExpire;
    }

// COLLECTIONS (DbAthlete)
    if (!forQuery) {
      map['DbActivities'] = await getDbActivities().toMapList();
    }
    if (!forQuery) {
      map['DbIntervals'] = await getDbIntervals().toMapList();
    }
    if (!forQuery) {
      map['DbWeights'] = await getDbWeights().toMapList();
    }
    if (!forQuery) {
      map['DbHeartRateZoneSchemas'] =
          await getDbHeartRateZoneSchemas().toMapList();
    }
    if (!forQuery) {
      map['DbPowerZoneSchemas'] = await getDbPowerZoneSchemas().toMapList();
    }
    if (!forQuery) {
      map['DbTagGroups'] = await getDbTagGroups().toMapList();
    }
// END COLLECTIONS (DbAthlete)

    return map;
  }

  /// This method returns Json String [DbAthlete]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbAthlete]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      state,
      firstName,
      lastName,
      stravaUsername,
      photoPath,
      stravaId,
      geoState,
      downloadInterval,
      recordAggregationCount,
      stravaAccessToken,
      stravaScope,
      stravaRefreshToken,
      stravaExpire
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      state,
      firstName,
      lastName,
      stravaUsername,
      photoPath,
      stravaId,
      geoState,
      downloadInterval,
      recordAggregationCount,
      stravaAccessToken,
      stravaScope,
      stravaRefreshToken,
      stravaExpire
    ];
  }

  static Future<List<DbAthlete>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbAthlete.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbAthlete>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbAthlete>[];
    try {
      objList = list
          .map((dbathlete) =>
              DbAthlete.fromMap(dbathlete as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbAthlete.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbAthlete>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbAthlete> objList = <DbAthlete>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbAthlete.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbActivities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbActivities'))) {
          /*_loadedFields.add('athletes.plDbActivities'); */
          obj.plDbActivities = obj.plDbActivities ??
              await obj.getDbActivities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbIntervals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervals'))) {
          /*_loadedFields.add('athletes.plDbIntervals'); */
          obj.plDbIntervals = obj.plDbIntervals ??
              await obj.getDbIntervals().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbWeights') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbWeights'))) {
          /*_loadedFields.add('athletes.plDbWeights'); */
          obj.plDbWeights = obj.plDbWeights ??
              await obj.getDbWeights().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbHeartRateZoneSchemas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbHeartRateZoneSchemas'))) {
          /*_loadedFields.add('athletes.plDbHeartRateZoneSchemas'); */
          obj.plDbHeartRateZoneSchemas = obj.plDbHeartRateZoneSchemas ??
              await obj.getDbHeartRateZoneSchemas().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbPowerZoneSchemas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbPowerZoneSchemas'))) {
          /*_loadedFields.add('athletes.plDbPowerZoneSchemas'); */
          obj.plDbPowerZoneSchemas = obj.plDbPowerZoneSchemas ??
              await obj.getDbPowerZoneSchemas().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbTagGroups') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbTagGroups'))) {
          /*_loadedFields.add('athletes.plDbTagGroups'); */
          obj.plDbTagGroups = obj.plDbTagGroups ??
              await obj.getDbTagGroups().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbAthlete by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbAthlete if exist, otherwise returns null
  Future<DbAthlete> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbAthlete obj;
    final data = await _mnDbAthlete.getById([id]);
    if (data.length != 0) {
      obj = DbAthlete.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbActivities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbActivities'))) {
          /*_loadedFields.add('athletes.plDbActivities'); */
          obj.plDbActivities = obj.plDbActivities ??
              await obj.getDbActivities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbIntervals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervals'))) {
          /*_loadedFields.add('athletes.plDbIntervals'); */
          obj.plDbIntervals = obj.plDbIntervals ??
              await obj.getDbIntervals().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbWeights') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbWeights'))) {
          /*_loadedFields.add('athletes.plDbWeights'); */
          obj.plDbWeights = obj.plDbWeights ??
              await obj.getDbWeights().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbHeartRateZoneSchemas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbHeartRateZoneSchemas'))) {
          /*_loadedFields.add('athletes.plDbHeartRateZoneSchemas'); */
          obj.plDbHeartRateZoneSchemas = obj.plDbHeartRateZoneSchemas ??
              await obj.getDbHeartRateZoneSchemas().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbPowerZoneSchemas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbPowerZoneSchemas'))) {
          /*_loadedFields.add('athletes.plDbPowerZoneSchemas'); */
          obj.plDbPowerZoneSchemas = obj.plDbPowerZoneSchemas ??
              await obj.getDbPowerZoneSchemas().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbTagGroups') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbTagGroups'))) {
          /*_loadedFields.add('athletes.plDbTagGroups'); */
          obj.plDbTagGroups = obj.plDbTagGroups ??
              await obj.getDbTagGroups().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbAthlete) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbAthlete.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbAthlete.update(this);
    }

    return id;
  }

  /// saveAs DbAthlete. Returns a new Primary Key value of DbAthlete

  /// <returns>Returns a new Primary Key value of DbAthlete
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbAthlete> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DbAthlete> dbathletes) async {
    // final results = _mnDbAthlete.saveAll('INSERT OR REPLACE INTO athletes (id,state, firstName, lastName, stravaUsername, photoPath, stravaId, geoState, downloadInterval, recordAggregationCount, stravaAccessToken, stravaScope, stravaRefreshToken, stravaExpire)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',dbathletes);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbathletes) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbathletes.length; i++) {
      if (dbathletes[i].id == null) {
        dbathletes[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbAthlete.rawInsert(
              'INSERT OR REPLACE INTO athletes (id,state, firstName, lastName, stravaUsername, photoPath, stravaId, geoState, downloadInterval, recordAggregationCount, stravaAccessToken, stravaScope, stravaRefreshToken, stravaExpire)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                state,
                firstName,
                lastName,
                stravaUsername,
                photoPath,
                stravaId,
                geoState,
                downloadInterval,
                recordAggregationCount,
                stravaAccessToken,
                stravaScope,
                stravaRefreshToken,
                stravaExpire
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbAthlete id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbAthlete id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbAthlete Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbAthlete>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<DbAthlete> dbathletes) async {
    final results = await _mnDbAthlete.rawInsertAll(
        'INSERT OR REPLACE INTO athletes (id,state, firstName, lastName, stravaUsername, photoPath, stravaId, geoState, downloadInterval, recordAggregationCount, stravaAccessToken, stravaScope, stravaRefreshToken, stravaExpire)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbathletes);
    return results;
  }

  /// Deletes DbAthlete

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbAthlete invoked (id=$id)');
    var result = BoolResult();
    {
      result = await DbActivity()
          .select()
          .athletesId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbInterval()
          .select()
          .athletesId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbWeight()
          .select()
          .athletesId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbHeartRateZoneSchema()
          .select()
          .athletesId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbPowerZoneSchema()
          .select()
          .athletesId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbTagGroup()
          .select()
          .athletesId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbAthlete
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbAthlete.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbAthleteFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbAthleteFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbAthleteFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbAthleteFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    state = state ?? 'new';
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbathlete

// region DbAthleteField
class DbAthleteField extends SearchCriteria {
  DbAthleteField(this.dbathleteFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbAthleteFilterBuilder dbathleteFB;

  DbAthleteField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbAthleteFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param, SqlSyntax.EQuals,
            dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.NotEQuals, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder isNull() {
    dbathleteFB._addedBlocks = setCriteria(
        0,
        dbathleteFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbathleteFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbathleteFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks);
      _waitingNot = '';
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
    }
    return dbathleteFB;
  }

  DbAthleteFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbathleteFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbathleteFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks);
      _waitingNot = '';
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
    }
    return dbathleteFB;
  }

  DbAthleteFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbathleteFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbathleteFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks);
      _waitingNot = '';
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
    }
    return dbathleteFB;
  }

  DbAthleteFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbathleteFB._addedBlocks = setCriteria(
          pFirst,
          dbathleteFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbathleteFB._addedBlocks = setCriteria(pFirst, dbathleteFB.parameters,
            param, SqlSyntax.LessThan, dbathleteFB._addedBlocks);
      } else {
        dbathleteFB._addedBlocks = setCriteria(pFirst, dbathleteFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbathleteFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbathleteFB._addedBlocks = setCriteria(pLast, dbathleteFB.parameters,
            param, SqlSyntax.GreaterThan, dbathleteFB._addedBlocks);
      } else {
        dbathleteFB._addedBlocks = setCriteria(pLast, dbathleteFB.parameters,
            param, SqlSyntax.LessThanOrEquals, dbathleteFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThan, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param, SqlSyntax.LessThan,
            dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param, SqlSyntax.LessThan,
            dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThan, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder inValues(dynamic pValue) {
    dbathleteFB._addedBlocks = setCriteria(
        pValue,
        dbathleteFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }
}
// endregion DbAthleteField

// region DbAthleteFilterBuilder
class DbAthleteFilterBuilder extends SearchCriteria {
  DbAthleteFilterBuilder(DbAthlete obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbAthlete _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbAthleteFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbAthleteFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbAthleteFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbAthleteFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbAthleteFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbAthleteFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbAthleteFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbAthleteFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbAthleteFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbAthleteFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbAthleteFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbAthleteField setField(DbAthleteField field, String colName, DbType dbtype) {
    return DbAthleteField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbAthleteField _id;
  DbAthleteField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbAthleteField _state;
  DbAthleteField get state {
    return _state = setField(_state, 'state', DbType.text);
  }

  DbAthleteField _firstName;
  DbAthleteField get firstName {
    return _firstName = setField(_firstName, 'firstName', DbType.text);
  }

  DbAthleteField _lastName;
  DbAthleteField get lastName {
    return _lastName = setField(_lastName, 'lastName', DbType.text);
  }

  DbAthleteField _stravaUsername;
  DbAthleteField get stravaUsername {
    return _stravaUsername =
        setField(_stravaUsername, 'stravaUsername', DbType.text);
  }

  DbAthleteField _photoPath;
  DbAthleteField get photoPath {
    return _photoPath = setField(_photoPath, 'photoPath', DbType.text);
  }

  DbAthleteField _stravaId;
  DbAthleteField get stravaId {
    return _stravaId = setField(_stravaId, 'stravaId', DbType.integer);
  }

  DbAthleteField _geoState;
  DbAthleteField get geoState {
    return _geoState = setField(_geoState, 'geoState', DbType.text);
  }

  DbAthleteField _downloadInterval;
  DbAthleteField get downloadInterval {
    return _downloadInterval =
        setField(_downloadInterval, 'downloadInterval', DbType.integer);
  }

  DbAthleteField _recordAggregationCount;
  DbAthleteField get recordAggregationCount {
    return _recordAggregationCount = setField(
        _recordAggregationCount, 'recordAggregationCount', DbType.integer);
  }

  DbAthleteField _stravaAccessToken;
  DbAthleteField get stravaAccessToken {
    return _stravaAccessToken =
        setField(_stravaAccessToken, 'stravaAccessToken', DbType.text);
  }

  DbAthleteField _stravaScope;
  DbAthleteField get stravaScope {
    return _stravaScope = setField(_stravaScope, 'stravaScope', DbType.text);
  }

  DbAthleteField _stravaRefreshToken;
  DbAthleteField get stravaRefreshToken {
    return _stravaRefreshToken =
        setField(_stravaRefreshToken, 'stravaRefreshToken', DbType.text);
  }

  DbAthleteField _stravaExpire;
  DbAthleteField get stravaExpire {
    return _stravaExpire =
        setField(_stravaExpire, 'stravaExpire', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbAthlete._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbAthlete> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Delete sub records where in (DbActivity) according to DeleteRule.CASCADE
    final idListDbActivityBYathletesId = toListPrimaryKeySQL(false);
    final resDbActivityBYathletesId = await DbActivity()
        .select()
        .where('athletesId IN (${idListDbActivityBYathletesId['sql']})',
            parameterValue: idListDbActivityBYathletesId['args'])
        .delete(hardDelete);
    if (!resDbActivityBYathletesId.success) {
      return resDbActivityBYathletesId;
    }
// Delete sub records where in (DbInterval) according to DeleteRule.CASCADE
    final idListDbIntervalBYathletesId = toListPrimaryKeySQL(false);
    final resDbIntervalBYathletesId = await DbInterval()
        .select()
        .where('athletesId IN (${idListDbIntervalBYathletesId['sql']})',
            parameterValue: idListDbIntervalBYathletesId['args'])
        .delete(hardDelete);
    if (!resDbIntervalBYathletesId.success) {
      return resDbIntervalBYathletesId;
    }
// Delete sub records where in (DbWeight) according to DeleteRule.CASCADE
    final idListDbWeightBYathletesId = toListPrimaryKeySQL(false);
    final resDbWeightBYathletesId = await DbWeight()
        .select()
        .where('athletesId IN (${idListDbWeightBYathletesId['sql']})',
            parameterValue: idListDbWeightBYathletesId['args'])
        .delete(hardDelete);
    if (!resDbWeightBYathletesId.success) {
      return resDbWeightBYathletesId;
    }
// Delete sub records where in (DbHeartRateZoneSchema) according to DeleteRule.CASCADE
    final idListDbHeartRateZoneSchemaBYathletesId = toListPrimaryKeySQL(false);
    final resDbHeartRateZoneSchemaBYathletesId = await DbHeartRateZoneSchema()
        .select()
        .where(
            'athletesId IN (${idListDbHeartRateZoneSchemaBYathletesId['sql']})',
            parameterValue: idListDbHeartRateZoneSchemaBYathletesId['args'])
        .delete(hardDelete);
    if (!resDbHeartRateZoneSchemaBYathletesId.success) {
      return resDbHeartRateZoneSchemaBYathletesId;
    }
// Delete sub records where in (DbPowerZoneSchema) according to DeleteRule.CASCADE
    final idListDbPowerZoneSchemaBYathletesId = toListPrimaryKeySQL(false);
    final resDbPowerZoneSchemaBYathletesId = await DbPowerZoneSchema()
        .select()
        .where('athletesId IN (${idListDbPowerZoneSchemaBYathletesId['sql']})',
            parameterValue: idListDbPowerZoneSchemaBYathletesId['args'])
        .delete(hardDelete);
    if (!resDbPowerZoneSchemaBYathletesId.success) {
      return resDbPowerZoneSchemaBYathletesId;
    }
// Delete sub records where in (DbTagGroup) according to DeleteRule.CASCADE
    final idListDbTagGroupBYathletesId = toListPrimaryKeySQL(false);
    final resDbTagGroupBYathletesId = await DbTagGroup()
        .select()
        .where('athletesId IN (${idListDbTagGroupBYathletesId['sql']})',
            parameterValue: idListDbTagGroupBYathletesId['args'])
        .delete(hardDelete);
    if (!resDbTagGroupBYathletesId.success) {
      return resDbTagGroupBYathletesId;
    }

    if (DbAthlete._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbAthlete.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbAthlete.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from athletes ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbAthlete.updateBatch(qparams, values);
  }

  /// This method always returns DbAthlete Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbAthlete>
  Future<DbAthlete> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbAthlete.toList(qparams);
    final data = await objFuture;
    DbAthlete obj;
    if (data.isNotEmpty) {
      obj = DbAthlete.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbActivities') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbActivities'))) {
          /*_loadedFields.add('athletes.plDbActivities'); */
          obj.plDbActivities = obj.plDbActivities ??
              await obj.getDbActivities().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbIntervals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervals'))) {
          /*_loadedFields.add('athletes.plDbIntervals'); */
          obj.plDbIntervals = obj.plDbIntervals ??
              await obj.getDbIntervals().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbWeights') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbWeights'))) {
          /*_loadedFields.add('athletes.plDbWeights'); */
          obj.plDbWeights = obj.plDbWeights ??
              await obj.getDbWeights().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbHeartRateZoneSchemas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbHeartRateZoneSchemas'))) {
          /*_loadedFields.add('athletes.plDbHeartRateZoneSchemas'); */
          obj.plDbHeartRateZoneSchemas = obj.plDbHeartRateZoneSchemas ??
              await obj.getDbHeartRateZoneSchemas().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbPowerZoneSchemas') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbPowerZoneSchemas'))) {
          /*_loadedFields.add('athletes.plDbPowerZoneSchemas'); */
          obj.plDbPowerZoneSchemas = obj.plDbPowerZoneSchemas ??
              await obj.getDbPowerZoneSchemas().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbTagGroups') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbTagGroups'))) {
          /*_loadedFields.add('athletes.plDbTagGroups'); */
          obj.plDbTagGroups = obj.plDbTagGroups ??
              await obj.getDbTagGroups().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbAthlete]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbathleteCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbathletesFuture = await _obj._mnDbAthlete.toList(qparams);
    final int count = dbathletesFuture[0]['CNT'] as int;
    if (dbathleteCount != null) {
      dbathleteCount(count);
    }
    return count;
  }

  /// This method returns List<DbAthlete> [DbAthlete]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbAthlete>
  Future<List<DbAthlete>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbAthlete> dbathletesData = await DbAthlete.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return dbathletesData;
  }

  /// This method returns Json String [DbAthlete]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbAthlete]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbAthlete]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbAthlete.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbAthlete]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM athletes WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbAthlete.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbAthlete]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbAthlete.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbAthlete.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbAthlete.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbAthleteFilterBuilder

// region DbAthleteFields
class DbAthleteFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fState;
  static TableField get state {
    return _fState =
        _fState ?? SqlSyntax.setField(_fState, 'state', DbType.text);
  }

  static TableField _fFirstName;
  static TableField get firstName {
    return _fFirstName = _fFirstName ??
        SqlSyntax.setField(_fFirstName, 'firstName', DbType.text);
  }

  static TableField _fLastName;
  static TableField get lastName {
    return _fLastName =
        _fLastName ?? SqlSyntax.setField(_fLastName, 'lastName', DbType.text);
  }

  static TableField _fStravaUsername;
  static TableField get stravaUsername {
    return _fStravaUsername = _fStravaUsername ??
        SqlSyntax.setField(_fStravaUsername, 'stravaUsername', DbType.text);
  }

  static TableField _fPhotoPath;
  static TableField get photoPath {
    return _fPhotoPath = _fPhotoPath ??
        SqlSyntax.setField(_fPhotoPath, 'photoPath', DbType.text);
  }

  static TableField _fStravaId;
  static TableField get stravaId {
    return _fStravaId = _fStravaId ??
        SqlSyntax.setField(_fStravaId, 'stravaId', DbType.integer);
  }

  static TableField _fGeoState;
  static TableField get geoState {
    return _fGeoState =
        _fGeoState ?? SqlSyntax.setField(_fGeoState, 'geoState', DbType.text);
  }

  static TableField _fDownloadInterval;
  static TableField get downloadInterval {
    return _fDownloadInterval = _fDownloadInterval ??
        SqlSyntax.setField(
            _fDownloadInterval, 'downloadInterval', DbType.integer);
  }

  static TableField _fRecordAggregationCount;
  static TableField get recordAggregationCount {
    return _fRecordAggregationCount = _fRecordAggregationCount ??
        SqlSyntax.setField(
            _fRecordAggregationCount, 'recordAggregationCount', DbType.integer);
  }

  static TableField _fStravaAccessToken;
  static TableField get stravaAccessToken {
    return _fStravaAccessToken = _fStravaAccessToken ??
        SqlSyntax.setField(
            _fStravaAccessToken, 'stravaAccessToken', DbType.text);
  }

  static TableField _fStravaScope;
  static TableField get stravaScope {
    return _fStravaScope = _fStravaScope ??
        SqlSyntax.setField(_fStravaScope, 'stravaScope', DbType.text);
  }

  static TableField _fStravaRefreshToken;
  static TableField get stravaRefreshToken {
    return _fStravaRefreshToken = _fStravaRefreshToken ??
        SqlSyntax.setField(
            _fStravaRefreshToken, 'stravaRefreshToken', DbType.text);
  }

  static TableField _fStravaExpire;
  static TableField get stravaExpire {
    return _fStravaExpire = _fStravaExpire ??
        SqlSyntax.setField(_fStravaExpire, 'stravaExpire', DbType.integer);
  }
}
// endregion DbAthleteFields

//region DbAthleteManager
class DbAthleteManager extends SqfEntityProvider {
  DbAthleteManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'athletes';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbAthleteManager
// region DbActivity
class DbActivity {
  DbActivity(
      {this.id,
      this.state,
      this.path,
      this.stravaId,
      this.name,
      this.movingTime,
      this.type,
      this.distance,
      this.serialNumber,
      this.timeCreated,
      this.sportName,
      this.sport,
      this.subSport,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.event,
      this.eventType,
      this.eventGroup,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.avgSpeedByMeasurements,
      this.avgSpeedBySpeed,
      this.avgSpeedByDistance,
      this.sdevSpeed,
      this.sdevPace,
      this.minSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.maxRunningCadence,
      this.trigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalTrainingEffect,
      this.necLat,
      this.necLong,
      this.swcLat,
      this.swcLong,
      this.firstLapIndex,
      this.numLaps,
      this.numSessions,
      this.localTimestamp,
      this.avgPower,
      this.sdevPower,
      this.minPower,
      this.maxPower,
      this.minHeartRate,
      this.sdevHeartRate,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrideRatio,
      this.sdevStrideRatio,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.cp,
      this.ftp,
      this.athletesId}) {
    _setDefaultValues();
  }
  DbActivity.withFields(
      this.state,
      this.path,
      this.stravaId,
      this.name,
      this.movingTime,
      this.type,
      this.distance,
      this.serialNumber,
      this.timeCreated,
      this.sportName,
      this.sport,
      this.subSport,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.event,
      this.eventType,
      this.eventGroup,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.avgSpeedByMeasurements,
      this.avgSpeedBySpeed,
      this.avgSpeedByDistance,
      this.sdevSpeed,
      this.sdevPace,
      this.minSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.maxRunningCadence,
      this.trigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalTrainingEffect,
      this.necLat,
      this.necLong,
      this.swcLat,
      this.swcLong,
      this.firstLapIndex,
      this.numLaps,
      this.numSessions,
      this.localTimestamp,
      this.avgPower,
      this.sdevPower,
      this.minPower,
      this.maxPower,
      this.minHeartRate,
      this.sdevHeartRate,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrideRatio,
      this.sdevStrideRatio,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.cp,
      this.ftp,
      this.athletesId) {
    _setDefaultValues();
  }
  DbActivity.withId(
      this.id,
      this.state,
      this.path,
      this.stravaId,
      this.name,
      this.movingTime,
      this.type,
      this.distance,
      this.serialNumber,
      this.timeCreated,
      this.sportName,
      this.sport,
      this.subSport,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.event,
      this.eventType,
      this.eventGroup,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.avgSpeedByMeasurements,
      this.avgSpeedBySpeed,
      this.avgSpeedByDistance,
      this.sdevSpeed,
      this.sdevPace,
      this.minSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.maxRunningCadence,
      this.trigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalTrainingEffect,
      this.necLat,
      this.necLong,
      this.swcLat,
      this.swcLong,
      this.firstLapIndex,
      this.numLaps,
      this.numSessions,
      this.localTimestamp,
      this.avgPower,
      this.sdevPower,
      this.minPower,
      this.maxPower,
      this.minHeartRate,
      this.sdevHeartRate,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrideRatio,
      this.sdevStrideRatio,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.cp,
      this.ftp,
      this.athletesId) {
    _setDefaultValues();
  }
  DbActivity.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['state'] != null) {
      state = o['state'] as String;
    }
    if (o['path'] != null) {
      path = o['path'] as String;
    }
    if (o['stravaId'] != null) {
      stravaId = int.tryParse(o['stravaId'].toString());
    }
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['movingTime'] != null) {
      movingTime = int.tryParse(o['movingTime'].toString());
    }
    if (o['type'] != null) {
      type = o['type'] as String;
    }
    if (o['distance'] != null) {
      distance = int.tryParse(o['distance'].toString());
    }
    if (o['serialNumber'] != null) {
      serialNumber = int.tryParse(o['serialNumber'].toString());
    }
    if (o['timeCreated'] != null) {
      timeCreated = int.tryParse(o['timeCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['timeCreated'].toString()))
          : DateTime.tryParse(o['timeCreated'].toString());
    }
    if (o['sportName'] != null) {
      sportName = o['sportName'] as String;
    }
    if (o['sport'] != null) {
      sport = o['sport'] as String;
    }
    if (o['subSport'] != null) {
      subSport = o['subSport'] as String;
    }
    if (o['timeStamp'] != null) {
      timeStamp = int.tryParse(o['timeStamp'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['timeStamp'].toString()))
          : DateTime.tryParse(o['timeStamp'].toString());
    }
    if (o['startTime'] != null) {
      startTime = int.tryParse(o['startTime'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['startTime'].toString()))
          : DateTime.tryParse(o['startTime'].toString());
    }
    if (o['startPositionLat'] != null) {
      startPositionLat = double.tryParse(o['startPositionLat'].toString());
    }
    if (o['startPositionLong'] != null) {
      startPositionLong = double.tryParse(o['startPositionLong'].toString());
    }
    if (o['event'] != null) {
      event = o['event'] as String;
    }
    if (o['eventType'] != null) {
      eventType = o['eventType'] as String;
    }
    if (o['eventGroup'] != null) {
      eventGroup = int.tryParse(o['eventGroup'].toString());
    }
    if (o['totalDistance'] != null) {
      totalDistance = int.tryParse(o['totalDistance'].toString());
    }
    if (o['totalStrides'] != null) {
      totalStrides = int.tryParse(o['totalStrides'].toString());
    }
    if (o['totalCalories'] != null) {
      totalCalories = int.tryParse(o['totalCalories'].toString());
    }
    if (o['avgSpeed'] != null) {
      avgSpeed = double.tryParse(o['avgSpeed'].toString());
    }
    if (o['avgSpeedByMeasurements'] != null) {
      avgSpeedByMeasurements =
          double.tryParse(o['avgSpeedByMeasurements'].toString());
    }
    if (o['avgSpeedBySpeed'] != null) {
      avgSpeedBySpeed = double.tryParse(o['avgSpeedBySpeed'].toString());
    }
    if (o['avgSpeedByDistance'] != null) {
      avgSpeedByDistance = double.tryParse(o['avgSpeedByDistance'].toString());
    }
    if (o['sdevSpeed'] != null) {
      sdevSpeed = double.tryParse(o['sdevSpeed'].toString());
    }
    if (o['sdevPace'] != null) {
      sdevPace = double.tryParse(o['sdevPace'].toString());
    }
    if (o['minSpeed'] != null) {
      minSpeed = double.tryParse(o['minSpeed'].toString());
    }
    if (o['maxSpeed'] != null) {
      maxSpeed = double.tryParse(o['maxSpeed'].toString());
    }
    if (o['totalAscent'] != null) {
      totalAscent = int.tryParse(o['totalAscent'].toString());
    }
    if (o['totalDescent'] != null) {
      totalDescent = int.tryParse(o['totalDescent'].toString());
    }
    if (o['maxRunningCadence'] != null) {
      maxRunningCadence = int.tryParse(o['maxRunningCadence'].toString());
    }
    if (o['trigger'] != null) {
      trigger = o['trigger'] as String;
    }
    if (o['avgTemperature'] != null) {
      avgTemperature = int.tryParse(o['avgTemperature'].toString());
    }
    if (o['maxTemperature'] != null) {
      maxTemperature = int.tryParse(o['maxTemperature'].toString());
    }
    if (o['avgFractionalCadence'] != null) {
      avgFractionalCadence =
          double.tryParse(o['avgFractionalCadence'].toString());
    }
    if (o['maxFractionalCadence'] != null) {
      maxFractionalCadence =
          double.tryParse(o['maxFractionalCadence'].toString());
    }
    if (o['totalFractionalCycles'] != null) {
      totalFractionalCycles =
          double.tryParse(o['totalFractionalCycles'].toString());
    }
    if (o['avgStanceTimePercent'] != null) {
      avgStanceTimePercent =
          double.tryParse(o['avgStanceTimePercent'].toString());
    }
    if (o['avgStanceTime'] != null) {
      avgStanceTime = double.tryParse(o['avgStanceTime'].toString());
    }
    if (o['avgHeartRate'] != null) {
      avgHeartRate = int.tryParse(o['avgHeartRate'].toString());
    }
    if (o['maxHeartRate'] != null) {
      maxHeartRate = int.tryParse(o['maxHeartRate'].toString());
    }
    if (o['avgRunningCadence'] != null) {
      avgRunningCadence = double.tryParse(o['avgRunningCadence'].toString());
    }
    if (o['avgVerticalOscillation'] != null) {
      avgVerticalOscillation =
          double.tryParse(o['avgVerticalOscillation'].toString());
    }
    if (o['totalElapsedTime'] != null) {
      totalElapsedTime = int.tryParse(o['totalElapsedTime'].toString());
    }
    if (o['totalTimerTime'] != null) {
      totalTimerTime = int.tryParse(o['totalTimerTime'].toString());
    }
    if (o['totalTrainingEffect'] != null) {
      totalTrainingEffect = int.tryParse(o['totalTrainingEffect'].toString());
    }
    if (o['necLat'] != null) {
      necLat = double.tryParse(o['necLat'].toString());
    }
    if (o['necLong'] != null) {
      necLong = double.tryParse(o['necLong'].toString());
    }
    if (o['swcLat'] != null) {
      swcLat = double.tryParse(o['swcLat'].toString());
    }
    if (o['swcLong'] != null) {
      swcLong = double.tryParse(o['swcLong'].toString());
    }
    if (o['firstLapIndex'] != null) {
      firstLapIndex = int.tryParse(o['firstLapIndex'].toString());
    }
    if (o['numLaps'] != null) {
      numLaps = int.tryParse(o['numLaps'].toString());
    }
    if (o['numSessions'] != null) {
      numSessions = int.tryParse(o['numSessions'].toString());
    }
    if (o['localTimestamp'] != null) {
      localTimestamp = int.tryParse(o['localTimestamp'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['localTimestamp'].toString()))
          : DateTime.tryParse(o['localTimestamp'].toString());
    }
    if (o['avgPower'] != null) {
      avgPower = double.tryParse(o['avgPower'].toString());
    }
    if (o['sdevPower'] != null) {
      sdevPower = double.tryParse(o['sdevPower'].toString());
    }
    if (o['minPower'] != null) {
      minPower = int.tryParse(o['minPower'].toString());
    }
    if (o['maxPower'] != null) {
      maxPower = int.tryParse(o['maxPower'].toString());
    }
    if (o['minHeartRate'] != null) {
      minHeartRate = int.tryParse(o['minHeartRate'].toString());
    }
    if (o['sdevHeartRate'] != null) {
      sdevHeartRate = double.tryParse(o['sdevHeartRate'].toString());
    }
    if (o['avgGroundTime'] != null) {
      avgGroundTime = double.tryParse(o['avgGroundTime'].toString());
    }
    if (o['sdevGroundTime'] != null) {
      sdevGroundTime = double.tryParse(o['sdevGroundTime'].toString());
    }
    if (o['avgLegSpringStiffness'] != null) {
      avgLegSpringStiffness =
          double.tryParse(o['avgLegSpringStiffness'].toString());
    }
    if (o['sdevLegSpringStiffness'] != null) {
      sdevLegSpringStiffness =
          double.tryParse(o['sdevLegSpringStiffness'].toString());
    }
    if (o['avgFormPower'] != null) {
      avgFormPower = double.tryParse(o['avgFormPower'].toString());
    }
    if (o['sdevFormPower'] != null) {
      sdevFormPower = double.tryParse(o['sdevFormPower'].toString());
    }
    if (o['avgPowerRatio'] != null) {
      avgPowerRatio = double.tryParse(o['avgPowerRatio'].toString());
    }
    if (o['sdevPowerRatio'] != null) {
      sdevPowerRatio = double.tryParse(o['sdevPowerRatio'].toString());
    }
    if (o['avgStrideRatio'] != null) {
      avgStrideRatio = double.tryParse(o['avgStrideRatio'].toString());
    }
    if (o['sdevStrideRatio'] != null) {
      sdevStrideRatio = double.tryParse(o['sdevStrideRatio'].toString());
    }
    if (o['avgStrydCadence'] != null) {
      avgStrydCadence = double.tryParse(o['avgStrydCadence'].toString());
    }
    if (o['sdevStrydCadence'] != null) {
      sdevStrydCadence = double.tryParse(o['sdevStrydCadence'].toString());
    }
    if (o['sdevVerticalOscillation'] != null) {
      sdevVerticalOscillation =
          double.tryParse(o['sdevVerticalOscillation'].toString());
    }
    if (o['cp'] != null) {
      cp = double.tryParse(o['cp'].toString());
    }
    if (o['ftp'] != null) {
      ftp = double.tryParse(o['ftp'].toString());
    }
    athletesId = int.tryParse(o['athletesId'].toString());

    // RELATIONSHIPS FromMAP
    plDbAthlete = o['dbAthlete'] != null
        ? DbAthlete.fromMap(o['dbAthlete'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbActivity)
  int id;
  String state;
  String path;
  int stravaId;
  String name;
  int movingTime;
  String type;
  int distance;
  int serialNumber;
  DateTime timeCreated;
  String sportName;
  String sport;
  String subSport;
  DateTime timeStamp;
  DateTime startTime;
  double startPositionLat;
  double startPositionLong;
  String event;
  String eventType;
  int eventGroup;
  int totalDistance;
  int totalStrides;
  int totalCalories;
  double avgSpeed;
  double avgSpeedByMeasurements;
  double avgSpeedBySpeed;
  double avgSpeedByDistance;
  double sdevSpeed;
  double sdevPace;
  double minSpeed;
  double maxSpeed;
  int totalAscent;
  int totalDescent;
  int maxRunningCadence;
  String trigger;
  int avgTemperature;
  int maxTemperature;
  double avgFractionalCadence;
  double maxFractionalCadence;
  double totalFractionalCycles;
  double avgStanceTimePercent;
  double avgStanceTime;
  int avgHeartRate;
  int maxHeartRate;
  double avgRunningCadence;
  double avgVerticalOscillation;
  int totalElapsedTime;
  int totalTimerTime;
  int totalTrainingEffect;
  double necLat;
  double necLong;
  double swcLat;
  double swcLong;
  int firstLapIndex;
  int numLaps;
  int numSessions;
  DateTime localTimestamp;
  double avgPower;
  double sdevPower;
  int minPower;
  int maxPower;
  int minHeartRate;
  double sdevHeartRate;
  double avgGroundTime;
  double sdevGroundTime;
  double avgLegSpringStiffness;
  double sdevLegSpringStiffness;
  double avgFormPower;
  double sdevFormPower;
  double avgPowerRatio;
  double sdevPowerRatio;
  double avgStrideRatio;
  double sdevStrideRatio;
  double avgStrydCadence;
  double sdevStrydCadence;
  double sdevVerticalOscillation;
  double cp;
  double ftp;
  int athletesId;

  BoolResult saveResult;
  // end FIELDS (DbActivity)

// RELATIONSHIPS (DbActivity)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbAthlete', 'plField2'..]) or so on..
  DbAthlete plDbAthlete;

  /// get DbAthlete By AthletesId
  Future<DbAthlete> getDbAthlete(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbAthlete().getById(athletesId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbActivity)

// COLLECTIONS & VIRTUALS (DbActivity)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbEvents', 'plField2'..]) or so on..
  List<DbEvent> plDbEvents;

  /// get DbEvent(s) filtered by id=activitiesId
  DbEventFilterBuilder getDbEvents(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbEvent()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .activitiesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbLaps', 'plField2'..]) or so on..
  List<DbLap> plDbLaps;

  /// get DbLap(s) filtered by id=activitiesId
  DbLapFilterBuilder getDbLaps(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbLap()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .activitiesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbIntervals', 'plField2'..]) or so on..
  List<DbInterval> plDbIntervals;

  /// get DbInterval(s) filtered by id=activitiesId
  DbIntervalFilterBuilder getDbIntervals(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbInterval()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .activitiesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbActivityTaggings', 'plField2'..]) or so on..
  List<DbActivityTagging> plDbActivityTaggings;

  /// get DbActivityTagging(s) filtered by id=activitiesId
  DbActivityTaggingFilterBuilder getDbActivityTaggings(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbActivityTagging()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .activitiesId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (DbActivity)

  static const bool _softDeleteActivated = false;
  DbActivityManager __mnDbActivity;

  DbActivityManager get _mnDbActivity {
    return __mnDbActivity = __mnDbActivity ?? DbActivityManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (path != null) {
      map['path'] = path;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (movingTime != null) {
      map['movingTime'] = movingTime;
    }

    if (type != null) {
      map['type'] = type;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (serialNumber != null) {
      map['serialNumber'] = serialNumber;
    }

    if (timeCreated != null) {
      map['timeCreated'] = forJson
          ? timeCreated.toString()
          : forQuery ? timeCreated.millisecondsSinceEpoch : timeCreated;
    }

    if (sportName != null) {
      map['sportName'] = sportName;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (avgSpeedByMeasurements != null) {
      map['avgSpeedByMeasurements'] = avgSpeedByMeasurements;
    }

    if (avgSpeedBySpeed != null) {
      map['avgSpeedBySpeed'] = avgSpeedBySpeed;
    }

    if (avgSpeedByDistance != null) {
      map['avgSpeedByDistance'] = avgSpeedByDistance;
    }

    if (sdevSpeed != null) {
      map['sdevSpeed'] = sdevSpeed;
    }

    if (sdevPace != null) {
      map['sdevPace'] = sdevPace;
    }

    if (minSpeed != null) {
      map['minSpeed'] = minSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (trigger != null) {
      map['trigger'] = trigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalTrainingEffect != null) {
      map['totalTrainingEffect'] = totalTrainingEffect;
    }

    if (necLat != null) {
      map['necLat'] = necLat;
    }

    if (necLong != null) {
      map['necLong'] = necLong;
    }

    if (swcLat != null) {
      map['swcLat'] = swcLat;
    }

    if (swcLong != null) {
      map['swcLong'] = swcLong;
    }

    if (firstLapIndex != null) {
      map['firstLapIndex'] = firstLapIndex;
    }

    if (numLaps != null) {
      map['numLaps'] = numLaps;
    }

    if (numSessions != null) {
      map['numSessions'] = numSessions;
    }

    if (localTimestamp != null) {
      map['localTimestamp'] = forJson
          ? localTimestamp.toString()
          : forQuery ? localTimestamp.millisecondsSinceEpoch : localTimestamp;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (minHeartRate != null) {
      map['minHeartRate'] = minHeartRate;
    }

    if (sdevHeartRate != null) {
      map['sdevHeartRate'] = sdevHeartRate;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgPowerRatio != null) {
      map['avgPowerRatio'] = avgPowerRatio;
    }

    if (sdevPowerRatio != null) {
      map['sdevPowerRatio'] = sdevPowerRatio;
    }

    if (avgStrideRatio != null) {
      map['avgStrideRatio'] = avgStrideRatio;
    }

    if (sdevStrideRatio != null) {
      map['sdevStrideRatio'] = sdevStrideRatio;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (cp != null) {
      map['cp'] = cp;
    }

    if (ftp != null) {
      map['ftp'] = ftp;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (path != null) {
      map['path'] = path;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (movingTime != null) {
      map['movingTime'] = movingTime;
    }

    if (type != null) {
      map['type'] = type;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (serialNumber != null) {
      map['serialNumber'] = serialNumber;
    }

    if (timeCreated != null) {
      map['timeCreated'] = forJson
          ? timeCreated.toString()
          : forQuery ? timeCreated.millisecondsSinceEpoch : timeCreated;
    }

    if (sportName != null) {
      map['sportName'] = sportName;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (avgSpeedByMeasurements != null) {
      map['avgSpeedByMeasurements'] = avgSpeedByMeasurements;
    }

    if (avgSpeedBySpeed != null) {
      map['avgSpeedBySpeed'] = avgSpeedBySpeed;
    }

    if (avgSpeedByDistance != null) {
      map['avgSpeedByDistance'] = avgSpeedByDistance;
    }

    if (sdevSpeed != null) {
      map['sdevSpeed'] = sdevSpeed;
    }

    if (sdevPace != null) {
      map['sdevPace'] = sdevPace;
    }

    if (minSpeed != null) {
      map['minSpeed'] = minSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (trigger != null) {
      map['trigger'] = trigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalTrainingEffect != null) {
      map['totalTrainingEffect'] = totalTrainingEffect;
    }

    if (necLat != null) {
      map['necLat'] = necLat;
    }

    if (necLong != null) {
      map['necLong'] = necLong;
    }

    if (swcLat != null) {
      map['swcLat'] = swcLat;
    }

    if (swcLong != null) {
      map['swcLong'] = swcLong;
    }

    if (firstLapIndex != null) {
      map['firstLapIndex'] = firstLapIndex;
    }

    if (numLaps != null) {
      map['numLaps'] = numLaps;
    }

    if (numSessions != null) {
      map['numSessions'] = numSessions;
    }

    if (localTimestamp != null) {
      map['localTimestamp'] = forJson
          ? localTimestamp.toString()
          : forQuery ? localTimestamp.millisecondsSinceEpoch : localTimestamp;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (minHeartRate != null) {
      map['minHeartRate'] = minHeartRate;
    }

    if (sdevHeartRate != null) {
      map['sdevHeartRate'] = sdevHeartRate;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgPowerRatio != null) {
      map['avgPowerRatio'] = avgPowerRatio;
    }

    if (sdevPowerRatio != null) {
      map['sdevPowerRatio'] = sdevPowerRatio;
    }

    if (avgStrideRatio != null) {
      map['avgStrideRatio'] = avgStrideRatio;
    }

    if (sdevStrideRatio != null) {
      map['sdevStrideRatio'] = sdevStrideRatio;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (cp != null) {
      map['cp'] = cp;
    }

    if (ftp != null) {
      map['ftp'] = ftp;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

// COLLECTIONS (DbActivity)
    if (!forQuery) {
      map['DbEvents'] = await getDbEvents().toMapList();
    }
    if (!forQuery) {
      map['DbLaps'] = await getDbLaps().toMapList();
    }
    if (!forQuery) {
      map['DbIntervals'] = await getDbIntervals().toMapList();
    }
    if (!forQuery) {
      map['DbActivityTaggings'] = await getDbActivityTaggings().toMapList();
    }
// END COLLECTIONS (DbActivity)

    return map;
  }

  /// This method returns Json String [DbActivity]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbActivity]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      state,
      path,
      stravaId,
      name,
      movingTime,
      type,
      distance,
      serialNumber,
      timeCreated != null ? timeCreated.millisecondsSinceEpoch : null,
      sportName,
      sport,
      subSport,
      timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
      startTime != null ? startTime.millisecondsSinceEpoch : null,
      startPositionLat,
      startPositionLong,
      event,
      eventType,
      eventGroup,
      totalDistance,
      totalStrides,
      totalCalories,
      avgSpeed,
      avgSpeedByMeasurements,
      avgSpeedBySpeed,
      avgSpeedByDistance,
      sdevSpeed,
      sdevPace,
      minSpeed,
      maxSpeed,
      totalAscent,
      totalDescent,
      maxRunningCadence,
      trigger,
      avgTemperature,
      maxTemperature,
      avgFractionalCadence,
      maxFractionalCadence,
      totalFractionalCycles,
      avgStanceTimePercent,
      avgStanceTime,
      avgHeartRate,
      maxHeartRate,
      avgRunningCadence,
      avgVerticalOscillation,
      totalElapsedTime,
      totalTimerTime,
      totalTrainingEffect,
      necLat,
      necLong,
      swcLat,
      swcLong,
      firstLapIndex,
      numLaps,
      numSessions,
      localTimestamp != null ? localTimestamp.millisecondsSinceEpoch : null,
      avgPower,
      sdevPower,
      minPower,
      maxPower,
      minHeartRate,
      sdevHeartRate,
      avgGroundTime,
      sdevGroundTime,
      avgLegSpringStiffness,
      sdevLegSpringStiffness,
      avgFormPower,
      sdevFormPower,
      avgPowerRatio,
      sdevPowerRatio,
      avgStrideRatio,
      sdevStrideRatio,
      avgStrydCadence,
      sdevStrydCadence,
      sdevVerticalOscillation,
      cp,
      ftp,
      athletesId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      state,
      path,
      stravaId,
      name,
      movingTime,
      type,
      distance,
      serialNumber,
      timeCreated != null ? timeCreated.millisecondsSinceEpoch : null,
      sportName,
      sport,
      subSport,
      timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
      startTime != null ? startTime.millisecondsSinceEpoch : null,
      startPositionLat,
      startPositionLong,
      event,
      eventType,
      eventGroup,
      totalDistance,
      totalStrides,
      totalCalories,
      avgSpeed,
      avgSpeedByMeasurements,
      avgSpeedBySpeed,
      avgSpeedByDistance,
      sdevSpeed,
      sdevPace,
      minSpeed,
      maxSpeed,
      totalAscent,
      totalDescent,
      maxRunningCadence,
      trigger,
      avgTemperature,
      maxTemperature,
      avgFractionalCadence,
      maxFractionalCadence,
      totalFractionalCycles,
      avgStanceTimePercent,
      avgStanceTime,
      avgHeartRate,
      maxHeartRate,
      avgRunningCadence,
      avgVerticalOscillation,
      totalElapsedTime,
      totalTimerTime,
      totalTrainingEffect,
      necLat,
      necLong,
      swcLat,
      swcLong,
      firstLapIndex,
      numLaps,
      numSessions,
      localTimestamp != null ? localTimestamp.millisecondsSinceEpoch : null,
      avgPower,
      sdevPower,
      minPower,
      maxPower,
      minHeartRate,
      sdevHeartRate,
      avgGroundTime,
      sdevGroundTime,
      avgLegSpringStiffness,
      sdevLegSpringStiffness,
      avgFormPower,
      sdevFormPower,
      avgPowerRatio,
      sdevPowerRatio,
      avgStrideRatio,
      sdevStrideRatio,
      avgStrydCadence,
      sdevStrydCadence,
      sdevVerticalOscillation,
      cp,
      ftp,
      athletesId
    ];
  }

  static Future<List<DbActivity>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbActivity.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbActivity>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbActivity>[];
    try {
      objList = list
          .map((dbactivity) =>
              DbActivity.fromMap(dbactivity as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbActivity.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbActivity>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbActivity> objList = <DbActivity>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbActivity.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('activities.plDbEvents') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbEvents'))) {
          /*_loadedFields.add('activities.plDbEvents'); */
          obj.plDbEvents = obj.plDbEvents ??
              await obj.getDbEvents().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbLaps') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbLaps'))) {
          /*_loadedFields.add('activities.plDbLaps'); */
          obj.plDbLaps = obj.plDbLaps ??
              await obj.getDbLaps().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbIntervals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervals'))) {
          /*_loadedFields.add('activities.plDbIntervals'); */
          obj.plDbIntervals = obj.plDbIntervals ??
              await obj.getDbIntervals().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbActivityTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbActivityTaggings'))) {
          /*_loadedFields.add('activities.plDbActivityTaggings'); */
          obj.plDbActivityTaggings = obj.plDbActivityTaggings ??
              await obj.getDbActivityTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbActivity by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbActivity if exist, otherwise returns null
  Future<DbActivity> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbActivity obj;
    final data = await _mnDbActivity.getById([id]);
    if (data.length != 0) {
      obj = DbActivity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('activities.plDbEvents') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbEvents'))) {
          /*_loadedFields.add('activities.plDbEvents'); */
          obj.plDbEvents = obj.plDbEvents ??
              await obj.getDbEvents().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbLaps') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbLaps'))) {
          /*_loadedFields.add('activities.plDbLaps'); */
          obj.plDbLaps = obj.plDbLaps ??
              await obj.getDbLaps().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbIntervals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervals'))) {
          /*_loadedFields.add('activities.plDbIntervals'); */
          obj.plDbIntervals = obj.plDbIntervals ??
              await obj.getDbIntervals().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbActivityTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbActivityTaggings'))) {
          /*_loadedFields.add('activities.plDbActivityTaggings'); */
          obj.plDbActivityTaggings = obj.plDbActivityTaggings ??
              await obj.getDbActivityTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbActivity) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbActivity.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbActivity.update(this);
    }

    return id;
  }

  /// saveAs DbActivity. Returns a new Primary Key value of DbActivity

  /// <returns>Returns a new Primary Key value of DbActivity
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbActivity> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DbActivity> dbactivities) async {
    // final results = _mnDbActivity.saveAll('INSERT OR REPLACE INTO activities (id,state, path, stravaId, name, movingTime, type, distance, serialNumber, timeCreated, sportName, sport, subSport, timeStamp, startTime, startPositionLat, startPositionLong, event, eventType, eventGroup, totalDistance, totalStrides, totalCalories, avgSpeed, avgSpeedByMeasurements, avgSpeedBySpeed, avgSpeedByDistance, sdevSpeed, sdevPace, minSpeed, maxSpeed, totalAscent, totalDescent, maxRunningCadence, trigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgStanceTimePercent, avgStanceTime, avgHeartRate, maxHeartRate, avgRunningCadence, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalTrainingEffect, necLat, necLong, swcLat, swcLong, firstLapIndex, numLaps, numSessions, localTimestamp, avgPower, sdevPower, minPower, maxPower, minHeartRate, sdevHeartRate, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgPowerRatio, sdevPowerRatio, avgStrideRatio, sdevStrideRatio, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, cp, ftp, athletesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',dbactivities);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbactivities) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbactivities.length; i++) {
      if (dbactivities[i].id == null) {
        dbactivities[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbActivity.rawInsert(
              'INSERT OR REPLACE INTO activities (id,state, path, stravaId, name, movingTime, type, distance, serialNumber, timeCreated, sportName, sport, subSport, timeStamp, startTime, startPositionLat, startPositionLong, event, eventType, eventGroup, totalDistance, totalStrides, totalCalories, avgSpeed, avgSpeedByMeasurements, avgSpeedBySpeed, avgSpeedByDistance, sdevSpeed, sdevPace, minSpeed, maxSpeed, totalAscent, totalDescent, maxRunningCadence, trigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgStanceTimePercent, avgStanceTime, avgHeartRate, maxHeartRate, avgRunningCadence, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalTrainingEffect, necLat, necLong, swcLat, swcLong, firstLapIndex, numLaps, numSessions, localTimestamp, avgPower, sdevPower, minPower, maxPower, minHeartRate, sdevHeartRate, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgPowerRatio, sdevPowerRatio, avgStrideRatio, sdevStrideRatio, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, cp, ftp, athletesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                state,
                path,
                stravaId,
                name,
                movingTime,
                type,
                distance,
                serialNumber,
                timeCreated != null ? timeCreated.millisecondsSinceEpoch : null,
                sportName,
                sport,
                subSport,
                timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
                startTime != null ? startTime.millisecondsSinceEpoch : null,
                startPositionLat,
                startPositionLong,
                event,
                eventType,
                eventGroup,
                totalDistance,
                totalStrides,
                totalCalories,
                avgSpeed,
                avgSpeedByMeasurements,
                avgSpeedBySpeed,
                avgSpeedByDistance,
                sdevSpeed,
                sdevPace,
                minSpeed,
                maxSpeed,
                totalAscent,
                totalDescent,
                maxRunningCadence,
                trigger,
                avgTemperature,
                maxTemperature,
                avgFractionalCadence,
                maxFractionalCadence,
                totalFractionalCycles,
                avgStanceTimePercent,
                avgStanceTime,
                avgHeartRate,
                maxHeartRate,
                avgRunningCadence,
                avgVerticalOscillation,
                totalElapsedTime,
                totalTimerTime,
                totalTrainingEffect,
                necLat,
                necLong,
                swcLat,
                swcLong,
                firstLapIndex,
                numLaps,
                numSessions,
                localTimestamp != null
                    ? localTimestamp.millisecondsSinceEpoch
                    : null,
                avgPower,
                sdevPower,
                minPower,
                maxPower,
                minHeartRate,
                sdevHeartRate,
                avgGroundTime,
                sdevGroundTime,
                avgLegSpringStiffness,
                sdevLegSpringStiffness,
                avgFormPower,
                sdevFormPower,
                avgPowerRatio,
                sdevPowerRatio,
                avgStrideRatio,
                sdevStrideRatio,
                avgStrydCadence,
                sdevStrydCadence,
                sdevVerticalOscillation,
                cp,
                ftp,
                athletesId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbActivity id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbActivity id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbActivity Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbActivity>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<DbActivity> dbactivities) async {
    final results = await _mnDbActivity.rawInsertAll(
        'INSERT OR REPLACE INTO activities (id,state, path, stravaId, name, movingTime, type, distance, serialNumber, timeCreated, sportName, sport, subSport, timeStamp, startTime, startPositionLat, startPositionLong, event, eventType, eventGroup, totalDistance, totalStrides, totalCalories, avgSpeed, avgSpeedByMeasurements, avgSpeedBySpeed, avgSpeedByDistance, sdevSpeed, sdevPace, minSpeed, maxSpeed, totalAscent, totalDescent, maxRunningCadence, trigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgStanceTimePercent, avgStanceTime, avgHeartRate, maxHeartRate, avgRunningCadence, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalTrainingEffect, necLat, necLong, swcLat, swcLong, firstLapIndex, numLaps, numSessions, localTimestamp, avgPower, sdevPower, minPower, maxPower, minHeartRate, sdevHeartRate, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgPowerRatio, sdevPowerRatio, avgStrideRatio, sdevStrideRatio, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, cp, ftp, athletesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbactivities);
    return results;
  }

  /// Deletes DbActivity

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbActivity invoked (id=$id)');
    var result = BoolResult();
    {
      result = await DbEvent()
          .select()
          .activitiesId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result =
          await DbLap().select().activitiesId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbInterval()
          .select()
          .activitiesId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbActivityTagging()
          .select()
          .activitiesId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbActivity
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbActivity.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbActivityFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbActivityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbActivityFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbActivityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    state = state ?? 'new';
    athletesId = athletesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbactivity

// region DbActivityField
class DbActivityField extends SearchCriteria {
  DbActivityField(this.dbactivityFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbActivityFilterBuilder dbactivityFB;

  DbActivityField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbActivityFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param, SqlSyntax.EQuals,
            dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.NotEQuals, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder isNull() {
    dbactivityFB._addedBlocks = setCriteria(
        0,
        dbactivityFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbactivityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbactivityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks);
      _waitingNot = '';
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
    }
    return dbactivityFB;
  }

  DbActivityFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbactivityFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbactivityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks);
      _waitingNot = '';
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
    }
    return dbactivityFB;
  }

  DbActivityFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbactivityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbactivityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks);
      _waitingNot = '';
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
    }
    return dbactivityFB;
  }

  DbActivityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbactivityFB._addedBlocks = setCriteria(
          pFirst,
          dbactivityFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbactivityFB._addedBlocks = setCriteria(pFirst, dbactivityFB.parameters,
            param, SqlSyntax.LessThan, dbactivityFB._addedBlocks);
      } else {
        dbactivityFB._addedBlocks = setCriteria(pFirst, dbactivityFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbactivityFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbactivityFB._addedBlocks = setCriteria(pLast, dbactivityFB.parameters,
            param, SqlSyntax.GreaterThan, dbactivityFB._addedBlocks);
      } else {
        dbactivityFB._addedBlocks = setCriteria(pLast, dbactivityFB.parameters,
            param, SqlSyntax.LessThanOrEquals, dbactivityFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThan, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThan, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThan, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThan, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder inValues(dynamic pValue) {
    dbactivityFB._addedBlocks = setCriteria(
        pValue,
        dbactivityFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }
}
// endregion DbActivityField

// region DbActivityFilterBuilder
class DbActivityFilterBuilder extends SearchCriteria {
  DbActivityFilterBuilder(DbActivity obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbActivity _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbActivityFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbActivityFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbActivityFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbActivityFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbActivityFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbActivityFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbActivityFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbActivityFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbActivityFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbActivityFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbActivityFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbActivityField setField(
      DbActivityField field, String colName, DbType dbtype) {
    return DbActivityField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbActivityField _id;
  DbActivityField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbActivityField _state;
  DbActivityField get state {
    return _state = setField(_state, 'state', DbType.text);
  }

  DbActivityField _path;
  DbActivityField get path {
    return _path = setField(_path, 'path', DbType.text);
  }

  DbActivityField _stravaId;
  DbActivityField get stravaId {
    return _stravaId = setField(_stravaId, 'stravaId', DbType.integer);
  }

  DbActivityField _name;
  DbActivityField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbActivityField _movingTime;
  DbActivityField get movingTime {
    return _movingTime = setField(_movingTime, 'movingTime', DbType.integer);
  }

  DbActivityField _type;
  DbActivityField get type {
    return _type = setField(_type, 'type', DbType.text);
  }

  DbActivityField _distance;
  DbActivityField get distance {
    return _distance = setField(_distance, 'distance', DbType.integer);
  }

  DbActivityField _serialNumber;
  DbActivityField get serialNumber {
    return _serialNumber =
        setField(_serialNumber, 'serialNumber', DbType.integer);
  }

  DbActivityField _timeCreated;
  DbActivityField get timeCreated {
    return _timeCreated =
        setField(_timeCreated, 'timeCreated', DbType.datetime);
  }

  DbActivityField _sportName;
  DbActivityField get sportName {
    return _sportName = setField(_sportName, 'sportName', DbType.text);
  }

  DbActivityField _sport;
  DbActivityField get sport {
    return _sport = setField(_sport, 'sport', DbType.text);
  }

  DbActivityField _subSport;
  DbActivityField get subSport {
    return _subSport = setField(_subSport, 'subSport', DbType.text);
  }

  DbActivityField _timeStamp;
  DbActivityField get timeStamp {
    return _timeStamp = setField(_timeStamp, 'timeStamp', DbType.datetime);
  }

  DbActivityField _startTime;
  DbActivityField get startTime {
    return _startTime = setField(_startTime, 'startTime', DbType.datetime);
  }

  DbActivityField _startPositionLat;
  DbActivityField get startPositionLat {
    return _startPositionLat =
        setField(_startPositionLat, 'startPositionLat', DbType.real);
  }

  DbActivityField _startPositionLong;
  DbActivityField get startPositionLong {
    return _startPositionLong =
        setField(_startPositionLong, 'startPositionLong', DbType.real);
  }

  DbActivityField _event;
  DbActivityField get event {
    return _event = setField(_event, 'event', DbType.text);
  }

  DbActivityField _eventType;
  DbActivityField get eventType {
    return _eventType = setField(_eventType, 'eventType', DbType.text);
  }

  DbActivityField _eventGroup;
  DbActivityField get eventGroup {
    return _eventGroup = setField(_eventGroup, 'eventGroup', DbType.integer);
  }

  DbActivityField _totalDistance;
  DbActivityField get totalDistance {
    return _totalDistance =
        setField(_totalDistance, 'totalDistance', DbType.integer);
  }

  DbActivityField _totalStrides;
  DbActivityField get totalStrides {
    return _totalStrides =
        setField(_totalStrides, 'totalStrides', DbType.integer);
  }

  DbActivityField _totalCalories;
  DbActivityField get totalCalories {
    return _totalCalories =
        setField(_totalCalories, 'totalCalories', DbType.integer);
  }

  DbActivityField _avgSpeed;
  DbActivityField get avgSpeed {
    return _avgSpeed = setField(_avgSpeed, 'avgSpeed', DbType.real);
  }

  DbActivityField _avgSpeedByMeasurements;
  DbActivityField get avgSpeedByMeasurements {
    return _avgSpeedByMeasurements = setField(
        _avgSpeedByMeasurements, 'avgSpeedByMeasurements', DbType.real);
  }

  DbActivityField _avgSpeedBySpeed;
  DbActivityField get avgSpeedBySpeed {
    return _avgSpeedBySpeed =
        setField(_avgSpeedBySpeed, 'avgSpeedBySpeed', DbType.real);
  }

  DbActivityField _avgSpeedByDistance;
  DbActivityField get avgSpeedByDistance {
    return _avgSpeedByDistance =
        setField(_avgSpeedByDistance, 'avgSpeedByDistance', DbType.real);
  }

  DbActivityField _sdevSpeed;
  DbActivityField get sdevSpeed {
    return _sdevSpeed = setField(_sdevSpeed, 'sdevSpeed', DbType.real);
  }

  DbActivityField _sdevPace;
  DbActivityField get sdevPace {
    return _sdevPace = setField(_sdevPace, 'sdevPace', DbType.real);
  }

  DbActivityField _minSpeed;
  DbActivityField get minSpeed {
    return _minSpeed = setField(_minSpeed, 'minSpeed', DbType.real);
  }

  DbActivityField _maxSpeed;
  DbActivityField get maxSpeed {
    return _maxSpeed = setField(_maxSpeed, 'maxSpeed', DbType.real);
  }

  DbActivityField _totalAscent;
  DbActivityField get totalAscent {
    return _totalAscent = setField(_totalAscent, 'totalAscent', DbType.integer);
  }

  DbActivityField _totalDescent;
  DbActivityField get totalDescent {
    return _totalDescent =
        setField(_totalDescent, 'totalDescent', DbType.integer);
  }

  DbActivityField _maxRunningCadence;
  DbActivityField get maxRunningCadence {
    return _maxRunningCadence =
        setField(_maxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  DbActivityField _trigger;
  DbActivityField get trigger {
    return _trigger = setField(_trigger, 'trigger', DbType.text);
  }

  DbActivityField _avgTemperature;
  DbActivityField get avgTemperature {
    return _avgTemperature =
        setField(_avgTemperature, 'avgTemperature', DbType.integer);
  }

  DbActivityField _maxTemperature;
  DbActivityField get maxTemperature {
    return _maxTemperature =
        setField(_maxTemperature, 'maxTemperature', DbType.integer);
  }

  DbActivityField _avgFractionalCadence;
  DbActivityField get avgFractionalCadence {
    return _avgFractionalCadence =
        setField(_avgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  DbActivityField _maxFractionalCadence;
  DbActivityField get maxFractionalCadence {
    return _maxFractionalCadence =
        setField(_maxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  DbActivityField _totalFractionalCycles;
  DbActivityField get totalFractionalCycles {
    return _totalFractionalCycles =
        setField(_totalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  DbActivityField _avgStanceTimePercent;
  DbActivityField get avgStanceTimePercent {
    return _avgStanceTimePercent =
        setField(_avgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  DbActivityField _avgStanceTime;
  DbActivityField get avgStanceTime {
    return _avgStanceTime =
        setField(_avgStanceTime, 'avgStanceTime', DbType.real);
  }

  DbActivityField _avgHeartRate;
  DbActivityField get avgHeartRate {
    return _avgHeartRate =
        setField(_avgHeartRate, 'avgHeartRate', DbType.integer);
  }

  DbActivityField _maxHeartRate;
  DbActivityField get maxHeartRate {
    return _maxHeartRate =
        setField(_maxHeartRate, 'maxHeartRate', DbType.integer);
  }

  DbActivityField _avgRunningCadence;
  DbActivityField get avgRunningCadence {
    return _avgRunningCadence =
        setField(_avgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  DbActivityField _avgVerticalOscillation;
  DbActivityField get avgVerticalOscillation {
    return _avgVerticalOscillation = setField(
        _avgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  DbActivityField _totalElapsedTime;
  DbActivityField get totalElapsedTime {
    return _totalElapsedTime =
        setField(_totalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  DbActivityField _totalTimerTime;
  DbActivityField get totalTimerTime {
    return _totalTimerTime =
        setField(_totalTimerTime, 'totalTimerTime', DbType.integer);
  }

  DbActivityField _totalTrainingEffect;
  DbActivityField get totalTrainingEffect {
    return _totalTrainingEffect =
        setField(_totalTrainingEffect, 'totalTrainingEffect', DbType.integer);
  }

  DbActivityField _necLat;
  DbActivityField get necLat {
    return _necLat = setField(_necLat, 'necLat', DbType.real);
  }

  DbActivityField _necLong;
  DbActivityField get necLong {
    return _necLong = setField(_necLong, 'necLong', DbType.real);
  }

  DbActivityField _swcLat;
  DbActivityField get swcLat {
    return _swcLat = setField(_swcLat, 'swcLat', DbType.real);
  }

  DbActivityField _swcLong;
  DbActivityField get swcLong {
    return _swcLong = setField(_swcLong, 'swcLong', DbType.real);
  }

  DbActivityField _firstLapIndex;
  DbActivityField get firstLapIndex {
    return _firstLapIndex =
        setField(_firstLapIndex, 'firstLapIndex', DbType.integer);
  }

  DbActivityField _numLaps;
  DbActivityField get numLaps {
    return _numLaps = setField(_numLaps, 'numLaps', DbType.integer);
  }

  DbActivityField _numSessions;
  DbActivityField get numSessions {
    return _numSessions = setField(_numSessions, 'numSessions', DbType.integer);
  }

  DbActivityField _localTimestamp;
  DbActivityField get localTimestamp {
    return _localTimestamp =
        setField(_localTimestamp, 'localTimestamp', DbType.datetime);
  }

  DbActivityField _avgPower;
  DbActivityField get avgPower {
    return _avgPower = setField(_avgPower, 'avgPower', DbType.real);
  }

  DbActivityField _sdevPower;
  DbActivityField get sdevPower {
    return _sdevPower = setField(_sdevPower, 'sdevPower', DbType.real);
  }

  DbActivityField _minPower;
  DbActivityField get minPower {
    return _minPower = setField(_minPower, 'minPower', DbType.integer);
  }

  DbActivityField _maxPower;
  DbActivityField get maxPower {
    return _maxPower = setField(_maxPower, 'maxPower', DbType.integer);
  }

  DbActivityField _minHeartRate;
  DbActivityField get minHeartRate {
    return _minHeartRate =
        setField(_minHeartRate, 'minHeartRate', DbType.integer);
  }

  DbActivityField _sdevHeartRate;
  DbActivityField get sdevHeartRate {
    return _sdevHeartRate =
        setField(_sdevHeartRate, 'sdevHeartRate', DbType.real);
  }

  DbActivityField _avgGroundTime;
  DbActivityField get avgGroundTime {
    return _avgGroundTime =
        setField(_avgGroundTime, 'avgGroundTime', DbType.real);
  }

  DbActivityField _sdevGroundTime;
  DbActivityField get sdevGroundTime {
    return _sdevGroundTime =
        setField(_sdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  DbActivityField _avgLegSpringStiffness;
  DbActivityField get avgLegSpringStiffness {
    return _avgLegSpringStiffness =
        setField(_avgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  DbActivityField _sdevLegSpringStiffness;
  DbActivityField get sdevLegSpringStiffness {
    return _sdevLegSpringStiffness = setField(
        _sdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  DbActivityField _avgFormPower;
  DbActivityField get avgFormPower {
    return _avgFormPower = setField(_avgFormPower, 'avgFormPower', DbType.real);
  }

  DbActivityField _sdevFormPower;
  DbActivityField get sdevFormPower {
    return _sdevFormPower =
        setField(_sdevFormPower, 'sdevFormPower', DbType.real);
  }

  DbActivityField _avgPowerRatio;
  DbActivityField get avgPowerRatio {
    return _avgPowerRatio =
        setField(_avgPowerRatio, 'avgPowerRatio', DbType.real);
  }

  DbActivityField _sdevPowerRatio;
  DbActivityField get sdevPowerRatio {
    return _sdevPowerRatio =
        setField(_sdevPowerRatio, 'sdevPowerRatio', DbType.real);
  }

  DbActivityField _avgStrideRatio;
  DbActivityField get avgStrideRatio {
    return _avgStrideRatio =
        setField(_avgStrideRatio, 'avgStrideRatio', DbType.real);
  }

  DbActivityField _sdevStrideRatio;
  DbActivityField get sdevStrideRatio {
    return _sdevStrideRatio =
        setField(_sdevStrideRatio, 'sdevStrideRatio', DbType.real);
  }

  DbActivityField _avgStrydCadence;
  DbActivityField get avgStrydCadence {
    return _avgStrydCadence =
        setField(_avgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  DbActivityField _sdevStrydCadence;
  DbActivityField get sdevStrydCadence {
    return _sdevStrydCadence =
        setField(_sdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  DbActivityField _sdevVerticalOscillation;
  DbActivityField get sdevVerticalOscillation {
    return _sdevVerticalOscillation = setField(
        _sdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  DbActivityField _cp;
  DbActivityField get cp {
    return _cp = setField(_cp, 'cp', DbType.real);
  }

  DbActivityField _ftp;
  DbActivityField get ftp {
    return _ftp = setField(_ftp, 'ftp', DbType.real);
  }

  DbActivityField _athletesId;
  DbActivityField get athletesId {
    return _athletesId = setField(_athletesId, 'athletesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbActivity._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbActivity> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Delete sub records where in (DbEvent) according to DeleteRule.CASCADE
    final idListDbEventBYactivitiesId = toListPrimaryKeySQL(false);
    final resDbEventBYactivitiesId = await DbEvent()
        .select()
        .where('activitiesId IN (${idListDbEventBYactivitiesId['sql']})',
            parameterValue: idListDbEventBYactivitiesId['args'])
        .delete(hardDelete);
    if (!resDbEventBYactivitiesId.success) {
      return resDbEventBYactivitiesId;
    }
// Delete sub records where in (DbLap) according to DeleteRule.CASCADE
    final idListDbLapBYactivitiesId = toListPrimaryKeySQL(false);
    final resDbLapBYactivitiesId = await DbLap()
        .select()
        .where('activitiesId IN (${idListDbLapBYactivitiesId['sql']})',
            parameterValue: idListDbLapBYactivitiesId['args'])
        .delete(hardDelete);
    if (!resDbLapBYactivitiesId.success) {
      return resDbLapBYactivitiesId;
    }
// Delete sub records where in (DbInterval) according to DeleteRule.CASCADE
    final idListDbIntervalBYactivitiesId = toListPrimaryKeySQL(false);
    final resDbIntervalBYactivitiesId = await DbInterval()
        .select()
        .where('activitiesId IN (${idListDbIntervalBYactivitiesId['sql']})',
            parameterValue: idListDbIntervalBYactivitiesId['args'])
        .delete(hardDelete);
    if (!resDbIntervalBYactivitiesId.success) {
      return resDbIntervalBYactivitiesId;
    }
// Delete sub records where in (DbActivityTagging) according to DeleteRule.CASCADE
    final idListDbActivityTaggingBYactivitiesId = toListPrimaryKeySQL(false);
    final resDbActivityTaggingBYactivitiesId = await DbActivityTagging()
        .select()
        .where(
            'activitiesId IN (${idListDbActivityTaggingBYactivitiesId['sql']})',
            parameterValue: idListDbActivityTaggingBYactivitiesId['args'])
        .delete(hardDelete);
    if (!resDbActivityTaggingBYactivitiesId.success) {
      return resDbActivityTaggingBYactivitiesId;
    }

    if (DbActivity._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbActivity.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbActivity.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from activities ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbActivity.updateBatch(qparams, values);
  }

  /// This method always returns DbActivity Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbActivity>
  Future<DbActivity> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbActivity.toList(qparams);
    final data = await objFuture;
    DbActivity obj;
    if (data.isNotEmpty) {
      obj = DbActivity.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('activities.plDbEvents') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbEvents'))) {
          /*_loadedFields.add('activities.plDbEvents'); */
          obj.plDbEvents = obj.plDbEvents ??
              await obj.getDbEvents().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbLaps') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbLaps'))) {
          /*_loadedFields.add('activities.plDbLaps'); */
          obj.plDbLaps = obj.plDbLaps ??
              await obj.getDbLaps().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbIntervals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervals'))) {
          /*_loadedFields.add('activities.plDbIntervals'); */
          obj.plDbIntervals = obj.plDbIntervals ??
              await obj.getDbIntervals().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbActivityTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbActivityTaggings'))) {
          /*_loadedFields.add('activities.plDbActivityTaggings'); */
          obj.plDbActivityTaggings = obj.plDbActivityTaggings ??
              await obj.getDbActivityTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbActivity]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbactivityCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbactivitiesFuture = await _obj._mnDbActivity.toList(qparams);
    final int count = dbactivitiesFuture[0]['CNT'] as int;
    if (dbactivityCount != null) {
      dbactivityCount(count);
    }
    return count;
  }

  /// This method returns List<DbActivity> [DbActivity]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbActivity>
  Future<List<DbActivity>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbActivity> dbactivitiesData = await DbActivity.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return dbactivitiesData;
  }

  /// This method returns Json String [DbActivity]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbActivity]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbActivity]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbActivity.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbActivity]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM activities WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbActivity.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbActivity]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbActivity.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbActivity.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbActivity.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbActivityFilterBuilder

// region DbActivityFields
class DbActivityFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fState;
  static TableField get state {
    return _fState =
        _fState ?? SqlSyntax.setField(_fState, 'state', DbType.text);
  }

  static TableField _fPath;
  static TableField get path {
    return _fPath = _fPath ?? SqlSyntax.setField(_fPath, 'path', DbType.text);
  }

  static TableField _fStravaId;
  static TableField get stravaId {
    return _fStravaId = _fStravaId ??
        SqlSyntax.setField(_fStravaId, 'stravaId', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fMovingTime;
  static TableField get movingTime {
    return _fMovingTime = _fMovingTime ??
        SqlSyntax.setField(_fMovingTime, 'movingTime', DbType.integer);
  }

  static TableField _fType;
  static TableField get type {
    return _fType = _fType ?? SqlSyntax.setField(_fType, 'type', DbType.text);
  }

  static TableField _fDistance;
  static TableField get distance {
    return _fDistance = _fDistance ??
        SqlSyntax.setField(_fDistance, 'distance', DbType.integer);
  }

  static TableField _fSerialNumber;
  static TableField get serialNumber {
    return _fSerialNumber = _fSerialNumber ??
        SqlSyntax.setField(_fSerialNumber, 'serialNumber', DbType.integer);
  }

  static TableField _fTimeCreated;
  static TableField get timeCreated {
    return _fTimeCreated = _fTimeCreated ??
        SqlSyntax.setField(_fTimeCreated, 'timeCreated', DbType.datetime);
  }

  static TableField _fSportName;
  static TableField get sportName {
    return _fSportName = _fSportName ??
        SqlSyntax.setField(_fSportName, 'sportName', DbType.text);
  }

  static TableField _fSport;
  static TableField get sport {
    return _fSport =
        _fSport ?? SqlSyntax.setField(_fSport, 'sport', DbType.text);
  }

  static TableField _fSubSport;
  static TableField get subSport {
    return _fSubSport =
        _fSubSport ?? SqlSyntax.setField(_fSubSport, 'subSport', DbType.text);
  }

  static TableField _fTimeStamp;
  static TableField get timeStamp {
    return _fTimeStamp = _fTimeStamp ??
        SqlSyntax.setField(_fTimeStamp, 'timeStamp', DbType.datetime);
  }

  static TableField _fStartTime;
  static TableField get startTime {
    return _fStartTime = _fStartTime ??
        SqlSyntax.setField(_fStartTime, 'startTime', DbType.datetime);
  }

  static TableField _fStartPositionLat;
  static TableField get startPositionLat {
    return _fStartPositionLat = _fStartPositionLat ??
        SqlSyntax.setField(_fStartPositionLat, 'startPositionLat', DbType.real);
  }

  static TableField _fStartPositionLong;
  static TableField get startPositionLong {
    return _fStartPositionLong = _fStartPositionLong ??
        SqlSyntax.setField(
            _fStartPositionLong, 'startPositionLong', DbType.real);
  }

  static TableField _fEvent;
  static TableField get event {
    return _fEvent =
        _fEvent ?? SqlSyntax.setField(_fEvent, 'event', DbType.text);
  }

  static TableField _fEventType;
  static TableField get eventType {
    return _fEventType = _fEventType ??
        SqlSyntax.setField(_fEventType, 'eventType', DbType.text);
  }

  static TableField _fEventGroup;
  static TableField get eventGroup {
    return _fEventGroup = _fEventGroup ??
        SqlSyntax.setField(_fEventGroup, 'eventGroup', DbType.integer);
  }

  static TableField _fTotalDistance;
  static TableField get totalDistance {
    return _fTotalDistance = _fTotalDistance ??
        SqlSyntax.setField(_fTotalDistance, 'totalDistance', DbType.integer);
  }

  static TableField _fTotalStrides;
  static TableField get totalStrides {
    return _fTotalStrides = _fTotalStrides ??
        SqlSyntax.setField(_fTotalStrides, 'totalStrides', DbType.integer);
  }

  static TableField _fTotalCalories;
  static TableField get totalCalories {
    return _fTotalCalories = _fTotalCalories ??
        SqlSyntax.setField(_fTotalCalories, 'totalCalories', DbType.integer);
  }

  static TableField _fAvgSpeed;
  static TableField get avgSpeed {
    return _fAvgSpeed =
        _fAvgSpeed ?? SqlSyntax.setField(_fAvgSpeed, 'avgSpeed', DbType.real);
  }

  static TableField _fAvgSpeedByMeasurements;
  static TableField get avgSpeedByMeasurements {
    return _fAvgSpeedByMeasurements = _fAvgSpeedByMeasurements ??
        SqlSyntax.setField(
            _fAvgSpeedByMeasurements, 'avgSpeedByMeasurements', DbType.real);
  }

  static TableField _fAvgSpeedBySpeed;
  static TableField get avgSpeedBySpeed {
    return _fAvgSpeedBySpeed = _fAvgSpeedBySpeed ??
        SqlSyntax.setField(_fAvgSpeedBySpeed, 'avgSpeedBySpeed', DbType.real);
  }

  static TableField _fAvgSpeedByDistance;
  static TableField get avgSpeedByDistance {
    return _fAvgSpeedByDistance = _fAvgSpeedByDistance ??
        SqlSyntax.setField(
            _fAvgSpeedByDistance, 'avgSpeedByDistance', DbType.real);
  }

  static TableField _fSdevSpeed;
  static TableField get sdevSpeed {
    return _fSdevSpeed = _fSdevSpeed ??
        SqlSyntax.setField(_fSdevSpeed, 'sdevSpeed', DbType.real);
  }

  static TableField _fSdevPace;
  static TableField get sdevPace {
    return _fSdevPace =
        _fSdevPace ?? SqlSyntax.setField(_fSdevPace, 'sdevPace', DbType.real);
  }

  static TableField _fMinSpeed;
  static TableField get minSpeed {
    return _fMinSpeed =
        _fMinSpeed ?? SqlSyntax.setField(_fMinSpeed, 'minSpeed', DbType.real);
  }

  static TableField _fMaxSpeed;
  static TableField get maxSpeed {
    return _fMaxSpeed =
        _fMaxSpeed ?? SqlSyntax.setField(_fMaxSpeed, 'maxSpeed', DbType.real);
  }

  static TableField _fTotalAscent;
  static TableField get totalAscent {
    return _fTotalAscent = _fTotalAscent ??
        SqlSyntax.setField(_fTotalAscent, 'totalAscent', DbType.integer);
  }

  static TableField _fTotalDescent;
  static TableField get totalDescent {
    return _fTotalDescent = _fTotalDescent ??
        SqlSyntax.setField(_fTotalDescent, 'totalDescent', DbType.integer);
  }

  static TableField _fMaxRunningCadence;
  static TableField get maxRunningCadence {
    return _fMaxRunningCadence = _fMaxRunningCadence ??
        SqlSyntax.setField(
            _fMaxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  static TableField _fTrigger;
  static TableField get trigger {
    return _fTrigger =
        _fTrigger ?? SqlSyntax.setField(_fTrigger, 'trigger', DbType.text);
  }

  static TableField _fAvgTemperature;
  static TableField get avgTemperature {
    return _fAvgTemperature = _fAvgTemperature ??
        SqlSyntax.setField(_fAvgTemperature, 'avgTemperature', DbType.integer);
  }

  static TableField _fMaxTemperature;
  static TableField get maxTemperature {
    return _fMaxTemperature = _fMaxTemperature ??
        SqlSyntax.setField(_fMaxTemperature, 'maxTemperature', DbType.integer);
  }

  static TableField _fAvgFractionalCadence;
  static TableField get avgFractionalCadence {
    return _fAvgFractionalCadence = _fAvgFractionalCadence ??
        SqlSyntax.setField(
            _fAvgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  static TableField _fMaxFractionalCadence;
  static TableField get maxFractionalCadence {
    return _fMaxFractionalCadence = _fMaxFractionalCadence ??
        SqlSyntax.setField(
            _fMaxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  static TableField _fTotalFractionalCycles;
  static TableField get totalFractionalCycles {
    return _fTotalFractionalCycles = _fTotalFractionalCycles ??
        SqlSyntax.setField(
            _fTotalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  static TableField _fAvgStanceTimePercent;
  static TableField get avgStanceTimePercent {
    return _fAvgStanceTimePercent = _fAvgStanceTimePercent ??
        SqlSyntax.setField(
            _fAvgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  static TableField _fAvgStanceTime;
  static TableField get avgStanceTime {
    return _fAvgStanceTime = _fAvgStanceTime ??
        SqlSyntax.setField(_fAvgStanceTime, 'avgStanceTime', DbType.real);
  }

  static TableField _fAvgHeartRate;
  static TableField get avgHeartRate {
    return _fAvgHeartRate = _fAvgHeartRate ??
        SqlSyntax.setField(_fAvgHeartRate, 'avgHeartRate', DbType.integer);
  }

  static TableField _fMaxHeartRate;
  static TableField get maxHeartRate {
    return _fMaxHeartRate = _fMaxHeartRate ??
        SqlSyntax.setField(_fMaxHeartRate, 'maxHeartRate', DbType.integer);
  }

  static TableField _fAvgRunningCadence;
  static TableField get avgRunningCadence {
    return _fAvgRunningCadence = _fAvgRunningCadence ??
        SqlSyntax.setField(
            _fAvgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  static TableField _fAvgVerticalOscillation;
  static TableField get avgVerticalOscillation {
    return _fAvgVerticalOscillation = _fAvgVerticalOscillation ??
        SqlSyntax.setField(
            _fAvgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  static TableField _fTotalElapsedTime;
  static TableField get totalElapsedTime {
    return _fTotalElapsedTime = _fTotalElapsedTime ??
        SqlSyntax.setField(
            _fTotalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  static TableField _fTotalTimerTime;
  static TableField get totalTimerTime {
    return _fTotalTimerTime = _fTotalTimerTime ??
        SqlSyntax.setField(_fTotalTimerTime, 'totalTimerTime', DbType.integer);
  }

  static TableField _fTotalTrainingEffect;
  static TableField get totalTrainingEffect {
    return _fTotalTrainingEffect = _fTotalTrainingEffect ??
        SqlSyntax.setField(
            _fTotalTrainingEffect, 'totalTrainingEffect', DbType.integer);
  }

  static TableField _fNecLat;
  static TableField get necLat {
    return _fNecLat =
        _fNecLat ?? SqlSyntax.setField(_fNecLat, 'necLat', DbType.real);
  }

  static TableField _fNecLong;
  static TableField get necLong {
    return _fNecLong =
        _fNecLong ?? SqlSyntax.setField(_fNecLong, 'necLong', DbType.real);
  }

  static TableField _fSwcLat;
  static TableField get swcLat {
    return _fSwcLat =
        _fSwcLat ?? SqlSyntax.setField(_fSwcLat, 'swcLat', DbType.real);
  }

  static TableField _fSwcLong;
  static TableField get swcLong {
    return _fSwcLong =
        _fSwcLong ?? SqlSyntax.setField(_fSwcLong, 'swcLong', DbType.real);
  }

  static TableField _fFirstLapIndex;
  static TableField get firstLapIndex {
    return _fFirstLapIndex = _fFirstLapIndex ??
        SqlSyntax.setField(_fFirstLapIndex, 'firstLapIndex', DbType.integer);
  }

  static TableField _fNumLaps;
  static TableField get numLaps {
    return _fNumLaps =
        _fNumLaps ?? SqlSyntax.setField(_fNumLaps, 'numLaps', DbType.integer);
  }

  static TableField _fNumSessions;
  static TableField get numSessions {
    return _fNumSessions = _fNumSessions ??
        SqlSyntax.setField(_fNumSessions, 'numSessions', DbType.integer);
  }

  static TableField _fLocalTimestamp;
  static TableField get localTimestamp {
    return _fLocalTimestamp = _fLocalTimestamp ??
        SqlSyntax.setField(_fLocalTimestamp, 'localTimestamp', DbType.datetime);
  }

  static TableField _fAvgPower;
  static TableField get avgPower {
    return _fAvgPower =
        _fAvgPower ?? SqlSyntax.setField(_fAvgPower, 'avgPower', DbType.real);
  }

  static TableField _fSdevPower;
  static TableField get sdevPower {
    return _fSdevPower = _fSdevPower ??
        SqlSyntax.setField(_fSdevPower, 'sdevPower', DbType.real);
  }

  static TableField _fMinPower;
  static TableField get minPower {
    return _fMinPower = _fMinPower ??
        SqlSyntax.setField(_fMinPower, 'minPower', DbType.integer);
  }

  static TableField _fMaxPower;
  static TableField get maxPower {
    return _fMaxPower = _fMaxPower ??
        SqlSyntax.setField(_fMaxPower, 'maxPower', DbType.integer);
  }

  static TableField _fMinHeartRate;
  static TableField get minHeartRate {
    return _fMinHeartRate = _fMinHeartRate ??
        SqlSyntax.setField(_fMinHeartRate, 'minHeartRate', DbType.integer);
  }

  static TableField _fSdevHeartRate;
  static TableField get sdevHeartRate {
    return _fSdevHeartRate = _fSdevHeartRate ??
        SqlSyntax.setField(_fSdevHeartRate, 'sdevHeartRate', DbType.real);
  }

  static TableField _fAvgGroundTime;
  static TableField get avgGroundTime {
    return _fAvgGroundTime = _fAvgGroundTime ??
        SqlSyntax.setField(_fAvgGroundTime, 'avgGroundTime', DbType.real);
  }

  static TableField _fSdevGroundTime;
  static TableField get sdevGroundTime {
    return _fSdevGroundTime = _fSdevGroundTime ??
        SqlSyntax.setField(_fSdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  static TableField _fAvgLegSpringStiffness;
  static TableField get avgLegSpringStiffness {
    return _fAvgLegSpringStiffness = _fAvgLegSpringStiffness ??
        SqlSyntax.setField(
            _fAvgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  static TableField _fSdevLegSpringStiffness;
  static TableField get sdevLegSpringStiffness {
    return _fSdevLegSpringStiffness = _fSdevLegSpringStiffness ??
        SqlSyntax.setField(
            _fSdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  static TableField _fAvgFormPower;
  static TableField get avgFormPower {
    return _fAvgFormPower = _fAvgFormPower ??
        SqlSyntax.setField(_fAvgFormPower, 'avgFormPower', DbType.real);
  }

  static TableField _fSdevFormPower;
  static TableField get sdevFormPower {
    return _fSdevFormPower = _fSdevFormPower ??
        SqlSyntax.setField(_fSdevFormPower, 'sdevFormPower', DbType.real);
  }

  static TableField _fAvgPowerRatio;
  static TableField get avgPowerRatio {
    return _fAvgPowerRatio = _fAvgPowerRatio ??
        SqlSyntax.setField(_fAvgPowerRatio, 'avgPowerRatio', DbType.real);
  }

  static TableField _fSdevPowerRatio;
  static TableField get sdevPowerRatio {
    return _fSdevPowerRatio = _fSdevPowerRatio ??
        SqlSyntax.setField(_fSdevPowerRatio, 'sdevPowerRatio', DbType.real);
  }

  static TableField _fAvgStrideRatio;
  static TableField get avgStrideRatio {
    return _fAvgStrideRatio = _fAvgStrideRatio ??
        SqlSyntax.setField(_fAvgStrideRatio, 'avgStrideRatio', DbType.real);
  }

  static TableField _fSdevStrideRatio;
  static TableField get sdevStrideRatio {
    return _fSdevStrideRatio = _fSdevStrideRatio ??
        SqlSyntax.setField(_fSdevStrideRatio, 'sdevStrideRatio', DbType.real);
  }

  static TableField _fAvgStrydCadence;
  static TableField get avgStrydCadence {
    return _fAvgStrydCadence = _fAvgStrydCadence ??
        SqlSyntax.setField(_fAvgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  static TableField _fSdevStrydCadence;
  static TableField get sdevStrydCadence {
    return _fSdevStrydCadence = _fSdevStrydCadence ??
        SqlSyntax.setField(_fSdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  static TableField _fSdevVerticalOscillation;
  static TableField get sdevVerticalOscillation {
    return _fSdevVerticalOscillation = _fSdevVerticalOscillation ??
        SqlSyntax.setField(
            _fSdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  static TableField _fCp;
  static TableField get cp {
    return _fCp = _fCp ?? SqlSyntax.setField(_fCp, 'cp', DbType.real);
  }

  static TableField _fFtp;
  static TableField get ftp {
    return _fFtp = _fFtp ?? SqlSyntax.setField(_fFtp, 'ftp', DbType.real);
  }

  static TableField _fAthletesId;
  static TableField get athletesId {
    return _fAthletesId = _fAthletesId ??
        SqlSyntax.setField(_fAthletesId, 'athletesId', DbType.integer);
  }
}
// endregion DbActivityFields

//region DbActivityManager
class DbActivityManager extends SqfEntityProvider {
  DbActivityManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'activities';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbActivityManager
// region DbEvent
class DbEvent {
  DbEvent(
      {this.id,
      this.event,
      this.eventType,
      this.eventGroup,
      this.timerTrigger,
      this.timeStamp,
      this.positionLat,
      this.positionLong,
      this.distance,
      this.altitude,
      this.speed,
      this.heartRate,
      this.cadence,
      this.fractionalCadence,
      this.power,
      this.strydCadence,
      this.groundTime,
      this.verticalOscillation,
      this.formPower,
      this.legSpringStiffness,
      this.data,
      this.activitiesId,
      this.lapsId}) {
    _setDefaultValues();
  }
  DbEvent.withFields(
      this.event,
      this.eventType,
      this.eventGroup,
      this.timerTrigger,
      this.timeStamp,
      this.positionLat,
      this.positionLong,
      this.distance,
      this.altitude,
      this.speed,
      this.heartRate,
      this.cadence,
      this.fractionalCadence,
      this.power,
      this.strydCadence,
      this.groundTime,
      this.verticalOscillation,
      this.formPower,
      this.legSpringStiffness,
      this.data,
      this.activitiesId,
      this.lapsId) {
    _setDefaultValues();
  }
  DbEvent.withId(
      this.id,
      this.event,
      this.eventType,
      this.eventGroup,
      this.timerTrigger,
      this.timeStamp,
      this.positionLat,
      this.positionLong,
      this.distance,
      this.altitude,
      this.speed,
      this.heartRate,
      this.cadence,
      this.fractionalCadence,
      this.power,
      this.strydCadence,
      this.groundTime,
      this.verticalOscillation,
      this.formPower,
      this.legSpringStiffness,
      this.data,
      this.activitiesId,
      this.lapsId) {
    _setDefaultValues();
  }
  DbEvent.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['event'] != null) {
      event = o['event'] as String;
    }
    if (o['eventType'] != null) {
      eventType = o['eventType'] as String;
    }
    if (o['eventGroup'] != null) {
      eventGroup = int.tryParse(o['eventGroup'].toString());
    }
    if (o['timerTrigger'] != null) {
      timerTrigger = o['timerTrigger'] as String;
    }
    if (o['timeStamp'] != null) {
      timeStamp = int.tryParse(o['timeStamp'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['timeStamp'].toString()))
          : DateTime.tryParse(o['timeStamp'].toString());
    }
    if (o['positionLat'] != null) {
      positionLat = double.tryParse(o['positionLat'].toString());
    }
    if (o['positionLong'] != null) {
      positionLong = double.tryParse(o['positionLong'].toString());
    }
    if (o['distance'] != null) {
      distance = double.tryParse(o['distance'].toString());
    }
    if (o['altitude'] != null) {
      altitude = double.tryParse(o['altitude'].toString());
    }
    if (o['speed'] != null) {
      speed = double.tryParse(o['speed'].toString());
    }
    if (o['heartRate'] != null) {
      heartRate = int.tryParse(o['heartRate'].toString());
    }
    if (o['cadence'] != null) {
      cadence = double.tryParse(o['cadence'].toString());
    }
    if (o['fractionalCadence'] != null) {
      fractionalCadence = double.tryParse(o['fractionalCadence'].toString());
    }
    if (o['power'] != null) {
      power = int.tryParse(o['power'].toString());
    }
    if (o['strydCadence'] != null) {
      strydCadence = double.tryParse(o['strydCadence'].toString());
    }
    if (o['groundTime'] != null) {
      groundTime = double.tryParse(o['groundTime'].toString());
    }
    if (o['verticalOscillation'] != null) {
      verticalOscillation =
          double.tryParse(o['verticalOscillation'].toString());
    }
    if (o['formPower'] != null) {
      formPower = int.tryParse(o['formPower'].toString());
    }
    if (o['legSpringStiffness'] != null) {
      legSpringStiffness = double.tryParse(o['legSpringStiffness'].toString());
    }
    if (o['data'] != null) {
      data = double.tryParse(o['data'].toString());
    }
    activitiesId = int.tryParse(o['activitiesId'].toString());

    lapsId = int.tryParse(o['lapsId'].toString());

    // RELATIONSHIPS FromMAP
    plDbActivity = o['dbActivity'] != null
        ? DbActivity.fromMap(o['dbActivity'] as Map<String, dynamic>)
        : null;
    plDbLap = o['dbLap'] != null
        ? DbLap.fromMap(o['dbLap'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbEvent)
  int id;
  String event;
  String eventType;
  int eventGroup;
  String timerTrigger;
  DateTime timeStamp;
  double positionLat;
  double positionLong;
  double distance;
  double altitude;
  double speed;
  int heartRate;
  double cadence;
  double fractionalCadence;
  int power;
  double strydCadence;
  double groundTime;
  double verticalOscillation;
  int formPower;
  double legSpringStiffness;
  double data;
  int activitiesId;
  int lapsId;

  BoolResult saveResult;
  // end FIELDS (DbEvent)

// RELATIONSHIPS (DbEvent)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbActivity', 'plField2'..]) or so on..
  DbActivity plDbActivity;

  /// get DbActivity By ActivitiesId
  Future<DbActivity> getDbActivity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbActivity().getById(activitiesId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbLap', 'plField2'..]) or so on..
  DbLap plDbLap;

  /// get DbLap By LapsId
  Future<DbLap> getDbLap(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbLap()
        .getById(lapsId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbEvent)

// COLLECTIONS & VIRTUALS (DbEvent)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbIntervals', 'plField2'..]) or so on..
  List<DbInterval> plDbIntervals;

  /// get DbInterval(s) filtered by id=firstRecordId
  DbIntervalFilterBuilder getDbIntervals(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbInterval()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .firstRecordId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbIntervalsBylastRecordId', 'plField2'..]) or so on..
  List<DbInterval> plDbIntervalsBylastRecordId;

  /// get DbInterval(s) filtered by id=lastRecordId
  DbIntervalFilterBuilder getDbIntervalsBylastRecordId(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbInterval()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .lastRecordId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (DbEvent)

  static const bool _softDeleteActivated = false;
  DbEventManager __mnDbEvent;

  DbEventManager get _mnDbEvent {
    return __mnDbEvent = __mnDbEvent ?? DbEventManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (timerTrigger != null) {
      map['timerTrigger'] = timerTrigger;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (positionLat != null) {
      map['positionLat'] = positionLat;
    }

    if (positionLong != null) {
      map['positionLong'] = positionLong;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (altitude != null) {
      map['altitude'] = altitude;
    }

    if (speed != null) {
      map['speed'] = speed;
    }

    if (heartRate != null) {
      map['heartRate'] = heartRate;
    }

    if (cadence != null) {
      map['cadence'] = cadence;
    }

    if (fractionalCadence != null) {
      map['fractionalCadence'] = fractionalCadence;
    }

    if (power != null) {
      map['power'] = power;
    }

    if (strydCadence != null) {
      map['strydCadence'] = strydCadence;
    }

    if (groundTime != null) {
      map['groundTime'] = groundTime;
    }

    if (verticalOscillation != null) {
      map['verticalOscillation'] = verticalOscillation;
    }

    if (formPower != null) {
      map['formPower'] = formPower;
    }

    if (legSpringStiffness != null) {
      map['legSpringStiffness'] = legSpringStiffness;
    }

    if (data != null) {
      map['data'] = data;
    }

    if (activitiesId != null) {
      map['activitiesId'] = forView ? plDbActivity.state : activitiesId;
    }

    if (lapsId != null) {
      map['lapsId'] = forView ? plDbLap.event : lapsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (timerTrigger != null) {
      map['timerTrigger'] = timerTrigger;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (positionLat != null) {
      map['positionLat'] = positionLat;
    }

    if (positionLong != null) {
      map['positionLong'] = positionLong;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (altitude != null) {
      map['altitude'] = altitude;
    }

    if (speed != null) {
      map['speed'] = speed;
    }

    if (heartRate != null) {
      map['heartRate'] = heartRate;
    }

    if (cadence != null) {
      map['cadence'] = cadence;
    }

    if (fractionalCadence != null) {
      map['fractionalCadence'] = fractionalCadence;
    }

    if (power != null) {
      map['power'] = power;
    }

    if (strydCadence != null) {
      map['strydCadence'] = strydCadence;
    }

    if (groundTime != null) {
      map['groundTime'] = groundTime;
    }

    if (verticalOscillation != null) {
      map['verticalOscillation'] = verticalOscillation;
    }

    if (formPower != null) {
      map['formPower'] = formPower;
    }

    if (legSpringStiffness != null) {
      map['legSpringStiffness'] = legSpringStiffness;
    }

    if (data != null) {
      map['data'] = data;
    }

    if (activitiesId != null) {
      map['activitiesId'] = forView ? plDbActivity.state : activitiesId;
    }

    if (lapsId != null) {
      map['lapsId'] = forView ? plDbLap.event : lapsId;
    }

// COLLECTIONS (DbEvent)
    if (!forQuery) {
      map['DbIntervals'] = await getDbIntervals().toMapList();
    }
    if (!forQuery) {
      map['DbIntervals'] = await getDbIntervals().toMapList();
    }
// END COLLECTIONS (DbEvent)

    return map;
  }

  /// This method returns Json String [DbEvent]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbEvent]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      event,
      eventType,
      eventGroup,
      timerTrigger,
      timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
      positionLat,
      positionLong,
      distance,
      altitude,
      speed,
      heartRate,
      cadence,
      fractionalCadence,
      power,
      strydCadence,
      groundTime,
      verticalOscillation,
      formPower,
      legSpringStiffness,
      data,
      activitiesId,
      lapsId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      event,
      eventType,
      eventGroup,
      timerTrigger,
      timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
      positionLat,
      positionLong,
      distance,
      altitude,
      speed,
      heartRate,
      cadence,
      fractionalCadence,
      power,
      strydCadence,
      groundTime,
      verticalOscillation,
      formPower,
      legSpringStiffness,
      data,
      activitiesId,
      lapsId
    ];
  }

  static Future<List<DbEvent>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbEvent.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbEvent>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbEvent>[];
    try {
      objList = list
          .map((dbevent) => DbEvent.fromMap(dbevent as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR DbEvent.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbEvent>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbEvent> objList = <DbEvent>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbEvent.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('events.plDbIntervals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervals'))) {
          /*_loadedFields.add('events.plDbIntervals'); */
          obj.plDbIntervals = obj.plDbIntervals ??
              await obj.getDbIntervals().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('events.plDbIntervalsBylastRecordId') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervalsBylastRecordId'))) {
          /*_loadedFields.add('events.plDbIntervalsBylastRecordId'); */
          obj.plDbIntervalsBylastRecordId = obj.plDbIntervalsBylastRecordId ??
              await obj.getDbIntervalsBylastRecordId().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('laps.plDbLap') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbLap'))) {
          /*_loadedFields.add('laps.plDbLap');*/
          obj.plDbLap = obj.plDbLap ??
              await obj.getDbLap(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbEvent by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbEvent if exist, otherwise returns null
  Future<DbEvent> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbEvent obj;
    final data = await _mnDbEvent.getById([id]);
    if (data.length != 0) {
      obj = DbEvent.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('events.plDbIntervals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervals'))) {
          /*_loadedFields.add('events.plDbIntervals'); */
          obj.plDbIntervals = obj.plDbIntervals ??
              await obj.getDbIntervals().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('events.plDbIntervalsBylastRecordId') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervalsBylastRecordId'))) {
          /*_loadedFields.add('events.plDbIntervalsBylastRecordId'); */
          obj.plDbIntervalsBylastRecordId = obj.plDbIntervalsBylastRecordId ??
              await obj.getDbIntervalsBylastRecordId().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('laps.plDbLap') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbLap'))) {
          /*_loadedFields.add('laps.plDbLap');*/
          obj.plDbLap = obj.plDbLap ??
              await obj.getDbLap(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbEvent) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbEvent.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbEvent.update(this);
    }

    return id;
  }

  /// saveAs DbEvent. Returns a new Primary Key value of DbEvent

  /// <returns>Returns a new Primary Key value of DbEvent
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbEvent> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DbEvent> dbevents) async {
    // final results = _mnDbEvent.saveAll('INSERT OR REPLACE INTO events (id,event, eventType, eventGroup, timerTrigger, timeStamp, positionLat, positionLong, distance, altitude, speed, heartRate, cadence, fractionalCadence, power, strydCadence, groundTime, verticalOscillation, formPower, legSpringStiffness, data, activitiesId, lapsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',dbevents);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbevents) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbevents.length; i++) {
      if (dbevents[i].id == null) {
        dbevents[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbEvent.rawInsert(
              'INSERT OR REPLACE INTO events (id,event, eventType, eventGroup, timerTrigger, timeStamp, positionLat, positionLong, distance, altitude, speed, heartRate, cadence, fractionalCadence, power, strydCadence, groundTime, verticalOscillation, formPower, legSpringStiffness, data, activitiesId, lapsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                event,
                eventType,
                eventGroup,
                timerTrigger,
                timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
                positionLat,
                positionLong,
                distance,
                altitude,
                speed,
                heartRate,
                cadence,
                fractionalCadence,
                power,
                strydCadence,
                groundTime,
                verticalOscillation,
                formPower,
                legSpringStiffness,
                data,
                activitiesId,
                lapsId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbEvent id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbEvent id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbEvent Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbEvent>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<DbEvent> dbevents) async {
    final results = await _mnDbEvent.rawInsertAll(
        'INSERT OR REPLACE INTO events (id,event, eventType, eventGroup, timerTrigger, timeStamp, positionLat, positionLong, distance, altitude, speed, heartRate, cadence, fractionalCadence, power, strydCadence, groundTime, verticalOscillation, formPower, legSpringStiffness, data, activitiesId, lapsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbevents);
    return results;
  }

  /// Deletes DbEvent

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbEvent invoked (id=$id)');
    var result = BoolResult();
    {
      result = await DbInterval()
          .select()
          .firstRecordId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbInterval()
          .select()
          .lastRecordId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbEvent
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbEvent.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbEventFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbEventFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbEventFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbEventFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    activitiesId = activitiesId ?? 0;
    lapsId = lapsId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbevent

// region DbEventField
class DbEventField extends SearchCriteria {
  DbEventField(this.dbeventFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbEventFilterBuilder dbeventFB;

  DbEventField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbEventFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.EQuals,
            dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.NotEQuals,
            dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder isNull() {
    dbeventFB._addedBlocks = setCriteria(
        0,
        dbeventFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbeventFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbeventFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks);
      _waitingNot = '';
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
    }
    return dbeventFB;
  }

  DbEventFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbeventFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbeventFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks);
      _waitingNot = '';
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
    }
    return dbeventFB;
  }

  DbEventFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbeventFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbeventFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks);
      _waitingNot = '';
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
    }
    return dbeventFB;
  }

  DbEventFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbeventFB._addedBlocks = setCriteria(
          pFirst,
          dbeventFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbeventFB._addedBlocks = setCriteria(pFirst, dbeventFB.parameters,
            param, SqlSyntax.LessThan, dbeventFB._addedBlocks);
      } else {
        dbeventFB._addedBlocks = setCriteria(pFirst, dbeventFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbeventFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbeventFB._addedBlocks = setCriteria(pLast, dbeventFB.parameters, param,
            SqlSyntax.GreaterThan, dbeventFB._addedBlocks);
      } else {
        dbeventFB._addedBlocks = setCriteria(pLast, dbeventFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbeventFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThan, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.LessThan,
            dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.LessThan,
            dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThan, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder inValues(dynamic pValue) {
    dbeventFB._addedBlocks = setCriteria(
        pValue,
        dbeventFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }
}
// endregion DbEventField

// region DbEventFilterBuilder
class DbEventFilterBuilder extends SearchCriteria {
  DbEventFilterBuilder(DbEvent obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbEvent _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbEventFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbEventFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbEventFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbEventFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbEventFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbEventFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbEventFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbEventFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbEventFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbEventFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbEventFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbEventField setField(DbEventField field, String colName, DbType dbtype) {
    return DbEventField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbEventField _id;
  DbEventField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbEventField _event;
  DbEventField get event {
    return _event = setField(_event, 'event', DbType.text);
  }

  DbEventField _eventType;
  DbEventField get eventType {
    return _eventType = setField(_eventType, 'eventType', DbType.text);
  }

  DbEventField _eventGroup;
  DbEventField get eventGroup {
    return _eventGroup = setField(_eventGroup, 'eventGroup', DbType.integer);
  }

  DbEventField _timerTrigger;
  DbEventField get timerTrigger {
    return _timerTrigger = setField(_timerTrigger, 'timerTrigger', DbType.text);
  }

  DbEventField _timeStamp;
  DbEventField get timeStamp {
    return _timeStamp = setField(_timeStamp, 'timeStamp', DbType.datetime);
  }

  DbEventField _positionLat;
  DbEventField get positionLat {
    return _positionLat = setField(_positionLat, 'positionLat', DbType.real);
  }

  DbEventField _positionLong;
  DbEventField get positionLong {
    return _positionLong = setField(_positionLong, 'positionLong', DbType.real);
  }

  DbEventField _distance;
  DbEventField get distance {
    return _distance = setField(_distance, 'distance', DbType.real);
  }

  DbEventField _altitude;
  DbEventField get altitude {
    return _altitude = setField(_altitude, 'altitude', DbType.real);
  }

  DbEventField _speed;
  DbEventField get speed {
    return _speed = setField(_speed, 'speed', DbType.real);
  }

  DbEventField _heartRate;
  DbEventField get heartRate {
    return _heartRate = setField(_heartRate, 'heartRate', DbType.integer);
  }

  DbEventField _cadence;
  DbEventField get cadence {
    return _cadence = setField(_cadence, 'cadence', DbType.real);
  }

  DbEventField _fractionalCadence;
  DbEventField get fractionalCadence {
    return _fractionalCadence =
        setField(_fractionalCadence, 'fractionalCadence', DbType.real);
  }

  DbEventField _power;
  DbEventField get power {
    return _power = setField(_power, 'power', DbType.integer);
  }

  DbEventField _strydCadence;
  DbEventField get strydCadence {
    return _strydCadence = setField(_strydCadence, 'strydCadence', DbType.real);
  }

  DbEventField _groundTime;
  DbEventField get groundTime {
    return _groundTime = setField(_groundTime, 'groundTime', DbType.real);
  }

  DbEventField _verticalOscillation;
  DbEventField get verticalOscillation {
    return _verticalOscillation =
        setField(_verticalOscillation, 'verticalOscillation', DbType.real);
  }

  DbEventField _formPower;
  DbEventField get formPower {
    return _formPower = setField(_formPower, 'formPower', DbType.integer);
  }

  DbEventField _legSpringStiffness;
  DbEventField get legSpringStiffness {
    return _legSpringStiffness =
        setField(_legSpringStiffness, 'legSpringStiffness', DbType.real);
  }

  DbEventField _data;
  DbEventField get data {
    return _data = setField(_data, 'data', DbType.real);
  }

  DbEventField _activitiesId;
  DbEventField get activitiesId {
    return _activitiesId =
        setField(_activitiesId, 'activitiesId', DbType.integer);
  }

  DbEventField _lapsId;
  DbEventField get lapsId {
    return _lapsId = setField(_lapsId, 'lapsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbEvent._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbEvent> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Delete sub records where in (DbInterval) according to DeleteRule.CASCADE
    final idListDbIntervalBYfirstRecordId = toListPrimaryKeySQL(false);
    final resDbIntervalBYfirstRecordId = await DbInterval()
        .select()
        .where('firstRecordId IN (${idListDbIntervalBYfirstRecordId['sql']})',
            parameterValue: idListDbIntervalBYfirstRecordId['args'])
        .delete(hardDelete);
    if (!resDbIntervalBYfirstRecordId.success) {
      return resDbIntervalBYfirstRecordId;
    }
// Delete sub records where in (DbInterval) according to DeleteRule.CASCADE
    final idListDbIntervalBYlastRecordId = toListPrimaryKeySQL(false);
    final resDbIntervalBYlastRecordId = await DbInterval()
        .select()
        .where('lastRecordId IN (${idListDbIntervalBYlastRecordId['sql']})',
            parameterValue: idListDbIntervalBYlastRecordId['args'])
        .delete(hardDelete);
    if (!resDbIntervalBYlastRecordId.success) {
      return resDbIntervalBYlastRecordId;
    }

    if (DbEvent._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbEvent.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbEvent.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from events ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbEvent.updateBatch(qparams, values);
  }

  /// This method always returns DbEvent Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbEvent>
  Future<DbEvent> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbEvent.toList(qparams);
    final data = await objFuture;
    DbEvent obj;
    if (data.isNotEmpty) {
      obj = DbEvent.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('events.plDbIntervals') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervals'))) {
          /*_loadedFields.add('events.plDbIntervals'); */
          obj.plDbIntervals = obj.plDbIntervals ??
              await obj.getDbIntervals().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('events.plDbIntervalsBylastRecordId') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervalsBylastRecordId'))) {
          /*_loadedFields.add('events.plDbIntervalsBylastRecordId'); */
          obj.plDbIntervalsBylastRecordId = obj.plDbIntervalsBylastRecordId ??
              await obj.getDbIntervalsBylastRecordId().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('laps.plDbLap') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbLap'))) {
          /*_loadedFields.add('laps.plDbLap');*/
          obj.plDbLap = obj.plDbLap ??
              await obj.getDbLap(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbEvent]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbeventCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbeventsFuture = await _obj._mnDbEvent.toList(qparams);
    final int count = dbeventsFuture[0]['CNT'] as int;
    if (dbeventCount != null) {
      dbeventCount(count);
    }
    return count;
  }

  /// This method returns List<DbEvent> [DbEvent]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbEvent>
  Future<List<DbEvent>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbEvent> dbeventsData = await DbEvent.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return dbeventsData;
  }

  /// This method returns Json String [DbEvent]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbEvent]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbEvent]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbEvent.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbEvent]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM events WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbEvent.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbEvent]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbEvent.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbEvent.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbEvent.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbEventFilterBuilder

// region DbEventFields
class DbEventFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fEvent;
  static TableField get event {
    return _fEvent =
        _fEvent ?? SqlSyntax.setField(_fEvent, 'event', DbType.text);
  }

  static TableField _fEventType;
  static TableField get eventType {
    return _fEventType = _fEventType ??
        SqlSyntax.setField(_fEventType, 'eventType', DbType.text);
  }

  static TableField _fEventGroup;
  static TableField get eventGroup {
    return _fEventGroup = _fEventGroup ??
        SqlSyntax.setField(_fEventGroup, 'eventGroup', DbType.integer);
  }

  static TableField _fTimerTrigger;
  static TableField get timerTrigger {
    return _fTimerTrigger = _fTimerTrigger ??
        SqlSyntax.setField(_fTimerTrigger, 'timerTrigger', DbType.text);
  }

  static TableField _fTimeStamp;
  static TableField get timeStamp {
    return _fTimeStamp = _fTimeStamp ??
        SqlSyntax.setField(_fTimeStamp, 'timeStamp', DbType.datetime);
  }

  static TableField _fPositionLat;
  static TableField get positionLat {
    return _fPositionLat = _fPositionLat ??
        SqlSyntax.setField(_fPositionLat, 'positionLat', DbType.real);
  }

  static TableField _fPositionLong;
  static TableField get positionLong {
    return _fPositionLong = _fPositionLong ??
        SqlSyntax.setField(_fPositionLong, 'positionLong', DbType.real);
  }

  static TableField _fDistance;
  static TableField get distance {
    return _fDistance =
        _fDistance ?? SqlSyntax.setField(_fDistance, 'distance', DbType.real);
  }

  static TableField _fAltitude;
  static TableField get altitude {
    return _fAltitude =
        _fAltitude ?? SqlSyntax.setField(_fAltitude, 'altitude', DbType.real);
  }

  static TableField _fSpeed;
  static TableField get speed {
    return _fSpeed =
        _fSpeed ?? SqlSyntax.setField(_fSpeed, 'speed', DbType.real);
  }

  static TableField _fHeartRate;
  static TableField get heartRate {
    return _fHeartRate = _fHeartRate ??
        SqlSyntax.setField(_fHeartRate, 'heartRate', DbType.integer);
  }

  static TableField _fCadence;
  static TableField get cadence {
    return _fCadence =
        _fCadence ?? SqlSyntax.setField(_fCadence, 'cadence', DbType.real);
  }

  static TableField _fFractionalCadence;
  static TableField get fractionalCadence {
    return _fFractionalCadence = _fFractionalCadence ??
        SqlSyntax.setField(
            _fFractionalCadence, 'fractionalCadence', DbType.real);
  }

  static TableField _fPower;
  static TableField get power {
    return _fPower =
        _fPower ?? SqlSyntax.setField(_fPower, 'power', DbType.integer);
  }

  static TableField _fStrydCadence;
  static TableField get strydCadence {
    return _fStrydCadence = _fStrydCadence ??
        SqlSyntax.setField(_fStrydCadence, 'strydCadence', DbType.real);
  }

  static TableField _fGroundTime;
  static TableField get groundTime {
    return _fGroundTime = _fGroundTime ??
        SqlSyntax.setField(_fGroundTime, 'groundTime', DbType.real);
  }

  static TableField _fVerticalOscillation;
  static TableField get verticalOscillation {
    return _fVerticalOscillation = _fVerticalOscillation ??
        SqlSyntax.setField(
            _fVerticalOscillation, 'verticalOscillation', DbType.real);
  }

  static TableField _fFormPower;
  static TableField get formPower {
    return _fFormPower = _fFormPower ??
        SqlSyntax.setField(_fFormPower, 'formPower', DbType.integer);
  }

  static TableField _fLegSpringStiffness;
  static TableField get legSpringStiffness {
    return _fLegSpringStiffness = _fLegSpringStiffness ??
        SqlSyntax.setField(
            _fLegSpringStiffness, 'legSpringStiffness', DbType.real);
  }

  static TableField _fData;
  static TableField get data {
    return _fData = _fData ?? SqlSyntax.setField(_fData, 'data', DbType.real);
  }

  static TableField _fActivitiesId;
  static TableField get activitiesId {
    return _fActivitiesId = _fActivitiesId ??
        SqlSyntax.setField(_fActivitiesId, 'activitiesId', DbType.integer);
  }

  static TableField _fLapsId;
  static TableField get lapsId {
    return _fLapsId =
        _fLapsId ?? SqlSyntax.setField(_fLapsId, 'lapsId', DbType.integer);
  }
}
// endregion DbEventFields

//region DbEventManager
class DbEventManager extends SqfEntityProvider {
  DbEventManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'events';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbEventManager
// region DbLap
class DbLap {
  DbLap(
      {this.id,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.endPositionLat,
      this.endPositionLong,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.event,
      this.eventType,
      this.eventGroup,
      this.sport,
      this.subSport,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.avgSpeedByMeasurements,
      this.avgSpeedBySpeed,
      this.avgSpeedByDistance,
      this.sdevSpeed,
      this.sdevPace,
      this.minSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.maxRunningCadence,
      this.intensity,
      this.lapTrigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.minHeartRate,
      this.sdevHeartRate,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrideRatio,
      this.sdevStrideRatio,
      this.cp,
      this.ftp,
      this.activitiesId}) {
    _setDefaultValues();
  }
  DbLap.withFields(
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.endPositionLat,
      this.endPositionLong,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.event,
      this.eventType,
      this.eventGroup,
      this.sport,
      this.subSport,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.avgSpeedByMeasurements,
      this.avgSpeedBySpeed,
      this.avgSpeedByDistance,
      this.sdevSpeed,
      this.sdevPace,
      this.minSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.maxRunningCadence,
      this.intensity,
      this.lapTrigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.minHeartRate,
      this.sdevHeartRate,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrideRatio,
      this.sdevStrideRatio,
      this.cp,
      this.ftp,
      this.activitiesId) {
    _setDefaultValues();
  }
  DbLap.withId(
      this.id,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.endPositionLat,
      this.endPositionLong,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.event,
      this.eventType,
      this.eventGroup,
      this.sport,
      this.subSport,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.avgSpeedByMeasurements,
      this.avgSpeedBySpeed,
      this.avgSpeedByDistance,
      this.sdevSpeed,
      this.sdevPace,
      this.minSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.maxRunningCadence,
      this.intensity,
      this.lapTrigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.minHeartRate,
      this.sdevHeartRate,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrideRatio,
      this.sdevStrideRatio,
      this.cp,
      this.ftp,
      this.activitiesId) {
    _setDefaultValues();
  }
  DbLap.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['timeStamp'] != null) {
      timeStamp = int.tryParse(o['timeStamp'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['timeStamp'].toString()))
          : DateTime.tryParse(o['timeStamp'].toString());
    }
    if (o['startTime'] != null) {
      startTime = int.tryParse(o['startTime'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['startTime'].toString()))
          : DateTime.tryParse(o['startTime'].toString());
    }
    if (o['startPositionLat'] != null) {
      startPositionLat = double.tryParse(o['startPositionLat'].toString());
    }
    if (o['startPositionLong'] != null) {
      startPositionLong = double.tryParse(o['startPositionLong'].toString());
    }
    if (o['endPositionLat'] != null) {
      endPositionLat = double.tryParse(o['endPositionLat'].toString());
    }
    if (o['endPositionLong'] != null) {
      endPositionLong = double.tryParse(o['endPositionLong'].toString());
    }
    if (o['avgHeartRate'] != null) {
      avgHeartRate = int.tryParse(o['avgHeartRate'].toString());
    }
    if (o['maxHeartRate'] != null) {
      maxHeartRate = int.tryParse(o['maxHeartRate'].toString());
    }
    if (o['avgRunningCadence'] != null) {
      avgRunningCadence = double.tryParse(o['avgRunningCadence'].toString());
    }
    if (o['event'] != null) {
      event = o['event'] as String;
    }
    if (o['eventType'] != null) {
      eventType = o['eventType'] as String;
    }
    if (o['eventGroup'] != null) {
      eventGroup = int.tryParse(o['eventGroup'].toString());
    }
    if (o['sport'] != null) {
      sport = o['sport'] as String;
    }
    if (o['subSport'] != null) {
      subSport = o['subSport'] as String;
    }
    if (o['avgVerticalOscillation'] != null) {
      avgVerticalOscillation =
          double.tryParse(o['avgVerticalOscillation'].toString());
    }
    if (o['totalElapsedTime'] != null) {
      totalElapsedTime = int.tryParse(o['totalElapsedTime'].toString());
    }
    if (o['totalTimerTime'] != null) {
      totalTimerTime = int.tryParse(o['totalTimerTime'].toString());
    }
    if (o['totalDistance'] != null) {
      totalDistance = int.tryParse(o['totalDistance'].toString());
    }
    if (o['totalStrides'] != null) {
      totalStrides = int.tryParse(o['totalStrides'].toString());
    }
    if (o['totalCalories'] != null) {
      totalCalories = int.tryParse(o['totalCalories'].toString());
    }
    if (o['avgSpeed'] != null) {
      avgSpeed = double.tryParse(o['avgSpeed'].toString());
    }
    if (o['avgSpeedByMeasurements'] != null) {
      avgSpeedByMeasurements =
          double.tryParse(o['avgSpeedByMeasurements'].toString());
    }
    if (o['avgSpeedBySpeed'] != null) {
      avgSpeedBySpeed = double.tryParse(o['avgSpeedBySpeed'].toString());
    }
    if (o['avgSpeedByDistance'] != null) {
      avgSpeedByDistance = double.tryParse(o['avgSpeedByDistance'].toString());
    }
    if (o['sdevSpeed'] != null) {
      sdevSpeed = double.tryParse(o['sdevSpeed'].toString());
    }
    if (o['sdevPace'] != null) {
      sdevPace = double.tryParse(o['sdevPace'].toString());
    }
    if (o['minSpeed'] != null) {
      minSpeed = double.tryParse(o['minSpeed'].toString());
    }
    if (o['maxSpeed'] != null) {
      maxSpeed = double.tryParse(o['maxSpeed'].toString());
    }
    if (o['totalAscent'] != null) {
      totalAscent = int.tryParse(o['totalAscent'].toString());
    }
    if (o['totalDescent'] != null) {
      totalDescent = int.tryParse(o['totalDescent'].toString());
    }
    if (o['avgStanceTimePercent'] != null) {
      avgStanceTimePercent =
          double.tryParse(o['avgStanceTimePercent'].toString());
    }
    if (o['avgStanceTime'] != null) {
      avgStanceTime = double.tryParse(o['avgStanceTime'].toString());
    }
    if (o['maxRunningCadence'] != null) {
      maxRunningCadence = int.tryParse(o['maxRunningCadence'].toString());
    }
    if (o['intensity'] != null) {
      intensity = int.tryParse(o['intensity'].toString());
    }
    if (o['lapTrigger'] != null) {
      lapTrigger = o['lapTrigger'] as String;
    }
    if (o['avgTemperature'] != null) {
      avgTemperature = int.tryParse(o['avgTemperature'].toString());
    }
    if (o['maxTemperature'] != null) {
      maxTemperature = int.tryParse(o['maxTemperature'].toString());
    }
    if (o['avgFractionalCadence'] != null) {
      avgFractionalCadence =
          double.tryParse(o['avgFractionalCadence'].toString());
    }
    if (o['maxFractionalCadence'] != null) {
      maxFractionalCadence =
          double.tryParse(o['maxFractionalCadence'].toString());
    }
    if (o['totalFractionalCycles'] != null) {
      totalFractionalCycles =
          double.tryParse(o['totalFractionalCycles'].toString());
    }
    if (o['avgPower'] != null) {
      avgPower = double.tryParse(o['avgPower'].toString());
    }
    if (o['minPower'] != null) {
      minPower = int.tryParse(o['minPower'].toString());
    }
    if (o['maxPower'] != null) {
      maxPower = int.tryParse(o['maxPower'].toString());
    }
    if (o['sdevPower'] != null) {
      sdevPower = double.tryParse(o['sdevPower'].toString());
    }
    if (o['minHeartRate'] != null) {
      minHeartRate = int.tryParse(o['minHeartRate'].toString());
    }
    if (o['sdevHeartRate'] != null) {
      sdevHeartRate = double.tryParse(o['sdevHeartRate'].toString());
    }
    if (o['avgGroundTime'] != null) {
      avgGroundTime = double.tryParse(o['avgGroundTime'].toString());
    }
    if (o['sdevGroundTime'] != null) {
      sdevGroundTime = double.tryParse(o['sdevGroundTime'].toString());
    }
    if (o['avgLegSpringStiffness'] != null) {
      avgLegSpringStiffness =
          double.tryParse(o['avgLegSpringStiffness'].toString());
    }
    if (o['sdevLegSpringStiffness'] != null) {
      sdevLegSpringStiffness =
          double.tryParse(o['sdevLegSpringStiffness'].toString());
    }
    if (o['avgFormPower'] != null) {
      avgFormPower = double.tryParse(o['avgFormPower'].toString());
    }
    if (o['sdevFormPower'] != null) {
      sdevFormPower = double.tryParse(o['sdevFormPower'].toString());
    }
    if (o['avgStrydCadence'] != null) {
      avgStrydCadence = double.tryParse(o['avgStrydCadence'].toString());
    }
    if (o['sdevStrydCadence'] != null) {
      sdevStrydCadence = double.tryParse(o['sdevStrydCadence'].toString());
    }
    if (o['sdevVerticalOscillation'] != null) {
      sdevVerticalOscillation =
          double.tryParse(o['sdevVerticalOscillation'].toString());
    }
    if (o['avgPowerRatio'] != null) {
      avgPowerRatio = double.tryParse(o['avgPowerRatio'].toString());
    }
    if (o['sdevPowerRatio'] != null) {
      sdevPowerRatio = double.tryParse(o['sdevPowerRatio'].toString());
    }
    if (o['avgStrideRatio'] != null) {
      avgStrideRatio = double.tryParse(o['avgStrideRatio'].toString());
    }
    if (o['sdevStrideRatio'] != null) {
      sdevStrideRatio = double.tryParse(o['sdevStrideRatio'].toString());
    }
    if (o['cp'] != null) {
      cp = double.tryParse(o['cp'].toString());
    }
    if (o['ftp'] != null) {
      ftp = double.tryParse(o['ftp'].toString());
    }
    activitiesId = int.tryParse(o['activitiesId'].toString());

    // RELATIONSHIPS FromMAP
    plDbActivity = o['dbActivity'] != null
        ? DbActivity.fromMap(o['dbActivity'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbLap)
  int id;
  DateTime timeStamp;
  DateTime startTime;
  double startPositionLat;
  double startPositionLong;
  double endPositionLat;
  double endPositionLong;
  int avgHeartRate;
  int maxHeartRate;
  double avgRunningCadence;
  String event;
  String eventType;
  int eventGroup;
  String sport;
  String subSport;
  double avgVerticalOscillation;
  int totalElapsedTime;
  int totalTimerTime;
  int totalDistance;
  int totalStrides;
  int totalCalories;
  double avgSpeed;
  double avgSpeedByMeasurements;
  double avgSpeedBySpeed;
  double avgSpeedByDistance;
  double sdevSpeed;
  double sdevPace;
  double minSpeed;
  double maxSpeed;
  int totalAscent;
  int totalDescent;
  double avgStanceTimePercent;
  double avgStanceTime;
  int maxRunningCadence;
  int intensity;
  String lapTrigger;
  int avgTemperature;
  int maxTemperature;
  double avgFractionalCadence;
  double maxFractionalCadence;
  double totalFractionalCycles;
  double avgPower;
  int minPower;
  int maxPower;
  double sdevPower;
  int minHeartRate;
  double sdevHeartRate;
  double avgGroundTime;
  double sdevGroundTime;
  double avgLegSpringStiffness;
  double sdevLegSpringStiffness;
  double avgFormPower;
  double sdevFormPower;
  double avgStrydCadence;
  double sdevStrydCadence;
  double sdevVerticalOscillation;
  double avgPowerRatio;
  double sdevPowerRatio;
  double avgStrideRatio;
  double sdevStrideRatio;
  double cp;
  double ftp;
  int activitiesId;

  BoolResult saveResult;
  // end FIELDS (DbLap)

// RELATIONSHIPS (DbLap)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbActivity', 'plField2'..]) or so on..
  DbActivity plDbActivity;

  /// get DbActivity By ActivitiesId
  Future<DbActivity> getDbActivity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbActivity().getById(activitiesId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbLap)

// COLLECTIONS & VIRTUALS (DbLap)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbEvents', 'plField2'..]) or so on..
  List<DbEvent> plDbEvents;

  /// get DbEvent(s) filtered by id=lapsId
  DbEventFilterBuilder getDbEvents(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbEvent()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .lapsId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbLapTaggings', 'plField2'..]) or so on..
  List<DbLapTagging> plDbLapTaggings;

  /// get DbLapTagging(s) filtered by id=lapsId
  DbLapTaggingFilterBuilder getDbLapTaggings(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbLapTagging()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .lapsId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (DbLap)

  static const bool _softDeleteActivated = false;
  DbLapManager __mnDbLap;

  DbLapManager get _mnDbLap {
    return __mnDbLap = __mnDbLap ?? DbLapManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (endPositionLat != null) {
      map['endPositionLat'] = endPositionLat;
    }

    if (endPositionLong != null) {
      map['endPositionLong'] = endPositionLong;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (avgSpeedByMeasurements != null) {
      map['avgSpeedByMeasurements'] = avgSpeedByMeasurements;
    }

    if (avgSpeedBySpeed != null) {
      map['avgSpeedBySpeed'] = avgSpeedBySpeed;
    }

    if (avgSpeedByDistance != null) {
      map['avgSpeedByDistance'] = avgSpeedByDistance;
    }

    if (sdevSpeed != null) {
      map['sdevSpeed'] = sdevSpeed;
    }

    if (sdevPace != null) {
      map['sdevPace'] = sdevPace;
    }

    if (minSpeed != null) {
      map['minSpeed'] = minSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (intensity != null) {
      map['intensity'] = intensity;
    }

    if (lapTrigger != null) {
      map['lapTrigger'] = lapTrigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (minHeartRate != null) {
      map['minHeartRate'] = minHeartRate;
    }

    if (sdevHeartRate != null) {
      map['sdevHeartRate'] = sdevHeartRate;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (avgPowerRatio != null) {
      map['avgPowerRatio'] = avgPowerRatio;
    }

    if (sdevPowerRatio != null) {
      map['sdevPowerRatio'] = sdevPowerRatio;
    }

    if (avgStrideRatio != null) {
      map['avgStrideRatio'] = avgStrideRatio;
    }

    if (sdevStrideRatio != null) {
      map['sdevStrideRatio'] = sdevStrideRatio;
    }

    if (cp != null) {
      map['cp'] = cp;
    }

    if (ftp != null) {
      map['ftp'] = ftp;
    }

    if (activitiesId != null) {
      map['activitiesId'] = forView ? plDbActivity.state : activitiesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (endPositionLat != null) {
      map['endPositionLat'] = endPositionLat;
    }

    if (endPositionLong != null) {
      map['endPositionLong'] = endPositionLong;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (avgSpeedByMeasurements != null) {
      map['avgSpeedByMeasurements'] = avgSpeedByMeasurements;
    }

    if (avgSpeedBySpeed != null) {
      map['avgSpeedBySpeed'] = avgSpeedBySpeed;
    }

    if (avgSpeedByDistance != null) {
      map['avgSpeedByDistance'] = avgSpeedByDistance;
    }

    if (sdevSpeed != null) {
      map['sdevSpeed'] = sdevSpeed;
    }

    if (sdevPace != null) {
      map['sdevPace'] = sdevPace;
    }

    if (minSpeed != null) {
      map['minSpeed'] = minSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (intensity != null) {
      map['intensity'] = intensity;
    }

    if (lapTrigger != null) {
      map['lapTrigger'] = lapTrigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (minHeartRate != null) {
      map['minHeartRate'] = minHeartRate;
    }

    if (sdevHeartRate != null) {
      map['sdevHeartRate'] = sdevHeartRate;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (avgPowerRatio != null) {
      map['avgPowerRatio'] = avgPowerRatio;
    }

    if (sdevPowerRatio != null) {
      map['sdevPowerRatio'] = sdevPowerRatio;
    }

    if (avgStrideRatio != null) {
      map['avgStrideRatio'] = avgStrideRatio;
    }

    if (sdevStrideRatio != null) {
      map['sdevStrideRatio'] = sdevStrideRatio;
    }

    if (cp != null) {
      map['cp'] = cp;
    }

    if (ftp != null) {
      map['ftp'] = ftp;
    }

    if (activitiesId != null) {
      map['activitiesId'] = forView ? plDbActivity.state : activitiesId;
    }

// COLLECTIONS (DbLap)
    if (!forQuery) {
      map['DbEvents'] = await getDbEvents().toMapList();
    }
    if (!forQuery) {
      map['DbLapTaggings'] = await getDbLapTaggings().toMapList();
    }
// END COLLECTIONS (DbLap)

    return map;
  }

  /// This method returns Json String [DbLap]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbLap]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      timeStamp,
      startTime != null ? startTime.millisecondsSinceEpoch : null,
      startPositionLat,
      startPositionLong,
      endPositionLat,
      endPositionLong,
      avgHeartRate,
      maxHeartRate,
      avgRunningCadence,
      event,
      eventType,
      eventGroup,
      sport,
      subSport,
      avgVerticalOscillation,
      totalElapsedTime,
      totalTimerTime,
      totalDistance,
      totalStrides,
      totalCalories,
      avgSpeed,
      avgSpeedByMeasurements,
      avgSpeedBySpeed,
      avgSpeedByDistance,
      sdevSpeed,
      sdevPace,
      minSpeed,
      maxSpeed,
      totalAscent,
      totalDescent,
      avgStanceTimePercent,
      avgStanceTime,
      maxRunningCadence,
      intensity,
      lapTrigger,
      avgTemperature,
      maxTemperature,
      avgFractionalCadence,
      maxFractionalCadence,
      totalFractionalCycles,
      avgPower,
      minPower,
      maxPower,
      sdevPower,
      minHeartRate,
      sdevHeartRate,
      avgGroundTime,
      sdevGroundTime,
      avgLegSpringStiffness,
      sdevLegSpringStiffness,
      avgFormPower,
      sdevFormPower,
      avgStrydCadence,
      sdevStrydCadence,
      sdevVerticalOscillation,
      avgPowerRatio,
      sdevPowerRatio,
      avgStrideRatio,
      sdevStrideRatio,
      cp,
      ftp,
      activitiesId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      timeStamp,
      startTime != null ? startTime.millisecondsSinceEpoch : null,
      startPositionLat,
      startPositionLong,
      endPositionLat,
      endPositionLong,
      avgHeartRate,
      maxHeartRate,
      avgRunningCadence,
      event,
      eventType,
      eventGroup,
      sport,
      subSport,
      avgVerticalOscillation,
      totalElapsedTime,
      totalTimerTime,
      totalDistance,
      totalStrides,
      totalCalories,
      avgSpeed,
      avgSpeedByMeasurements,
      avgSpeedBySpeed,
      avgSpeedByDistance,
      sdevSpeed,
      sdevPace,
      minSpeed,
      maxSpeed,
      totalAscent,
      totalDescent,
      avgStanceTimePercent,
      avgStanceTime,
      maxRunningCadence,
      intensity,
      lapTrigger,
      avgTemperature,
      maxTemperature,
      avgFractionalCadence,
      maxFractionalCadence,
      totalFractionalCycles,
      avgPower,
      minPower,
      maxPower,
      sdevPower,
      minHeartRate,
      sdevHeartRate,
      avgGroundTime,
      sdevGroundTime,
      avgLegSpringStiffness,
      sdevLegSpringStiffness,
      avgFormPower,
      sdevFormPower,
      avgStrydCadence,
      sdevStrydCadence,
      sdevVerticalOscillation,
      avgPowerRatio,
      sdevPowerRatio,
      avgStrideRatio,
      sdevStrideRatio,
      cp,
      ftp,
      activitiesId
    ];
  }

  static Future<List<DbLap>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR DbLap.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbLap>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbLap>[];
    try {
      objList = list
          .map((dblap) => DbLap.fromMap(dblap as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR DbLap.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbLap>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbLap> objList = <DbLap>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbLap.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('laps.plDbEvents') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbEvents'))) {
          /*_loadedFields.add('laps.plDbEvents'); */
          obj.plDbEvents = obj.plDbEvents ??
              await obj.getDbEvents().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('laps.plDbLapTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbLapTaggings'))) {
          /*_loadedFields.add('laps.plDbLapTaggings'); */
          obj.plDbLapTaggings = obj.plDbLapTaggings ??
              await obj.getDbLapTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbLap by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbLap if exist, otherwise returns null
  Future<DbLap> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbLap obj;
    final data = await _mnDbLap.getById([id]);
    if (data.length != 0) {
      obj = DbLap.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('laps.plDbEvents') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbEvents'))) {
          /*_loadedFields.add('laps.plDbEvents'); */
          obj.plDbEvents = obj.plDbEvents ??
              await obj.getDbEvents().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('laps.plDbLapTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbLapTaggings'))) {
          /*_loadedFields.add('laps.plDbLapTaggings'); */
          obj.plDbLapTaggings = obj.plDbLapTaggings ??
              await obj.getDbLapTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbLap) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbLap.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbLap.update(this);
    }

    return id;
  }

  /// saveAs DbLap. Returns a new Primary Key value of DbLap

  /// <returns>Returns a new Primary Key value of DbLap
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbLap> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DbLap> dblaps) async {
    // final results = _mnDbLap.saveAll('INSERT OR REPLACE INTO laps (id,timeStamp, startTime, startPositionLat, startPositionLong, endPositionLat, endPositionLong, avgHeartRate, maxHeartRate, avgRunningCadence, event, eventType, eventGroup, sport, subSport, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalDistance, totalStrides, totalCalories, avgSpeed, avgSpeedByMeasurements, avgSpeedBySpeed, avgSpeedByDistance, sdevSpeed, sdevPace, minSpeed, maxSpeed, totalAscent, totalDescent, avgStanceTimePercent, avgStanceTime, maxRunningCadence, intensity, lapTrigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgPower, minPower, maxPower, sdevPower, minHeartRate, sdevHeartRate, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, avgPowerRatio, sdevPowerRatio, avgStrideRatio, sdevStrideRatio, cp, ftp, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',dblaps);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dblaps) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dblaps.length; i++) {
      if (dblaps[i].id == null) {
        dblaps[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbLap.rawInsert(
              'INSERT OR REPLACE INTO laps (id,timeStamp, startTime, startPositionLat, startPositionLong, endPositionLat, endPositionLong, avgHeartRate, maxHeartRate, avgRunningCadence, event, eventType, eventGroup, sport, subSport, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalDistance, totalStrides, totalCalories, avgSpeed, avgSpeedByMeasurements, avgSpeedBySpeed, avgSpeedByDistance, sdevSpeed, sdevPace, minSpeed, maxSpeed, totalAscent, totalDescent, avgStanceTimePercent, avgStanceTime, maxRunningCadence, intensity, lapTrigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgPower, minPower, maxPower, sdevPower, minHeartRate, sdevHeartRate, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, avgPowerRatio, sdevPowerRatio, avgStrideRatio, sdevStrideRatio, cp, ftp, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                timeStamp,
                startTime != null ? startTime.millisecondsSinceEpoch : null,
                startPositionLat,
                startPositionLong,
                endPositionLat,
                endPositionLong,
                avgHeartRate,
                maxHeartRate,
                avgRunningCadence,
                event,
                eventType,
                eventGroup,
                sport,
                subSport,
                avgVerticalOscillation,
                totalElapsedTime,
                totalTimerTime,
                totalDistance,
                totalStrides,
                totalCalories,
                avgSpeed,
                avgSpeedByMeasurements,
                avgSpeedBySpeed,
                avgSpeedByDistance,
                sdevSpeed,
                sdevPace,
                minSpeed,
                maxSpeed,
                totalAscent,
                totalDescent,
                avgStanceTimePercent,
                avgStanceTime,
                maxRunningCadence,
                intensity,
                lapTrigger,
                avgTemperature,
                maxTemperature,
                avgFractionalCadence,
                maxFractionalCadence,
                totalFractionalCycles,
                avgPower,
                minPower,
                maxPower,
                sdevPower,
                minHeartRate,
                sdevHeartRate,
                avgGroundTime,
                sdevGroundTime,
                avgLegSpringStiffness,
                sdevLegSpringStiffness,
                avgFormPower,
                sdevFormPower,
                avgStrydCadence,
                sdevStrydCadence,
                sdevVerticalOscillation,
                avgPowerRatio,
                sdevPowerRatio,
                avgStrideRatio,
                sdevStrideRatio,
                cp,
                ftp,
                activitiesId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true, successMessage: 'DbLap id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbLap id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbLap Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbLap>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<DbLap> dblaps) async {
    final results = await _mnDbLap.rawInsertAll(
        'INSERT OR REPLACE INTO laps (id,timeStamp, startTime, startPositionLat, startPositionLong, endPositionLat, endPositionLong, avgHeartRate, maxHeartRate, avgRunningCadence, event, eventType, eventGroup, sport, subSport, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalDistance, totalStrides, totalCalories, avgSpeed, avgSpeedByMeasurements, avgSpeedBySpeed, avgSpeedByDistance, sdevSpeed, sdevPace, minSpeed, maxSpeed, totalAscent, totalDescent, avgStanceTimePercent, avgStanceTime, maxRunningCadence, intensity, lapTrigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgPower, minPower, maxPower, sdevPower, minHeartRate, sdevHeartRate, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, avgPowerRatio, sdevPowerRatio, avgStrideRatio, sdevStrideRatio, cp, ftp, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dblaps);
    return results;
  }

  /// Deletes DbLap

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbLap invoked (id=$id)');
    var result = BoolResult();
    {
      result =
          await DbEvent().select().lapsId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbLapTagging()
          .select()
          .lapsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbLap
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbLap.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbLapFilterBuilder select({List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLapFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbLapFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLapFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    activitiesId = activitiesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dblap

// region DbLapField
class DbLapField extends SearchCriteria {
  DbLapField(this.dblapFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbLapFilterBuilder dblapFB;

  DbLapField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbLapFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.EQuals,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.NotEQuals,
            dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.EQualsOrNull,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder isNull() {
    dblapFB._addedBlocks = setCriteria(
        0,
        dblapFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dblapFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dblapFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks);
      _waitingNot = '';
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
    }
    return dblapFB;
  }

  DbLapFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dblapFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dblapFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks);
      _waitingNot = '';
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
    }
    return dblapFB;
  }

  DbLapFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dblapFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dblapFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks);
      _waitingNot = '';
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
    }
    return dblapFB;
  }

  DbLapFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dblapFB._addedBlocks = setCriteria(
          pFirst,
          dblapFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dblapFB._addedBlocks = setCriteria(pFirst, dblapFB.parameters, param,
            SqlSyntax.LessThan, dblapFB._addedBlocks);
      } else {
        dblapFB._addedBlocks = setCriteria(pFirst, dblapFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblapFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dblapFB._addedBlocks = setCriteria(pLast, dblapFB.parameters, param,
            SqlSyntax.GreaterThan, dblapFB._addedBlocks);
      } else {
        dblapFB._addedBlocks = setCriteria(pLast, dblapFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblapFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.GreaterThan,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.LessThan,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.LessThan,
            dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.GreaterThan,
            dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder inValues(dynamic pValue) {
    dblapFB._addedBlocks = setCriteria(
        pValue,
        dblapFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }
}
// endregion DbLapField

// region DbLapFilterBuilder
class DbLapFilterBuilder extends SearchCriteria {
  DbLapFilterBuilder(DbLap obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbLap _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbLapFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbLapFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbLapFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbLapFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbLapFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbLapFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbLapFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbLapFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbLapFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbLapFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbLapFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbLapField setField(DbLapField field, String colName, DbType dbtype) {
    return DbLapField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbLapField _id;
  DbLapField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbLapField _timeStamp;
  DbLapField get timeStamp {
    return _timeStamp = setField(_timeStamp, 'timeStamp', DbType.datetime);
  }

  DbLapField _startTime;
  DbLapField get startTime {
    return _startTime = setField(_startTime, 'startTime', DbType.datetime);
  }

  DbLapField _startPositionLat;
  DbLapField get startPositionLat {
    return _startPositionLat =
        setField(_startPositionLat, 'startPositionLat', DbType.real);
  }

  DbLapField _startPositionLong;
  DbLapField get startPositionLong {
    return _startPositionLong =
        setField(_startPositionLong, 'startPositionLong', DbType.real);
  }

  DbLapField _endPositionLat;
  DbLapField get endPositionLat {
    return _endPositionLat =
        setField(_endPositionLat, 'endPositionLat', DbType.real);
  }

  DbLapField _endPositionLong;
  DbLapField get endPositionLong {
    return _endPositionLong =
        setField(_endPositionLong, 'endPositionLong', DbType.real);
  }

  DbLapField _avgHeartRate;
  DbLapField get avgHeartRate {
    return _avgHeartRate =
        setField(_avgHeartRate, 'avgHeartRate', DbType.integer);
  }

  DbLapField _maxHeartRate;
  DbLapField get maxHeartRate {
    return _maxHeartRate =
        setField(_maxHeartRate, 'maxHeartRate', DbType.integer);
  }

  DbLapField _avgRunningCadence;
  DbLapField get avgRunningCadence {
    return _avgRunningCadence =
        setField(_avgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  DbLapField _event;
  DbLapField get event {
    return _event = setField(_event, 'event', DbType.text);
  }

  DbLapField _eventType;
  DbLapField get eventType {
    return _eventType = setField(_eventType, 'eventType', DbType.text);
  }

  DbLapField _eventGroup;
  DbLapField get eventGroup {
    return _eventGroup = setField(_eventGroup, 'eventGroup', DbType.integer);
  }

  DbLapField _sport;
  DbLapField get sport {
    return _sport = setField(_sport, 'sport', DbType.text);
  }

  DbLapField _subSport;
  DbLapField get subSport {
    return _subSport = setField(_subSport, 'subSport', DbType.text);
  }

  DbLapField _avgVerticalOscillation;
  DbLapField get avgVerticalOscillation {
    return _avgVerticalOscillation = setField(
        _avgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  DbLapField _totalElapsedTime;
  DbLapField get totalElapsedTime {
    return _totalElapsedTime =
        setField(_totalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  DbLapField _totalTimerTime;
  DbLapField get totalTimerTime {
    return _totalTimerTime =
        setField(_totalTimerTime, 'totalTimerTime', DbType.integer);
  }

  DbLapField _totalDistance;
  DbLapField get totalDistance {
    return _totalDistance =
        setField(_totalDistance, 'totalDistance', DbType.integer);
  }

  DbLapField _totalStrides;
  DbLapField get totalStrides {
    return _totalStrides =
        setField(_totalStrides, 'totalStrides', DbType.integer);
  }

  DbLapField _totalCalories;
  DbLapField get totalCalories {
    return _totalCalories =
        setField(_totalCalories, 'totalCalories', DbType.integer);
  }

  DbLapField _avgSpeed;
  DbLapField get avgSpeed {
    return _avgSpeed = setField(_avgSpeed, 'avgSpeed', DbType.real);
  }

  DbLapField _avgSpeedByMeasurements;
  DbLapField get avgSpeedByMeasurements {
    return _avgSpeedByMeasurements = setField(
        _avgSpeedByMeasurements, 'avgSpeedByMeasurements', DbType.real);
  }

  DbLapField _avgSpeedBySpeed;
  DbLapField get avgSpeedBySpeed {
    return _avgSpeedBySpeed =
        setField(_avgSpeedBySpeed, 'avgSpeedBySpeed', DbType.real);
  }

  DbLapField _avgSpeedByDistance;
  DbLapField get avgSpeedByDistance {
    return _avgSpeedByDistance =
        setField(_avgSpeedByDistance, 'avgSpeedByDistance', DbType.real);
  }

  DbLapField _sdevSpeed;
  DbLapField get sdevSpeed {
    return _sdevSpeed = setField(_sdevSpeed, 'sdevSpeed', DbType.real);
  }

  DbLapField _sdevPace;
  DbLapField get sdevPace {
    return _sdevPace = setField(_sdevPace, 'sdevPace', DbType.real);
  }

  DbLapField _minSpeed;
  DbLapField get minSpeed {
    return _minSpeed = setField(_minSpeed, 'minSpeed', DbType.real);
  }

  DbLapField _maxSpeed;
  DbLapField get maxSpeed {
    return _maxSpeed = setField(_maxSpeed, 'maxSpeed', DbType.real);
  }

  DbLapField _totalAscent;
  DbLapField get totalAscent {
    return _totalAscent = setField(_totalAscent, 'totalAscent', DbType.integer);
  }

  DbLapField _totalDescent;
  DbLapField get totalDescent {
    return _totalDescent =
        setField(_totalDescent, 'totalDescent', DbType.integer);
  }

  DbLapField _avgStanceTimePercent;
  DbLapField get avgStanceTimePercent {
    return _avgStanceTimePercent =
        setField(_avgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  DbLapField _avgStanceTime;
  DbLapField get avgStanceTime {
    return _avgStanceTime =
        setField(_avgStanceTime, 'avgStanceTime', DbType.real);
  }

  DbLapField _maxRunningCadence;
  DbLapField get maxRunningCadence {
    return _maxRunningCadence =
        setField(_maxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  DbLapField _intensity;
  DbLapField get intensity {
    return _intensity = setField(_intensity, 'intensity', DbType.integer);
  }

  DbLapField _lapTrigger;
  DbLapField get lapTrigger {
    return _lapTrigger = setField(_lapTrigger, 'lapTrigger', DbType.text);
  }

  DbLapField _avgTemperature;
  DbLapField get avgTemperature {
    return _avgTemperature =
        setField(_avgTemperature, 'avgTemperature', DbType.integer);
  }

  DbLapField _maxTemperature;
  DbLapField get maxTemperature {
    return _maxTemperature =
        setField(_maxTemperature, 'maxTemperature', DbType.integer);
  }

  DbLapField _avgFractionalCadence;
  DbLapField get avgFractionalCadence {
    return _avgFractionalCadence =
        setField(_avgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  DbLapField _maxFractionalCadence;
  DbLapField get maxFractionalCadence {
    return _maxFractionalCadence =
        setField(_maxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  DbLapField _totalFractionalCycles;
  DbLapField get totalFractionalCycles {
    return _totalFractionalCycles =
        setField(_totalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  DbLapField _avgPower;
  DbLapField get avgPower {
    return _avgPower = setField(_avgPower, 'avgPower', DbType.real);
  }

  DbLapField _minPower;
  DbLapField get minPower {
    return _minPower = setField(_minPower, 'minPower', DbType.integer);
  }

  DbLapField _maxPower;
  DbLapField get maxPower {
    return _maxPower = setField(_maxPower, 'maxPower', DbType.integer);
  }

  DbLapField _sdevPower;
  DbLapField get sdevPower {
    return _sdevPower = setField(_sdevPower, 'sdevPower', DbType.real);
  }

  DbLapField _minHeartRate;
  DbLapField get minHeartRate {
    return _minHeartRate =
        setField(_minHeartRate, 'minHeartRate', DbType.integer);
  }

  DbLapField _sdevHeartRate;
  DbLapField get sdevHeartRate {
    return _sdevHeartRate =
        setField(_sdevHeartRate, 'sdevHeartRate', DbType.real);
  }

  DbLapField _avgGroundTime;
  DbLapField get avgGroundTime {
    return _avgGroundTime =
        setField(_avgGroundTime, 'avgGroundTime', DbType.real);
  }

  DbLapField _sdevGroundTime;
  DbLapField get sdevGroundTime {
    return _sdevGroundTime =
        setField(_sdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  DbLapField _avgLegSpringStiffness;
  DbLapField get avgLegSpringStiffness {
    return _avgLegSpringStiffness =
        setField(_avgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  DbLapField _sdevLegSpringStiffness;
  DbLapField get sdevLegSpringStiffness {
    return _sdevLegSpringStiffness = setField(
        _sdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  DbLapField _avgFormPower;
  DbLapField get avgFormPower {
    return _avgFormPower = setField(_avgFormPower, 'avgFormPower', DbType.real);
  }

  DbLapField _sdevFormPower;
  DbLapField get sdevFormPower {
    return _sdevFormPower =
        setField(_sdevFormPower, 'sdevFormPower', DbType.real);
  }

  DbLapField _avgStrydCadence;
  DbLapField get avgStrydCadence {
    return _avgStrydCadence =
        setField(_avgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  DbLapField _sdevStrydCadence;
  DbLapField get sdevStrydCadence {
    return _sdevStrydCadence =
        setField(_sdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  DbLapField _sdevVerticalOscillation;
  DbLapField get sdevVerticalOscillation {
    return _sdevVerticalOscillation = setField(
        _sdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  DbLapField _avgPowerRatio;
  DbLapField get avgPowerRatio {
    return _avgPowerRatio =
        setField(_avgPowerRatio, 'avgPowerRatio', DbType.real);
  }

  DbLapField _sdevPowerRatio;
  DbLapField get sdevPowerRatio {
    return _sdevPowerRatio =
        setField(_sdevPowerRatio, 'sdevPowerRatio', DbType.real);
  }

  DbLapField _avgStrideRatio;
  DbLapField get avgStrideRatio {
    return _avgStrideRatio =
        setField(_avgStrideRatio, 'avgStrideRatio', DbType.real);
  }

  DbLapField _sdevStrideRatio;
  DbLapField get sdevStrideRatio {
    return _sdevStrideRatio =
        setField(_sdevStrideRatio, 'sdevStrideRatio', DbType.real);
  }

  DbLapField _cp;
  DbLapField get cp {
    return _cp = setField(_cp, 'cp', DbType.real);
  }

  DbLapField _ftp;
  DbLapField get ftp {
    return _ftp = setField(_ftp, 'ftp', DbType.real);
  }

  DbLapField _activitiesId;
  DbLapField get activitiesId {
    return _activitiesId =
        setField(_activitiesId, 'activitiesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbLap._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbLap> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Delete sub records where in (DbEvent) according to DeleteRule.CASCADE
    final idListDbEventBYlapsId = toListPrimaryKeySQL(false);
    final resDbEventBYlapsId = await DbEvent()
        .select()
        .where('lapsId IN (${idListDbEventBYlapsId['sql']})',
            parameterValue: idListDbEventBYlapsId['args'])
        .delete(hardDelete);
    if (!resDbEventBYlapsId.success) {
      return resDbEventBYlapsId;
    }
// Delete sub records where in (DbLapTagging) according to DeleteRule.CASCADE
    final idListDbLapTaggingBYlapsId = toListPrimaryKeySQL(false);
    final resDbLapTaggingBYlapsId = await DbLapTagging()
        .select()
        .where('lapsId IN (${idListDbLapTaggingBYlapsId['sql']})',
            parameterValue: idListDbLapTaggingBYlapsId['args'])
        .delete(hardDelete);
    if (!resDbLapTaggingBYlapsId.success) {
      return resDbLapTaggingBYlapsId;
    }

    if (DbLap._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbLap.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbLap.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from laps ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbLap.updateBatch(qparams, values);
  }

  /// This method always returns DbLap Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbLap>
  Future<DbLap> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbLap.toList(qparams);
    final data = await objFuture;
    DbLap obj;
    if (data.isNotEmpty) {
      obj = DbLap.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('laps.plDbEvents') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbEvents'))) {
          /*_loadedFields.add('laps.plDbEvents'); */
          obj.plDbEvents = obj.plDbEvents ??
              await obj.getDbEvents().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('laps.plDbLapTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbLapTaggings'))) {
          /*_loadedFields.add('laps.plDbLapTaggings'); */
          obj.plDbLapTaggings = obj.plDbLapTaggings ??
              await obj.getDbLapTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbLap]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dblapCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dblapsFuture = await _obj._mnDbLap.toList(qparams);
    final int count = dblapsFuture[0]['CNT'] as int;
    if (dblapCount != null) {
      dblapCount(count);
    }
    return count;
  }

  /// This method returns List<DbLap> [DbLap]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbLap>
  Future<List<DbLap>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbLap> dblapsData = await DbLap.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return dblapsData;
  }

  /// This method returns Json String [DbLap]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbLap]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbLap]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbLap.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbLap]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM laps WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbLap.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbLap]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbLap.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbLap.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbLap.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbLapFilterBuilder

// region DbLapFields
class DbLapFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fTimeStamp;
  static TableField get timeStamp {
    return _fTimeStamp = _fTimeStamp ??
        SqlSyntax.setField(_fTimeStamp, 'timeStamp', DbType.datetime);
  }

  static TableField _fStartTime;
  static TableField get startTime {
    return _fStartTime = _fStartTime ??
        SqlSyntax.setField(_fStartTime, 'startTime', DbType.datetime);
  }

  static TableField _fStartPositionLat;
  static TableField get startPositionLat {
    return _fStartPositionLat = _fStartPositionLat ??
        SqlSyntax.setField(_fStartPositionLat, 'startPositionLat', DbType.real);
  }

  static TableField _fStartPositionLong;
  static TableField get startPositionLong {
    return _fStartPositionLong = _fStartPositionLong ??
        SqlSyntax.setField(
            _fStartPositionLong, 'startPositionLong', DbType.real);
  }

  static TableField _fEndPositionLat;
  static TableField get endPositionLat {
    return _fEndPositionLat = _fEndPositionLat ??
        SqlSyntax.setField(_fEndPositionLat, 'endPositionLat', DbType.real);
  }

  static TableField _fEndPositionLong;
  static TableField get endPositionLong {
    return _fEndPositionLong = _fEndPositionLong ??
        SqlSyntax.setField(_fEndPositionLong, 'endPositionLong', DbType.real);
  }

  static TableField _fAvgHeartRate;
  static TableField get avgHeartRate {
    return _fAvgHeartRate = _fAvgHeartRate ??
        SqlSyntax.setField(_fAvgHeartRate, 'avgHeartRate', DbType.integer);
  }

  static TableField _fMaxHeartRate;
  static TableField get maxHeartRate {
    return _fMaxHeartRate = _fMaxHeartRate ??
        SqlSyntax.setField(_fMaxHeartRate, 'maxHeartRate', DbType.integer);
  }

  static TableField _fAvgRunningCadence;
  static TableField get avgRunningCadence {
    return _fAvgRunningCadence = _fAvgRunningCadence ??
        SqlSyntax.setField(
            _fAvgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  static TableField _fEvent;
  static TableField get event {
    return _fEvent =
        _fEvent ?? SqlSyntax.setField(_fEvent, 'event', DbType.text);
  }

  static TableField _fEventType;
  static TableField get eventType {
    return _fEventType = _fEventType ??
        SqlSyntax.setField(_fEventType, 'eventType', DbType.text);
  }

  static TableField _fEventGroup;
  static TableField get eventGroup {
    return _fEventGroup = _fEventGroup ??
        SqlSyntax.setField(_fEventGroup, 'eventGroup', DbType.integer);
  }

  static TableField _fSport;
  static TableField get sport {
    return _fSport =
        _fSport ?? SqlSyntax.setField(_fSport, 'sport', DbType.text);
  }

  static TableField _fSubSport;
  static TableField get subSport {
    return _fSubSport =
        _fSubSport ?? SqlSyntax.setField(_fSubSport, 'subSport', DbType.text);
  }

  static TableField _fAvgVerticalOscillation;
  static TableField get avgVerticalOscillation {
    return _fAvgVerticalOscillation = _fAvgVerticalOscillation ??
        SqlSyntax.setField(
            _fAvgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  static TableField _fTotalElapsedTime;
  static TableField get totalElapsedTime {
    return _fTotalElapsedTime = _fTotalElapsedTime ??
        SqlSyntax.setField(
            _fTotalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  static TableField _fTotalTimerTime;
  static TableField get totalTimerTime {
    return _fTotalTimerTime = _fTotalTimerTime ??
        SqlSyntax.setField(_fTotalTimerTime, 'totalTimerTime', DbType.integer);
  }

  static TableField _fTotalDistance;
  static TableField get totalDistance {
    return _fTotalDistance = _fTotalDistance ??
        SqlSyntax.setField(_fTotalDistance, 'totalDistance', DbType.integer);
  }

  static TableField _fTotalStrides;
  static TableField get totalStrides {
    return _fTotalStrides = _fTotalStrides ??
        SqlSyntax.setField(_fTotalStrides, 'totalStrides', DbType.integer);
  }

  static TableField _fTotalCalories;
  static TableField get totalCalories {
    return _fTotalCalories = _fTotalCalories ??
        SqlSyntax.setField(_fTotalCalories, 'totalCalories', DbType.integer);
  }

  static TableField _fAvgSpeed;
  static TableField get avgSpeed {
    return _fAvgSpeed =
        _fAvgSpeed ?? SqlSyntax.setField(_fAvgSpeed, 'avgSpeed', DbType.real);
  }

  static TableField _fAvgSpeedByMeasurements;
  static TableField get avgSpeedByMeasurements {
    return _fAvgSpeedByMeasurements = _fAvgSpeedByMeasurements ??
        SqlSyntax.setField(
            _fAvgSpeedByMeasurements, 'avgSpeedByMeasurements', DbType.real);
  }

  static TableField _fAvgSpeedBySpeed;
  static TableField get avgSpeedBySpeed {
    return _fAvgSpeedBySpeed = _fAvgSpeedBySpeed ??
        SqlSyntax.setField(_fAvgSpeedBySpeed, 'avgSpeedBySpeed', DbType.real);
  }

  static TableField _fAvgSpeedByDistance;
  static TableField get avgSpeedByDistance {
    return _fAvgSpeedByDistance = _fAvgSpeedByDistance ??
        SqlSyntax.setField(
            _fAvgSpeedByDistance, 'avgSpeedByDistance', DbType.real);
  }

  static TableField _fSdevSpeed;
  static TableField get sdevSpeed {
    return _fSdevSpeed = _fSdevSpeed ??
        SqlSyntax.setField(_fSdevSpeed, 'sdevSpeed', DbType.real);
  }

  static TableField _fSdevPace;
  static TableField get sdevPace {
    return _fSdevPace =
        _fSdevPace ?? SqlSyntax.setField(_fSdevPace, 'sdevPace', DbType.real);
  }

  static TableField _fMinSpeed;
  static TableField get minSpeed {
    return _fMinSpeed =
        _fMinSpeed ?? SqlSyntax.setField(_fMinSpeed, 'minSpeed', DbType.real);
  }

  static TableField _fMaxSpeed;
  static TableField get maxSpeed {
    return _fMaxSpeed =
        _fMaxSpeed ?? SqlSyntax.setField(_fMaxSpeed, 'maxSpeed', DbType.real);
  }

  static TableField _fTotalAscent;
  static TableField get totalAscent {
    return _fTotalAscent = _fTotalAscent ??
        SqlSyntax.setField(_fTotalAscent, 'totalAscent', DbType.integer);
  }

  static TableField _fTotalDescent;
  static TableField get totalDescent {
    return _fTotalDescent = _fTotalDescent ??
        SqlSyntax.setField(_fTotalDescent, 'totalDescent', DbType.integer);
  }

  static TableField _fAvgStanceTimePercent;
  static TableField get avgStanceTimePercent {
    return _fAvgStanceTimePercent = _fAvgStanceTimePercent ??
        SqlSyntax.setField(
            _fAvgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  static TableField _fAvgStanceTime;
  static TableField get avgStanceTime {
    return _fAvgStanceTime = _fAvgStanceTime ??
        SqlSyntax.setField(_fAvgStanceTime, 'avgStanceTime', DbType.real);
  }

  static TableField _fMaxRunningCadence;
  static TableField get maxRunningCadence {
    return _fMaxRunningCadence = _fMaxRunningCadence ??
        SqlSyntax.setField(
            _fMaxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  static TableField _fIntensity;
  static TableField get intensity {
    return _fIntensity = _fIntensity ??
        SqlSyntax.setField(_fIntensity, 'intensity', DbType.integer);
  }

  static TableField _fLapTrigger;
  static TableField get lapTrigger {
    return _fLapTrigger = _fLapTrigger ??
        SqlSyntax.setField(_fLapTrigger, 'lapTrigger', DbType.text);
  }

  static TableField _fAvgTemperature;
  static TableField get avgTemperature {
    return _fAvgTemperature = _fAvgTemperature ??
        SqlSyntax.setField(_fAvgTemperature, 'avgTemperature', DbType.integer);
  }

  static TableField _fMaxTemperature;
  static TableField get maxTemperature {
    return _fMaxTemperature = _fMaxTemperature ??
        SqlSyntax.setField(_fMaxTemperature, 'maxTemperature', DbType.integer);
  }

  static TableField _fAvgFractionalCadence;
  static TableField get avgFractionalCadence {
    return _fAvgFractionalCadence = _fAvgFractionalCadence ??
        SqlSyntax.setField(
            _fAvgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  static TableField _fMaxFractionalCadence;
  static TableField get maxFractionalCadence {
    return _fMaxFractionalCadence = _fMaxFractionalCadence ??
        SqlSyntax.setField(
            _fMaxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  static TableField _fTotalFractionalCycles;
  static TableField get totalFractionalCycles {
    return _fTotalFractionalCycles = _fTotalFractionalCycles ??
        SqlSyntax.setField(
            _fTotalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  static TableField _fAvgPower;
  static TableField get avgPower {
    return _fAvgPower =
        _fAvgPower ?? SqlSyntax.setField(_fAvgPower, 'avgPower', DbType.real);
  }

  static TableField _fMinPower;
  static TableField get minPower {
    return _fMinPower = _fMinPower ??
        SqlSyntax.setField(_fMinPower, 'minPower', DbType.integer);
  }

  static TableField _fMaxPower;
  static TableField get maxPower {
    return _fMaxPower = _fMaxPower ??
        SqlSyntax.setField(_fMaxPower, 'maxPower', DbType.integer);
  }

  static TableField _fSdevPower;
  static TableField get sdevPower {
    return _fSdevPower = _fSdevPower ??
        SqlSyntax.setField(_fSdevPower, 'sdevPower', DbType.real);
  }

  static TableField _fMinHeartRate;
  static TableField get minHeartRate {
    return _fMinHeartRate = _fMinHeartRate ??
        SqlSyntax.setField(_fMinHeartRate, 'minHeartRate', DbType.integer);
  }

  static TableField _fSdevHeartRate;
  static TableField get sdevHeartRate {
    return _fSdevHeartRate = _fSdevHeartRate ??
        SqlSyntax.setField(_fSdevHeartRate, 'sdevHeartRate', DbType.real);
  }

  static TableField _fAvgGroundTime;
  static TableField get avgGroundTime {
    return _fAvgGroundTime = _fAvgGroundTime ??
        SqlSyntax.setField(_fAvgGroundTime, 'avgGroundTime', DbType.real);
  }

  static TableField _fSdevGroundTime;
  static TableField get sdevGroundTime {
    return _fSdevGroundTime = _fSdevGroundTime ??
        SqlSyntax.setField(_fSdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  static TableField _fAvgLegSpringStiffness;
  static TableField get avgLegSpringStiffness {
    return _fAvgLegSpringStiffness = _fAvgLegSpringStiffness ??
        SqlSyntax.setField(
            _fAvgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  static TableField _fSdevLegSpringStiffness;
  static TableField get sdevLegSpringStiffness {
    return _fSdevLegSpringStiffness = _fSdevLegSpringStiffness ??
        SqlSyntax.setField(
            _fSdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  static TableField _fAvgFormPower;
  static TableField get avgFormPower {
    return _fAvgFormPower = _fAvgFormPower ??
        SqlSyntax.setField(_fAvgFormPower, 'avgFormPower', DbType.real);
  }

  static TableField _fSdevFormPower;
  static TableField get sdevFormPower {
    return _fSdevFormPower = _fSdevFormPower ??
        SqlSyntax.setField(_fSdevFormPower, 'sdevFormPower', DbType.real);
  }

  static TableField _fAvgStrydCadence;
  static TableField get avgStrydCadence {
    return _fAvgStrydCadence = _fAvgStrydCadence ??
        SqlSyntax.setField(_fAvgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  static TableField _fSdevStrydCadence;
  static TableField get sdevStrydCadence {
    return _fSdevStrydCadence = _fSdevStrydCadence ??
        SqlSyntax.setField(_fSdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  static TableField _fSdevVerticalOscillation;
  static TableField get sdevVerticalOscillation {
    return _fSdevVerticalOscillation = _fSdevVerticalOscillation ??
        SqlSyntax.setField(
            _fSdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  static TableField _fAvgPowerRatio;
  static TableField get avgPowerRatio {
    return _fAvgPowerRatio = _fAvgPowerRatio ??
        SqlSyntax.setField(_fAvgPowerRatio, 'avgPowerRatio', DbType.real);
  }

  static TableField _fSdevPowerRatio;
  static TableField get sdevPowerRatio {
    return _fSdevPowerRatio = _fSdevPowerRatio ??
        SqlSyntax.setField(_fSdevPowerRatio, 'sdevPowerRatio', DbType.real);
  }

  static TableField _fAvgStrideRatio;
  static TableField get avgStrideRatio {
    return _fAvgStrideRatio = _fAvgStrideRatio ??
        SqlSyntax.setField(_fAvgStrideRatio, 'avgStrideRatio', DbType.real);
  }

  static TableField _fSdevStrideRatio;
  static TableField get sdevStrideRatio {
    return _fSdevStrideRatio = _fSdevStrideRatio ??
        SqlSyntax.setField(_fSdevStrideRatio, 'sdevStrideRatio', DbType.real);
  }

  static TableField _fCp;
  static TableField get cp {
    return _fCp = _fCp ?? SqlSyntax.setField(_fCp, 'cp', DbType.real);
  }

  static TableField _fFtp;
  static TableField get ftp {
    return _fFtp = _fFtp ?? SqlSyntax.setField(_fFtp, 'ftp', DbType.real);
  }

  static TableField _fActivitiesId;
  static TableField get activitiesId {
    return _fActivitiesId = _fActivitiesId ??
        SqlSyntax.setField(_fActivitiesId, 'activitiesId', DbType.integer);
  }
}
// endregion DbLapFields

//region DbLapManager
class DbLapManager extends SqfEntityProvider {
  DbLapManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'laps';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbLapManager
// region DbInterval
class DbInterval {
  DbInterval(
      {this.id,
      this.timeStamp,
      this.duration,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgSpeed,
      this.avgSpeedByMeasurements,
      this.avgSpeedBySpeed,
      this.avgSpeedByDistance,
      this.minSpeed,
      this.maxSpeed,
      this.sdevSpeed,
      this.sdevPace,
      this.distance,
      this.avgHeartRate,
      this.minHeartRate,
      this.maxHeartRate,
      this.sdevHeartRate,
      this.avgCadence,
      this.minCadence,
      this.maxCadence,
      this.sdevCadence,
      this.avgStrydCadence,
      this.minStrydCadence,
      this.maxStrydCadence,
      this.sdevStrydCadence,
      this.avgGroundTime,
      this.minGroundTime,
      this.maxGroundTime,
      this.sdevGroundTime,
      this.avgVerticalOscillation,
      this.minVerticalOscillation,
      this.maxVerticalOscillation,
      this.sdevVerticalOscillation,
      this.avgFormPower,
      this.maxFormPower,
      this.minFormPower,
      this.sdevFormPower,
      this.avgLegSpringStiffness,
      this.maxLegSpringStiffness,
      this.minLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.totalAscent,
      this.totalDescent,
      this.cp,
      this.ftp,
      this.firstRecordId,
      this.lastRecordId,
      this.athletesId,
      this.activitiesId}) {
    _setDefaultValues();
  }
  DbInterval.withFields(
      this.timeStamp,
      this.duration,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgSpeed,
      this.avgSpeedByMeasurements,
      this.avgSpeedBySpeed,
      this.avgSpeedByDistance,
      this.minSpeed,
      this.maxSpeed,
      this.sdevSpeed,
      this.sdevPace,
      this.distance,
      this.avgHeartRate,
      this.minHeartRate,
      this.maxHeartRate,
      this.sdevHeartRate,
      this.avgCadence,
      this.minCadence,
      this.maxCadence,
      this.sdevCadence,
      this.avgStrydCadence,
      this.minStrydCadence,
      this.maxStrydCadence,
      this.sdevStrydCadence,
      this.avgGroundTime,
      this.minGroundTime,
      this.maxGroundTime,
      this.sdevGroundTime,
      this.avgVerticalOscillation,
      this.minVerticalOscillation,
      this.maxVerticalOscillation,
      this.sdevVerticalOscillation,
      this.avgFormPower,
      this.maxFormPower,
      this.minFormPower,
      this.sdevFormPower,
      this.avgLegSpringStiffness,
      this.maxLegSpringStiffness,
      this.minLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.totalAscent,
      this.totalDescent,
      this.cp,
      this.ftp,
      this.firstRecordId,
      this.lastRecordId,
      this.athletesId,
      this.activitiesId) {
    _setDefaultValues();
  }
  DbInterval.withId(
      this.id,
      this.timeStamp,
      this.duration,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgSpeed,
      this.avgSpeedByMeasurements,
      this.avgSpeedBySpeed,
      this.avgSpeedByDistance,
      this.minSpeed,
      this.maxSpeed,
      this.sdevSpeed,
      this.sdevPace,
      this.distance,
      this.avgHeartRate,
      this.minHeartRate,
      this.maxHeartRate,
      this.sdevHeartRate,
      this.avgCadence,
      this.minCadence,
      this.maxCadence,
      this.sdevCadence,
      this.avgStrydCadence,
      this.minStrydCadence,
      this.maxStrydCadence,
      this.sdevStrydCadence,
      this.avgGroundTime,
      this.minGroundTime,
      this.maxGroundTime,
      this.sdevGroundTime,
      this.avgVerticalOscillation,
      this.minVerticalOscillation,
      this.maxVerticalOscillation,
      this.sdevVerticalOscillation,
      this.avgFormPower,
      this.maxFormPower,
      this.minFormPower,
      this.sdevFormPower,
      this.avgLegSpringStiffness,
      this.maxLegSpringStiffness,
      this.minLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.totalAscent,
      this.totalDescent,
      this.cp,
      this.ftp,
      this.firstRecordId,
      this.lastRecordId,
      this.athletesId,
      this.activitiesId) {
    _setDefaultValues();
  }
  DbInterval.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['timeStamp'] != null) {
      timeStamp = int.tryParse(o['timeStamp'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['timeStamp'].toString()))
          : DateTime.tryParse(o['timeStamp'].toString());
    }
    if (o['duration'] != null) {
      duration = int.tryParse(o['duration'].toString());
    }
    if (o['avgPower'] != null) {
      avgPower = double.tryParse(o['avgPower'].toString());
    }
    if (o['minPower'] != null) {
      minPower = int.tryParse(o['minPower'].toString());
    }
    if (o['maxPower'] != null) {
      maxPower = int.tryParse(o['maxPower'].toString());
    }
    if (o['sdevPower'] != null) {
      sdevPower = double.tryParse(o['sdevPower'].toString());
    }
    if (o['avgSpeed'] != null) {
      avgSpeed = double.tryParse(o['avgSpeed'].toString());
    }
    if (o['avgSpeedByMeasurements'] != null) {
      avgSpeedByMeasurements =
          double.tryParse(o['avgSpeedByMeasurements'].toString());
    }
    if (o['avgSpeedBySpeed'] != null) {
      avgSpeedBySpeed = double.tryParse(o['avgSpeedBySpeed'].toString());
    }
    if (o['avgSpeedByDistance'] != null) {
      avgSpeedByDistance = double.tryParse(o['avgSpeedByDistance'].toString());
    }
    if (o['minSpeed'] != null) {
      minSpeed = double.tryParse(o['minSpeed'].toString());
    }
    if (o['maxSpeed'] != null) {
      maxSpeed = double.tryParse(o['maxSpeed'].toString());
    }
    if (o['sdevSpeed'] != null) {
      sdevSpeed = double.tryParse(o['sdevSpeed'].toString());
    }
    if (o['sdevPace'] != null) {
      sdevPace = double.tryParse(o['sdevPace'].toString());
    }
    if (o['distance'] != null) {
      distance = int.tryParse(o['distance'].toString());
    }
    if (o['avgHeartRate'] != null) {
      avgHeartRate = int.tryParse(o['avgHeartRate'].toString());
    }
    if (o['minHeartRate'] != null) {
      minHeartRate = int.tryParse(o['minHeartRate'].toString());
    }
    if (o['maxHeartRate'] != null) {
      maxHeartRate = int.tryParse(o['maxHeartRate'].toString());
    }
    if (o['sdevHeartRate'] != null) {
      sdevHeartRate = double.tryParse(o['sdevHeartRate'].toString());
    }
    if (o['avgCadence'] != null) {
      avgCadence = double.tryParse(o['avgCadence'].toString());
    }
    if (o['minCadence'] != null) {
      minCadence = double.tryParse(o['minCadence'].toString());
    }
    if (o['maxCadence'] != null) {
      maxCadence = double.tryParse(o['maxCadence'].toString());
    }
    if (o['sdevCadence'] != null) {
      sdevCadence = double.tryParse(o['sdevCadence'].toString());
    }
    if (o['avgStrydCadence'] != null) {
      avgStrydCadence = double.tryParse(o['avgStrydCadence'].toString());
    }
    if (o['minStrydCadence'] != null) {
      minStrydCadence = double.tryParse(o['minStrydCadence'].toString());
    }
    if (o['maxStrydCadence'] != null) {
      maxStrydCadence = double.tryParse(o['maxStrydCadence'].toString());
    }
    if (o['sdevStrydCadence'] != null) {
      sdevStrydCadence = double.tryParse(o['sdevStrydCadence'].toString());
    }
    if (o['avgGroundTime'] != null) {
      avgGroundTime = double.tryParse(o['avgGroundTime'].toString());
    }
    if (o['minGroundTime'] != null) {
      minGroundTime = double.tryParse(o['minGroundTime'].toString());
    }
    if (o['maxGroundTime'] != null) {
      maxGroundTime = double.tryParse(o['maxGroundTime'].toString());
    }
    if (o['sdevGroundTime'] != null) {
      sdevGroundTime = double.tryParse(o['sdevGroundTime'].toString());
    }
    if (o['avgVerticalOscillation'] != null) {
      avgVerticalOscillation =
          double.tryParse(o['avgVerticalOscillation'].toString());
    }
    if (o['minVerticalOscillation'] != null) {
      minVerticalOscillation =
          double.tryParse(o['minVerticalOscillation'].toString());
    }
    if (o['maxVerticalOscillation'] != null) {
      maxVerticalOscillation =
          double.tryParse(o['maxVerticalOscillation'].toString());
    }
    if (o['sdevVerticalOscillation'] != null) {
      sdevVerticalOscillation =
          double.tryParse(o['sdevVerticalOscillation'].toString());
    }
    if (o['avgFormPower'] != null) {
      avgFormPower = double.tryParse(o['avgFormPower'].toString());
    }
    if (o['maxFormPower'] != null) {
      maxFormPower = int.tryParse(o['maxFormPower'].toString());
    }
    if (o['minFormPower'] != null) {
      minFormPower = int.tryParse(o['minFormPower'].toString());
    }
    if (o['sdevFormPower'] != null) {
      sdevFormPower = double.tryParse(o['sdevFormPower'].toString());
    }
    if (o['avgLegSpringStiffness'] != null) {
      avgLegSpringStiffness =
          double.tryParse(o['avgLegSpringStiffness'].toString());
    }
    if (o['maxLegSpringStiffness'] != null) {
      maxLegSpringStiffness =
          double.tryParse(o['maxLegSpringStiffness'].toString());
    }
    if (o['minLegSpringStiffness'] != null) {
      minLegSpringStiffness =
          double.tryParse(o['minLegSpringStiffness'].toString());
    }
    if (o['sdevLegSpringStiffness'] != null) {
      sdevLegSpringStiffness =
          double.tryParse(o['sdevLegSpringStiffness'].toString());
    }
    if (o['totalAscent'] != null) {
      totalAscent = int.tryParse(o['totalAscent'].toString());
    }
    if (o['totalDescent'] != null) {
      totalDescent = int.tryParse(o['totalDescent'].toString());
    }
    if (o['cp'] != null) {
      cp = double.tryParse(o['cp'].toString());
    }
    if (o['ftp'] != null) {
      ftp = double.tryParse(o['ftp'].toString());
    }
    firstRecordId = int.tryParse(o['firstRecordId'].toString());

    lastRecordId = int.tryParse(o['lastRecordId'].toString());

    athletesId = int.tryParse(o['athletesId'].toString());

    activitiesId = int.tryParse(o['activitiesId'].toString());

    // RELATIONSHIPS FromMAP
    plDbEvent = o['dbEvent'] != null
        ? DbEvent.fromMap(o['dbEvent'] as Map<String, dynamic>)
        : null;
    plDbEventByLastRecordId = o['dbEvent'] != null
        ? DbEvent.fromMap(o['dbEvent'] as Map<String, dynamic>)
        : null;
    plDbAthlete = o['dbAthlete'] != null
        ? DbAthlete.fromMap(o['dbAthlete'] as Map<String, dynamic>)
        : null;
    plDbActivity = o['dbActivity'] != null
        ? DbActivity.fromMap(o['dbActivity'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbInterval)
  int id;
  DateTime timeStamp;
  int duration;
  double avgPower;
  int minPower;
  int maxPower;
  double sdevPower;
  double avgSpeed;
  double avgSpeedByMeasurements;
  double avgSpeedBySpeed;
  double avgSpeedByDistance;
  double minSpeed;
  double maxSpeed;
  double sdevSpeed;
  double sdevPace;
  int distance;
  int avgHeartRate;
  int minHeartRate;
  int maxHeartRate;
  double sdevHeartRate;
  double avgCadence;
  double minCadence;
  double maxCadence;
  double sdevCadence;
  double avgStrydCadence;
  double minStrydCadence;
  double maxStrydCadence;
  double sdevStrydCadence;
  double avgGroundTime;
  double minGroundTime;
  double maxGroundTime;
  double sdevGroundTime;
  double avgVerticalOscillation;
  double minVerticalOscillation;
  double maxVerticalOscillation;
  double sdevVerticalOscillation;
  double avgFormPower;
  int maxFormPower;
  int minFormPower;
  double sdevFormPower;
  double avgLegSpringStiffness;
  double maxLegSpringStiffness;
  double minLegSpringStiffness;
  double sdevLegSpringStiffness;
  int totalAscent;
  int totalDescent;
  double cp;
  double ftp;
  int firstRecordId;
  int lastRecordId;
  int athletesId;
  int activitiesId;

  BoolResult saveResult;
  // end FIELDS (DbInterval)

// RELATIONSHIPS (DbInterval)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbEvent', 'plField2'..]) or so on..
  DbEvent plDbEvent;

  /// get DbEvent By FirstRecordId
  Future<DbEvent> getDbEvent(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbEvent().getById(firstRecordId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbEventByLastRecordId', 'plField2'..]) or so on..
  DbEvent plDbEventByLastRecordId;

  /// get DbEvent By LastRecordId
  Future<DbEvent> getDbEventByLastRecordId(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbEvent().getById(lastRecordId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbAthlete', 'plField2'..]) or so on..
  DbAthlete plDbAthlete;

  /// get DbAthlete By AthletesId
  Future<DbAthlete> getDbAthlete(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbAthlete().getById(athletesId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbActivity', 'plField2'..]) or so on..
  DbActivity plDbActivity;

  /// get DbActivity By ActivitiesId
  Future<DbActivity> getDbActivity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbActivity().getById(activitiesId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbInterval)

// COLLECTIONS & VIRTUALS (DbInterval)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbIntervalTaggings', 'plField2'..]) or so on..
  List<DbIntervalTagging> plDbIntervalTaggings;

  /// get DbIntervalTagging(s) filtered by id=intervalsId
  DbIntervalTaggingFilterBuilder getDbIntervalTaggings(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbIntervalTagging()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .intervalsId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (DbInterval)

  static const bool _softDeleteActivated = false;
  DbIntervalManager __mnDbInterval;

  DbIntervalManager get _mnDbInterval {
    return __mnDbInterval = __mnDbInterval ?? DbIntervalManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (duration != null) {
      map['duration'] = duration;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (avgSpeedByMeasurements != null) {
      map['avgSpeedByMeasurements'] = avgSpeedByMeasurements;
    }

    if (avgSpeedBySpeed != null) {
      map['avgSpeedBySpeed'] = avgSpeedBySpeed;
    }

    if (avgSpeedByDistance != null) {
      map['avgSpeedByDistance'] = avgSpeedByDistance;
    }

    if (minSpeed != null) {
      map['minSpeed'] = minSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (sdevSpeed != null) {
      map['sdevSpeed'] = sdevSpeed;
    }

    if (sdevPace != null) {
      map['sdevPace'] = sdevPace;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (minHeartRate != null) {
      map['minHeartRate'] = minHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (sdevHeartRate != null) {
      map['sdevHeartRate'] = sdevHeartRate;
    }

    if (avgCadence != null) {
      map['avgCadence'] = avgCadence;
    }

    if (minCadence != null) {
      map['minCadence'] = minCadence;
    }

    if (maxCadence != null) {
      map['maxCadence'] = maxCadence;
    }

    if (sdevCadence != null) {
      map['sdevCadence'] = sdevCadence;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (minStrydCadence != null) {
      map['minStrydCadence'] = minStrydCadence;
    }

    if (maxStrydCadence != null) {
      map['maxStrydCadence'] = maxStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (minGroundTime != null) {
      map['minGroundTime'] = minGroundTime;
    }

    if (maxGroundTime != null) {
      map['maxGroundTime'] = maxGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (minVerticalOscillation != null) {
      map['minVerticalOscillation'] = minVerticalOscillation;
    }

    if (maxVerticalOscillation != null) {
      map['maxVerticalOscillation'] = maxVerticalOscillation;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (maxFormPower != null) {
      map['maxFormPower'] = maxFormPower;
    }

    if (minFormPower != null) {
      map['minFormPower'] = minFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (maxLegSpringStiffness != null) {
      map['maxLegSpringStiffness'] = maxLegSpringStiffness;
    }

    if (minLegSpringStiffness != null) {
      map['minLegSpringStiffness'] = minLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (cp != null) {
      map['cp'] = cp;
    }

    if (ftp != null) {
      map['ftp'] = ftp;
    }

    if (firstRecordId != null) {
      map['firstRecordId'] = forView ? plDbEvent.event : firstRecordId;
    }

    if (lastRecordId != null) {
      map['lastRecordId'] = forView ? plDbEvent.event : lastRecordId;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

    if (activitiesId != null) {
      map['activitiesId'] = forView ? plDbActivity.state : activitiesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (duration != null) {
      map['duration'] = duration;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (avgSpeedByMeasurements != null) {
      map['avgSpeedByMeasurements'] = avgSpeedByMeasurements;
    }

    if (avgSpeedBySpeed != null) {
      map['avgSpeedBySpeed'] = avgSpeedBySpeed;
    }

    if (avgSpeedByDistance != null) {
      map['avgSpeedByDistance'] = avgSpeedByDistance;
    }

    if (minSpeed != null) {
      map['minSpeed'] = minSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (sdevSpeed != null) {
      map['sdevSpeed'] = sdevSpeed;
    }

    if (sdevPace != null) {
      map['sdevPace'] = sdevPace;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (minHeartRate != null) {
      map['minHeartRate'] = minHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (sdevHeartRate != null) {
      map['sdevHeartRate'] = sdevHeartRate;
    }

    if (avgCadence != null) {
      map['avgCadence'] = avgCadence;
    }

    if (minCadence != null) {
      map['minCadence'] = minCadence;
    }

    if (maxCadence != null) {
      map['maxCadence'] = maxCadence;
    }

    if (sdevCadence != null) {
      map['sdevCadence'] = sdevCadence;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (minStrydCadence != null) {
      map['minStrydCadence'] = minStrydCadence;
    }

    if (maxStrydCadence != null) {
      map['maxStrydCadence'] = maxStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (minGroundTime != null) {
      map['minGroundTime'] = minGroundTime;
    }

    if (maxGroundTime != null) {
      map['maxGroundTime'] = maxGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (minVerticalOscillation != null) {
      map['minVerticalOscillation'] = minVerticalOscillation;
    }

    if (maxVerticalOscillation != null) {
      map['maxVerticalOscillation'] = maxVerticalOscillation;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (maxFormPower != null) {
      map['maxFormPower'] = maxFormPower;
    }

    if (minFormPower != null) {
      map['minFormPower'] = minFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (maxLegSpringStiffness != null) {
      map['maxLegSpringStiffness'] = maxLegSpringStiffness;
    }

    if (minLegSpringStiffness != null) {
      map['minLegSpringStiffness'] = minLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (cp != null) {
      map['cp'] = cp;
    }

    if (ftp != null) {
      map['ftp'] = ftp;
    }

    if (firstRecordId != null) {
      map['firstRecordId'] = forView ? plDbEvent.event : firstRecordId;
    }

    if (lastRecordId != null) {
      map['lastRecordId'] = forView ? plDbEvent.event : lastRecordId;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

    if (activitiesId != null) {
      map['activitiesId'] = forView ? plDbActivity.state : activitiesId;
    }

// COLLECTIONS (DbInterval)
    if (!forQuery) {
      map['DbIntervalTaggings'] = await getDbIntervalTaggings().toMapList();
    }
// END COLLECTIONS (DbInterval)

    return map;
  }

  /// This method returns Json String [DbInterval]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbInterval]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      timeStamp,
      duration,
      avgPower,
      minPower,
      maxPower,
      sdevPower,
      avgSpeed,
      avgSpeedByMeasurements,
      avgSpeedBySpeed,
      avgSpeedByDistance,
      minSpeed,
      maxSpeed,
      sdevSpeed,
      sdevPace,
      distance,
      avgHeartRate,
      minHeartRate,
      maxHeartRate,
      sdevHeartRate,
      avgCadence,
      minCadence,
      maxCadence,
      sdevCadence,
      avgStrydCadence,
      minStrydCadence,
      maxStrydCadence,
      sdevStrydCadence,
      avgGroundTime,
      minGroundTime,
      maxGroundTime,
      sdevGroundTime,
      avgVerticalOscillation,
      minVerticalOscillation,
      maxVerticalOscillation,
      sdevVerticalOscillation,
      avgFormPower,
      maxFormPower,
      minFormPower,
      sdevFormPower,
      avgLegSpringStiffness,
      maxLegSpringStiffness,
      minLegSpringStiffness,
      sdevLegSpringStiffness,
      totalAscent,
      totalDescent,
      cp,
      ftp,
      firstRecordId,
      lastRecordId,
      athletesId,
      activitiesId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      timeStamp,
      duration,
      avgPower,
      minPower,
      maxPower,
      sdevPower,
      avgSpeed,
      avgSpeedByMeasurements,
      avgSpeedBySpeed,
      avgSpeedByDistance,
      minSpeed,
      maxSpeed,
      sdevSpeed,
      sdevPace,
      distance,
      avgHeartRate,
      minHeartRate,
      maxHeartRate,
      sdevHeartRate,
      avgCadence,
      minCadence,
      maxCadence,
      sdevCadence,
      avgStrydCadence,
      minStrydCadence,
      maxStrydCadence,
      sdevStrydCadence,
      avgGroundTime,
      minGroundTime,
      maxGroundTime,
      sdevGroundTime,
      avgVerticalOscillation,
      minVerticalOscillation,
      maxVerticalOscillation,
      sdevVerticalOscillation,
      avgFormPower,
      maxFormPower,
      minFormPower,
      sdevFormPower,
      avgLegSpringStiffness,
      maxLegSpringStiffness,
      minLegSpringStiffness,
      sdevLegSpringStiffness,
      totalAscent,
      totalDescent,
      cp,
      ftp,
      firstRecordId,
      lastRecordId,
      athletesId,
      activitiesId
    ];
  }

  static Future<List<DbInterval>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbInterval.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbInterval>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbInterval>[];
    try {
      objList = list
          .map((dbinterval) =>
              DbInterval.fromMap(dbinterval as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbInterval.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbInterval>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbInterval> objList = <DbInterval>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbInterval.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('intervals.plDbIntervalTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervalTaggings'))) {
          /*_loadedFields.add('intervals.plDbIntervalTaggings'); */
          obj.plDbIntervalTaggings = obj.plDbIntervalTaggings ??
              await obj.getDbIntervalTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('events.plDbEvent') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbEvent'))) {
          /*_loadedFields.add('events.plDbEvent');*/
          obj.plDbEvent = obj.plDbEvent ??
              await obj.getDbEvent(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('events.plDbEventByLastRecordId') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbEventByLastRecordId'))) {
          /*_loadedFields.add('events.plDbEventByLastRecordId');*/
          obj.plDbEventByLastRecordId = obj.plDbEventByLastRecordId ??
              await obj.getDbEventByLastRecordId(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbInterval by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbInterval if exist, otherwise returns null
  Future<DbInterval> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbInterval obj;
    final data = await _mnDbInterval.getById([id]);
    if (data.length != 0) {
      obj = DbInterval.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('intervals.plDbIntervalTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervalTaggings'))) {
          /*_loadedFields.add('intervals.plDbIntervalTaggings'); */
          obj.plDbIntervalTaggings = obj.plDbIntervalTaggings ??
              await obj.getDbIntervalTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('events.plDbEvent') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbEvent'))) {
          /*_loadedFields.add('events.plDbEvent');*/
          obj.plDbEvent = obj.plDbEvent ??
              await obj.getDbEvent(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('events.plDbEventByLastRecordId') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbEventByLastRecordId'))) {
          /*_loadedFields.add('events.plDbEventByLastRecordId');*/
          obj.plDbEventByLastRecordId = obj.plDbEventByLastRecordId ??
              await obj.getDbEventByLastRecordId(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbInterval) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbInterval.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbInterval.update(this);
    }

    return id;
  }

  /// saveAs DbInterval. Returns a new Primary Key value of DbInterval

  /// <returns>Returns a new Primary Key value of DbInterval
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbInterval> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DbInterval> dbintervals) async {
    // final results = _mnDbInterval.saveAll('INSERT OR REPLACE INTO intervals (id,timeStamp, duration, avgPower, minPower, maxPower, sdevPower, avgSpeed, avgSpeedByMeasurements, avgSpeedBySpeed, avgSpeedByDistance, minSpeed, maxSpeed, sdevSpeed, sdevPace, distance, avgHeartRate, minHeartRate, maxHeartRate, sdevHeartRate, avgCadence, minCadence, maxCadence, sdevCadence, avgStrydCadence, minStrydCadence, maxStrydCadence, sdevStrydCadence, avgGroundTime, minGroundTime, maxGroundTime, sdevGroundTime, avgVerticalOscillation, minVerticalOscillation, maxVerticalOscillation, sdevVerticalOscillation, avgFormPower, maxFormPower, minFormPower, sdevFormPower, avgLegSpringStiffness, maxLegSpringStiffness, minLegSpringStiffness, sdevLegSpringStiffness, totalAscent, totalDescent, cp, ftp, firstRecordId, lastRecordId, athletesId, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',dbintervals);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbintervals) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbintervals.length; i++) {
      if (dbintervals[i].id == null) {
        dbintervals[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbInterval.rawInsert(
              'INSERT OR REPLACE INTO intervals (id,timeStamp, duration, avgPower, minPower, maxPower, sdevPower, avgSpeed, avgSpeedByMeasurements, avgSpeedBySpeed, avgSpeedByDistance, minSpeed, maxSpeed, sdevSpeed, sdevPace, distance, avgHeartRate, minHeartRate, maxHeartRate, sdevHeartRate, avgCadence, minCadence, maxCadence, sdevCadence, avgStrydCadence, minStrydCadence, maxStrydCadence, sdevStrydCadence, avgGroundTime, minGroundTime, maxGroundTime, sdevGroundTime, avgVerticalOscillation, minVerticalOscillation, maxVerticalOscillation, sdevVerticalOscillation, avgFormPower, maxFormPower, minFormPower, sdevFormPower, avgLegSpringStiffness, maxLegSpringStiffness, minLegSpringStiffness, sdevLegSpringStiffness, totalAscent, totalDescent, cp, ftp, firstRecordId, lastRecordId, athletesId, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                timeStamp,
                duration,
                avgPower,
                minPower,
                maxPower,
                sdevPower,
                avgSpeed,
                avgSpeedByMeasurements,
                avgSpeedBySpeed,
                avgSpeedByDistance,
                minSpeed,
                maxSpeed,
                sdevSpeed,
                sdevPace,
                distance,
                avgHeartRate,
                minHeartRate,
                maxHeartRate,
                sdevHeartRate,
                avgCadence,
                minCadence,
                maxCadence,
                sdevCadence,
                avgStrydCadence,
                minStrydCadence,
                maxStrydCadence,
                sdevStrydCadence,
                avgGroundTime,
                minGroundTime,
                maxGroundTime,
                sdevGroundTime,
                avgVerticalOscillation,
                minVerticalOscillation,
                maxVerticalOscillation,
                sdevVerticalOscillation,
                avgFormPower,
                maxFormPower,
                minFormPower,
                sdevFormPower,
                avgLegSpringStiffness,
                maxLegSpringStiffness,
                minLegSpringStiffness,
                sdevLegSpringStiffness,
                totalAscent,
                totalDescent,
                cp,
                ftp,
                firstRecordId,
                lastRecordId,
                athletesId,
                activitiesId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbInterval id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbInterval id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbInterval Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbInterval>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<DbInterval> dbintervals) async {
    final results = await _mnDbInterval.rawInsertAll(
        'INSERT OR REPLACE INTO intervals (id,timeStamp, duration, avgPower, minPower, maxPower, sdevPower, avgSpeed, avgSpeedByMeasurements, avgSpeedBySpeed, avgSpeedByDistance, minSpeed, maxSpeed, sdevSpeed, sdevPace, distance, avgHeartRate, minHeartRate, maxHeartRate, sdevHeartRate, avgCadence, minCadence, maxCadence, sdevCadence, avgStrydCadence, minStrydCadence, maxStrydCadence, sdevStrydCadence, avgGroundTime, minGroundTime, maxGroundTime, sdevGroundTime, avgVerticalOscillation, minVerticalOscillation, maxVerticalOscillation, sdevVerticalOscillation, avgFormPower, maxFormPower, minFormPower, sdevFormPower, avgLegSpringStiffness, maxLegSpringStiffness, minLegSpringStiffness, sdevLegSpringStiffness, totalAscent, totalDescent, cp, ftp, firstRecordId, lastRecordId, athletesId, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbintervals);
    return results;
  }

  /// Deletes DbInterval

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbInterval invoked (id=$id)');
    var result = BoolResult();
    {
      result = await DbIntervalTagging()
          .select()
          .intervalsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbInterval
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbInterval.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbIntervalFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbIntervalFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbIntervalFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbIntervalFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    firstRecordId = firstRecordId ?? 0;
    lastRecordId = lastRecordId ?? 0;
    athletesId = athletesId ?? 0;
    activitiesId = activitiesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbinterval

// region DbIntervalField
class DbIntervalField extends SearchCriteria {
  DbIntervalField(this.dbintervalFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbIntervalFilterBuilder dbintervalFB;

  DbIntervalField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbIntervalFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbintervalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervalFB.parameters, param, SqlSyntax.EQuals,
            dbintervalFB._addedBlocks)
        : setCriteria(pValue, dbintervalFB.parameters, param,
            SqlSyntax.NotEQuals, dbintervalFB._addedBlocks);
    _waitingNot = '';
    dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
        dbintervalFB._addedBlocks.retVal;
    return dbintervalFB;
  }

  DbIntervalFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbintervalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervalFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbintervalFB._addedBlocks)
        : setCriteria(pValue, dbintervalFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbintervalFB._addedBlocks);
    _waitingNot = '';
    dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
        dbintervalFB._addedBlocks.retVal;
    return dbintervalFB;
  }

  DbIntervalFilterBuilder isNull() {
    dbintervalFB._addedBlocks = setCriteria(
        0,
        dbintervalFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbintervalFB._addedBlocks);
    _waitingNot = '';
    dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
        dbintervalFB._addedBlocks.retVal;
    return dbintervalFB;
  }

  DbIntervalFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbintervalFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbintervalFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbintervalFB._addedBlocks);
      _waitingNot = '';
      dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
          dbintervalFB._addedBlocks.retVal;
    }
    return dbintervalFB;
  }

  DbIntervalFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbintervalFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbintervalFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbintervalFB._addedBlocks);
      _waitingNot = '';
      dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
          dbintervalFB._addedBlocks.retVal;
      dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
          dbintervalFB._addedBlocks.retVal;
    }
    return dbintervalFB;
  }

  DbIntervalFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbintervalFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbintervalFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbintervalFB._addedBlocks);
      _waitingNot = '';
      dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
          dbintervalFB._addedBlocks.retVal;
    }
    return dbintervalFB;
  }

  DbIntervalFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbintervalFB._addedBlocks = setCriteria(
          pFirst,
          dbintervalFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbintervalFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbintervalFB._addedBlocks = setCriteria(pFirst, dbintervalFB.parameters,
            param, SqlSyntax.LessThan, dbintervalFB._addedBlocks);
      } else {
        dbintervalFB._addedBlocks = setCriteria(pFirst, dbintervalFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbintervalFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbintervalFB._addedBlocks = setCriteria(pLast, dbintervalFB.parameters,
            param, SqlSyntax.GreaterThan, dbintervalFB._addedBlocks);
      } else {
        dbintervalFB._addedBlocks = setCriteria(pLast, dbintervalFB.parameters,
            param, SqlSyntax.LessThanOrEquals, dbintervalFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
        dbintervalFB._addedBlocks.retVal;
    return dbintervalFB;
  }

  DbIntervalFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbintervalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervalFB.parameters, param,
            SqlSyntax.GreaterThan, dbintervalFB._addedBlocks)
        : setCriteria(pValue, dbintervalFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbintervalFB._addedBlocks);
    _waitingNot = '';
    dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
        dbintervalFB._addedBlocks.retVal;
    return dbintervalFB;
  }

  DbIntervalFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbintervalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervalFB.parameters, param,
            SqlSyntax.LessThan, dbintervalFB._addedBlocks)
        : setCriteria(pValue, dbintervalFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbintervalFB._addedBlocks);
    _waitingNot = '';
    dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
        dbintervalFB._addedBlocks.retVal;
    return dbintervalFB;
  }

  DbIntervalFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbintervalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervalFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbintervalFB._addedBlocks)
        : setCriteria(pValue, dbintervalFB.parameters, param,
            SqlSyntax.LessThan, dbintervalFB._addedBlocks);
    _waitingNot = '';
    dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
        dbintervalFB._addedBlocks.retVal;
    return dbintervalFB;
  }

  DbIntervalFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbintervalFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervalFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbintervalFB._addedBlocks)
        : setCriteria(pValue, dbintervalFB.parameters, param,
            SqlSyntax.GreaterThan, dbintervalFB._addedBlocks);
    _waitingNot = '';
    dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
        dbintervalFB._addedBlocks.retVal;
    return dbintervalFB;
  }

  DbIntervalFilterBuilder inValues(dynamic pValue) {
    dbintervalFB._addedBlocks = setCriteria(
        pValue,
        dbintervalFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbintervalFB._addedBlocks);
    _waitingNot = '';
    dbintervalFB._addedBlocks.needEndBlock[dbintervalFB._blockIndex] =
        dbintervalFB._addedBlocks.retVal;
    return dbintervalFB;
  }
}
// endregion DbIntervalField

// region DbIntervalFilterBuilder
class DbIntervalFilterBuilder extends SearchCriteria {
  DbIntervalFilterBuilder(DbInterval obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbInterval _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbIntervalFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbIntervalFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbIntervalFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbIntervalFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbIntervalFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbIntervalFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbIntervalFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbIntervalFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbIntervalFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbIntervalFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbIntervalFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbIntervalField setField(
      DbIntervalField field, String colName, DbType dbtype) {
    return DbIntervalField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbIntervalField _id;
  DbIntervalField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbIntervalField _timeStamp;
  DbIntervalField get timeStamp {
    return _timeStamp = setField(_timeStamp, 'timeStamp', DbType.datetime);
  }

  DbIntervalField _duration;
  DbIntervalField get duration {
    return _duration = setField(_duration, 'duration', DbType.integer);
  }

  DbIntervalField _avgPower;
  DbIntervalField get avgPower {
    return _avgPower = setField(_avgPower, 'avgPower', DbType.real);
  }

  DbIntervalField _minPower;
  DbIntervalField get minPower {
    return _minPower = setField(_minPower, 'minPower', DbType.integer);
  }

  DbIntervalField _maxPower;
  DbIntervalField get maxPower {
    return _maxPower = setField(_maxPower, 'maxPower', DbType.integer);
  }

  DbIntervalField _sdevPower;
  DbIntervalField get sdevPower {
    return _sdevPower = setField(_sdevPower, 'sdevPower', DbType.real);
  }

  DbIntervalField _avgSpeed;
  DbIntervalField get avgSpeed {
    return _avgSpeed = setField(_avgSpeed, 'avgSpeed', DbType.real);
  }

  DbIntervalField _avgSpeedByMeasurements;
  DbIntervalField get avgSpeedByMeasurements {
    return _avgSpeedByMeasurements = setField(
        _avgSpeedByMeasurements, 'avgSpeedByMeasurements', DbType.real);
  }

  DbIntervalField _avgSpeedBySpeed;
  DbIntervalField get avgSpeedBySpeed {
    return _avgSpeedBySpeed =
        setField(_avgSpeedBySpeed, 'avgSpeedBySpeed', DbType.real);
  }

  DbIntervalField _avgSpeedByDistance;
  DbIntervalField get avgSpeedByDistance {
    return _avgSpeedByDistance =
        setField(_avgSpeedByDistance, 'avgSpeedByDistance', DbType.real);
  }

  DbIntervalField _minSpeed;
  DbIntervalField get minSpeed {
    return _minSpeed = setField(_minSpeed, 'minSpeed', DbType.real);
  }

  DbIntervalField _maxSpeed;
  DbIntervalField get maxSpeed {
    return _maxSpeed = setField(_maxSpeed, 'maxSpeed', DbType.real);
  }

  DbIntervalField _sdevSpeed;
  DbIntervalField get sdevSpeed {
    return _sdevSpeed = setField(_sdevSpeed, 'sdevSpeed', DbType.real);
  }

  DbIntervalField _sdevPace;
  DbIntervalField get sdevPace {
    return _sdevPace = setField(_sdevPace, 'sdevPace', DbType.real);
  }

  DbIntervalField _distance;
  DbIntervalField get distance {
    return _distance = setField(_distance, 'distance', DbType.integer);
  }

  DbIntervalField _avgHeartRate;
  DbIntervalField get avgHeartRate {
    return _avgHeartRate =
        setField(_avgHeartRate, 'avgHeartRate', DbType.integer);
  }

  DbIntervalField _minHeartRate;
  DbIntervalField get minHeartRate {
    return _minHeartRate =
        setField(_minHeartRate, 'minHeartRate', DbType.integer);
  }

  DbIntervalField _maxHeartRate;
  DbIntervalField get maxHeartRate {
    return _maxHeartRate =
        setField(_maxHeartRate, 'maxHeartRate', DbType.integer);
  }

  DbIntervalField _sdevHeartRate;
  DbIntervalField get sdevHeartRate {
    return _sdevHeartRate =
        setField(_sdevHeartRate, 'sdevHeartRate', DbType.real);
  }

  DbIntervalField _avgCadence;
  DbIntervalField get avgCadence {
    return _avgCadence = setField(_avgCadence, 'avgCadence', DbType.real);
  }

  DbIntervalField _minCadence;
  DbIntervalField get minCadence {
    return _minCadence = setField(_minCadence, 'minCadence', DbType.real);
  }

  DbIntervalField _maxCadence;
  DbIntervalField get maxCadence {
    return _maxCadence = setField(_maxCadence, 'maxCadence', DbType.real);
  }

  DbIntervalField _sdevCadence;
  DbIntervalField get sdevCadence {
    return _sdevCadence = setField(_sdevCadence, 'sdevCadence', DbType.real);
  }

  DbIntervalField _avgStrydCadence;
  DbIntervalField get avgStrydCadence {
    return _avgStrydCadence =
        setField(_avgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  DbIntervalField _minStrydCadence;
  DbIntervalField get minStrydCadence {
    return _minStrydCadence =
        setField(_minStrydCadence, 'minStrydCadence', DbType.real);
  }

  DbIntervalField _maxStrydCadence;
  DbIntervalField get maxStrydCadence {
    return _maxStrydCadence =
        setField(_maxStrydCadence, 'maxStrydCadence', DbType.real);
  }

  DbIntervalField _sdevStrydCadence;
  DbIntervalField get sdevStrydCadence {
    return _sdevStrydCadence =
        setField(_sdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  DbIntervalField _avgGroundTime;
  DbIntervalField get avgGroundTime {
    return _avgGroundTime =
        setField(_avgGroundTime, 'avgGroundTime', DbType.real);
  }

  DbIntervalField _minGroundTime;
  DbIntervalField get minGroundTime {
    return _minGroundTime =
        setField(_minGroundTime, 'minGroundTime', DbType.real);
  }

  DbIntervalField _maxGroundTime;
  DbIntervalField get maxGroundTime {
    return _maxGroundTime =
        setField(_maxGroundTime, 'maxGroundTime', DbType.real);
  }

  DbIntervalField _sdevGroundTime;
  DbIntervalField get sdevGroundTime {
    return _sdevGroundTime =
        setField(_sdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  DbIntervalField _avgVerticalOscillation;
  DbIntervalField get avgVerticalOscillation {
    return _avgVerticalOscillation = setField(
        _avgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  DbIntervalField _minVerticalOscillation;
  DbIntervalField get minVerticalOscillation {
    return _minVerticalOscillation = setField(
        _minVerticalOscillation, 'minVerticalOscillation', DbType.real);
  }

  DbIntervalField _maxVerticalOscillation;
  DbIntervalField get maxVerticalOscillation {
    return _maxVerticalOscillation = setField(
        _maxVerticalOscillation, 'maxVerticalOscillation', DbType.real);
  }

  DbIntervalField _sdevVerticalOscillation;
  DbIntervalField get sdevVerticalOscillation {
    return _sdevVerticalOscillation = setField(
        _sdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  DbIntervalField _avgFormPower;
  DbIntervalField get avgFormPower {
    return _avgFormPower = setField(_avgFormPower, 'avgFormPower', DbType.real);
  }

  DbIntervalField _maxFormPower;
  DbIntervalField get maxFormPower {
    return _maxFormPower =
        setField(_maxFormPower, 'maxFormPower', DbType.integer);
  }

  DbIntervalField _minFormPower;
  DbIntervalField get minFormPower {
    return _minFormPower =
        setField(_minFormPower, 'minFormPower', DbType.integer);
  }

  DbIntervalField _sdevFormPower;
  DbIntervalField get sdevFormPower {
    return _sdevFormPower =
        setField(_sdevFormPower, 'sdevFormPower', DbType.real);
  }

  DbIntervalField _avgLegSpringStiffness;
  DbIntervalField get avgLegSpringStiffness {
    return _avgLegSpringStiffness =
        setField(_avgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  DbIntervalField _maxLegSpringStiffness;
  DbIntervalField get maxLegSpringStiffness {
    return _maxLegSpringStiffness =
        setField(_maxLegSpringStiffness, 'maxLegSpringStiffness', DbType.real);
  }

  DbIntervalField _minLegSpringStiffness;
  DbIntervalField get minLegSpringStiffness {
    return _minLegSpringStiffness =
        setField(_minLegSpringStiffness, 'minLegSpringStiffness', DbType.real);
  }

  DbIntervalField _sdevLegSpringStiffness;
  DbIntervalField get sdevLegSpringStiffness {
    return _sdevLegSpringStiffness = setField(
        _sdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  DbIntervalField _totalAscent;
  DbIntervalField get totalAscent {
    return _totalAscent = setField(_totalAscent, 'totalAscent', DbType.integer);
  }

  DbIntervalField _totalDescent;
  DbIntervalField get totalDescent {
    return _totalDescent =
        setField(_totalDescent, 'totalDescent', DbType.integer);
  }

  DbIntervalField _cp;
  DbIntervalField get cp {
    return _cp = setField(_cp, 'cp', DbType.real);
  }

  DbIntervalField _ftp;
  DbIntervalField get ftp {
    return _ftp = setField(_ftp, 'ftp', DbType.real);
  }

  DbIntervalField _firstRecordId;
  DbIntervalField get firstRecordId {
    return _firstRecordId =
        setField(_firstRecordId, 'firstRecordId', DbType.integer);
  }

  DbIntervalField _lastRecordId;
  DbIntervalField get lastRecordId {
    return _lastRecordId =
        setField(_lastRecordId, 'lastRecordId', DbType.integer);
  }

  DbIntervalField _athletesId;
  DbIntervalField get athletesId {
    return _athletesId = setField(_athletesId, 'athletesId', DbType.integer);
  }

  DbIntervalField _activitiesId;
  DbIntervalField get activitiesId {
    return _activitiesId =
        setField(_activitiesId, 'activitiesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbInterval._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbInterval> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Delete sub records where in (DbIntervalTagging) according to DeleteRule.CASCADE
    final idListDbIntervalTaggingBYintervalsId = toListPrimaryKeySQL(false);
    final resDbIntervalTaggingBYintervalsId = await DbIntervalTagging()
        .select()
        .where(
            'intervalsId IN (${idListDbIntervalTaggingBYintervalsId['sql']})',
            parameterValue: idListDbIntervalTaggingBYintervalsId['args'])
        .delete(hardDelete);
    if (!resDbIntervalTaggingBYintervalsId.success) {
      return resDbIntervalTaggingBYintervalsId;
    }

    if (DbInterval._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbInterval.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbInterval.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from intervals ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbInterval.updateBatch(qparams, values);
  }

  /// This method always returns DbInterval Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbInterval>
  Future<DbInterval> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbInterval.toList(qparams);
    final data = await objFuture;
    DbInterval obj;
    if (data.isNotEmpty) {
      obj = DbInterval.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('intervals.plDbIntervalTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervalTaggings'))) {
          /*_loadedFields.add('intervals.plDbIntervalTaggings'); */
          obj.plDbIntervalTaggings = obj.plDbIntervalTaggings ??
              await obj.getDbIntervalTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('events.plDbEvent') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbEvent'))) {
          /*_loadedFields.add('events.plDbEvent');*/
          obj.plDbEvent = obj.plDbEvent ??
              await obj.getDbEvent(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('events.plDbEventByLastRecordId') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbEventByLastRecordId'))) {
          /*_loadedFields.add('events.plDbEventByLastRecordId');*/
          obj.plDbEventByLastRecordId = obj.plDbEventByLastRecordId ??
              await obj.getDbEventByLastRecordId(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbInterval]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbintervalCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbintervalsFuture = await _obj._mnDbInterval.toList(qparams);
    final int count = dbintervalsFuture[0]['CNT'] as int;
    if (dbintervalCount != null) {
      dbintervalCount(count);
    }
    return count;
  }

  /// This method returns List<DbInterval> [DbInterval]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbInterval>
  Future<List<DbInterval>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbInterval> dbintervalsData = await DbInterval.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return dbintervalsData;
  }

  /// This method returns Json String [DbInterval]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbInterval]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbInterval]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbInterval.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbInterval]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM intervals WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbInterval.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbInterval]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbInterval.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbInterval.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbInterval.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbIntervalFilterBuilder

// region DbIntervalFields
class DbIntervalFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fTimeStamp;
  static TableField get timeStamp {
    return _fTimeStamp = _fTimeStamp ??
        SqlSyntax.setField(_fTimeStamp, 'timeStamp', DbType.datetime);
  }

  static TableField _fDuration;
  static TableField get duration {
    return _fDuration = _fDuration ??
        SqlSyntax.setField(_fDuration, 'duration', DbType.integer);
  }

  static TableField _fAvgPower;
  static TableField get avgPower {
    return _fAvgPower =
        _fAvgPower ?? SqlSyntax.setField(_fAvgPower, 'avgPower', DbType.real);
  }

  static TableField _fMinPower;
  static TableField get minPower {
    return _fMinPower = _fMinPower ??
        SqlSyntax.setField(_fMinPower, 'minPower', DbType.integer);
  }

  static TableField _fMaxPower;
  static TableField get maxPower {
    return _fMaxPower = _fMaxPower ??
        SqlSyntax.setField(_fMaxPower, 'maxPower', DbType.integer);
  }

  static TableField _fSdevPower;
  static TableField get sdevPower {
    return _fSdevPower = _fSdevPower ??
        SqlSyntax.setField(_fSdevPower, 'sdevPower', DbType.real);
  }

  static TableField _fAvgSpeed;
  static TableField get avgSpeed {
    return _fAvgSpeed =
        _fAvgSpeed ?? SqlSyntax.setField(_fAvgSpeed, 'avgSpeed', DbType.real);
  }

  static TableField _fAvgSpeedByMeasurements;
  static TableField get avgSpeedByMeasurements {
    return _fAvgSpeedByMeasurements = _fAvgSpeedByMeasurements ??
        SqlSyntax.setField(
            _fAvgSpeedByMeasurements, 'avgSpeedByMeasurements', DbType.real);
  }

  static TableField _fAvgSpeedBySpeed;
  static TableField get avgSpeedBySpeed {
    return _fAvgSpeedBySpeed = _fAvgSpeedBySpeed ??
        SqlSyntax.setField(_fAvgSpeedBySpeed, 'avgSpeedBySpeed', DbType.real);
  }

  static TableField _fAvgSpeedByDistance;
  static TableField get avgSpeedByDistance {
    return _fAvgSpeedByDistance = _fAvgSpeedByDistance ??
        SqlSyntax.setField(
            _fAvgSpeedByDistance, 'avgSpeedByDistance', DbType.real);
  }

  static TableField _fMinSpeed;
  static TableField get minSpeed {
    return _fMinSpeed =
        _fMinSpeed ?? SqlSyntax.setField(_fMinSpeed, 'minSpeed', DbType.real);
  }

  static TableField _fMaxSpeed;
  static TableField get maxSpeed {
    return _fMaxSpeed =
        _fMaxSpeed ?? SqlSyntax.setField(_fMaxSpeed, 'maxSpeed', DbType.real);
  }

  static TableField _fSdevSpeed;
  static TableField get sdevSpeed {
    return _fSdevSpeed = _fSdevSpeed ??
        SqlSyntax.setField(_fSdevSpeed, 'sdevSpeed', DbType.real);
  }

  static TableField _fSdevPace;
  static TableField get sdevPace {
    return _fSdevPace =
        _fSdevPace ?? SqlSyntax.setField(_fSdevPace, 'sdevPace', DbType.real);
  }

  static TableField _fDistance;
  static TableField get distance {
    return _fDistance = _fDistance ??
        SqlSyntax.setField(_fDistance, 'distance', DbType.integer);
  }

  static TableField _fAvgHeartRate;
  static TableField get avgHeartRate {
    return _fAvgHeartRate = _fAvgHeartRate ??
        SqlSyntax.setField(_fAvgHeartRate, 'avgHeartRate', DbType.integer);
  }

  static TableField _fMinHeartRate;
  static TableField get minHeartRate {
    return _fMinHeartRate = _fMinHeartRate ??
        SqlSyntax.setField(_fMinHeartRate, 'minHeartRate', DbType.integer);
  }

  static TableField _fMaxHeartRate;
  static TableField get maxHeartRate {
    return _fMaxHeartRate = _fMaxHeartRate ??
        SqlSyntax.setField(_fMaxHeartRate, 'maxHeartRate', DbType.integer);
  }

  static TableField _fSdevHeartRate;
  static TableField get sdevHeartRate {
    return _fSdevHeartRate = _fSdevHeartRate ??
        SqlSyntax.setField(_fSdevHeartRate, 'sdevHeartRate', DbType.real);
  }

  static TableField _fAvgCadence;
  static TableField get avgCadence {
    return _fAvgCadence = _fAvgCadence ??
        SqlSyntax.setField(_fAvgCadence, 'avgCadence', DbType.real);
  }

  static TableField _fMinCadence;
  static TableField get minCadence {
    return _fMinCadence = _fMinCadence ??
        SqlSyntax.setField(_fMinCadence, 'minCadence', DbType.real);
  }

  static TableField _fMaxCadence;
  static TableField get maxCadence {
    return _fMaxCadence = _fMaxCadence ??
        SqlSyntax.setField(_fMaxCadence, 'maxCadence', DbType.real);
  }

  static TableField _fSdevCadence;
  static TableField get sdevCadence {
    return _fSdevCadence = _fSdevCadence ??
        SqlSyntax.setField(_fSdevCadence, 'sdevCadence', DbType.real);
  }

  static TableField _fAvgStrydCadence;
  static TableField get avgStrydCadence {
    return _fAvgStrydCadence = _fAvgStrydCadence ??
        SqlSyntax.setField(_fAvgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  static TableField _fMinStrydCadence;
  static TableField get minStrydCadence {
    return _fMinStrydCadence = _fMinStrydCadence ??
        SqlSyntax.setField(_fMinStrydCadence, 'minStrydCadence', DbType.real);
  }

  static TableField _fMaxStrydCadence;
  static TableField get maxStrydCadence {
    return _fMaxStrydCadence = _fMaxStrydCadence ??
        SqlSyntax.setField(_fMaxStrydCadence, 'maxStrydCadence', DbType.real);
  }

  static TableField _fSdevStrydCadence;
  static TableField get sdevStrydCadence {
    return _fSdevStrydCadence = _fSdevStrydCadence ??
        SqlSyntax.setField(_fSdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  static TableField _fAvgGroundTime;
  static TableField get avgGroundTime {
    return _fAvgGroundTime = _fAvgGroundTime ??
        SqlSyntax.setField(_fAvgGroundTime, 'avgGroundTime', DbType.real);
  }

  static TableField _fMinGroundTime;
  static TableField get minGroundTime {
    return _fMinGroundTime = _fMinGroundTime ??
        SqlSyntax.setField(_fMinGroundTime, 'minGroundTime', DbType.real);
  }

  static TableField _fMaxGroundTime;
  static TableField get maxGroundTime {
    return _fMaxGroundTime = _fMaxGroundTime ??
        SqlSyntax.setField(_fMaxGroundTime, 'maxGroundTime', DbType.real);
  }

  static TableField _fSdevGroundTime;
  static TableField get sdevGroundTime {
    return _fSdevGroundTime = _fSdevGroundTime ??
        SqlSyntax.setField(_fSdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  static TableField _fAvgVerticalOscillation;
  static TableField get avgVerticalOscillation {
    return _fAvgVerticalOscillation = _fAvgVerticalOscillation ??
        SqlSyntax.setField(
            _fAvgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  static TableField _fMinVerticalOscillation;
  static TableField get minVerticalOscillation {
    return _fMinVerticalOscillation = _fMinVerticalOscillation ??
        SqlSyntax.setField(
            _fMinVerticalOscillation, 'minVerticalOscillation', DbType.real);
  }

  static TableField _fMaxVerticalOscillation;
  static TableField get maxVerticalOscillation {
    return _fMaxVerticalOscillation = _fMaxVerticalOscillation ??
        SqlSyntax.setField(
            _fMaxVerticalOscillation, 'maxVerticalOscillation', DbType.real);
  }

  static TableField _fSdevVerticalOscillation;
  static TableField get sdevVerticalOscillation {
    return _fSdevVerticalOscillation = _fSdevVerticalOscillation ??
        SqlSyntax.setField(
            _fSdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  static TableField _fAvgFormPower;
  static TableField get avgFormPower {
    return _fAvgFormPower = _fAvgFormPower ??
        SqlSyntax.setField(_fAvgFormPower, 'avgFormPower', DbType.real);
  }

  static TableField _fMaxFormPower;
  static TableField get maxFormPower {
    return _fMaxFormPower = _fMaxFormPower ??
        SqlSyntax.setField(_fMaxFormPower, 'maxFormPower', DbType.integer);
  }

  static TableField _fMinFormPower;
  static TableField get minFormPower {
    return _fMinFormPower = _fMinFormPower ??
        SqlSyntax.setField(_fMinFormPower, 'minFormPower', DbType.integer);
  }

  static TableField _fSdevFormPower;
  static TableField get sdevFormPower {
    return _fSdevFormPower = _fSdevFormPower ??
        SqlSyntax.setField(_fSdevFormPower, 'sdevFormPower', DbType.real);
  }

  static TableField _fAvgLegSpringStiffness;
  static TableField get avgLegSpringStiffness {
    return _fAvgLegSpringStiffness = _fAvgLegSpringStiffness ??
        SqlSyntax.setField(
            _fAvgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  static TableField _fMaxLegSpringStiffness;
  static TableField get maxLegSpringStiffness {
    return _fMaxLegSpringStiffness = _fMaxLegSpringStiffness ??
        SqlSyntax.setField(
            _fMaxLegSpringStiffness, 'maxLegSpringStiffness', DbType.real);
  }

  static TableField _fMinLegSpringStiffness;
  static TableField get minLegSpringStiffness {
    return _fMinLegSpringStiffness = _fMinLegSpringStiffness ??
        SqlSyntax.setField(
            _fMinLegSpringStiffness, 'minLegSpringStiffness', DbType.real);
  }

  static TableField _fSdevLegSpringStiffness;
  static TableField get sdevLegSpringStiffness {
    return _fSdevLegSpringStiffness = _fSdevLegSpringStiffness ??
        SqlSyntax.setField(
            _fSdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  static TableField _fTotalAscent;
  static TableField get totalAscent {
    return _fTotalAscent = _fTotalAscent ??
        SqlSyntax.setField(_fTotalAscent, 'totalAscent', DbType.integer);
  }

  static TableField _fTotalDescent;
  static TableField get totalDescent {
    return _fTotalDescent = _fTotalDescent ??
        SqlSyntax.setField(_fTotalDescent, 'totalDescent', DbType.integer);
  }

  static TableField _fCp;
  static TableField get cp {
    return _fCp = _fCp ?? SqlSyntax.setField(_fCp, 'cp', DbType.real);
  }

  static TableField _fFtp;
  static TableField get ftp {
    return _fFtp = _fFtp ?? SqlSyntax.setField(_fFtp, 'ftp', DbType.real);
  }

  static TableField _fFirstRecordId;
  static TableField get firstRecordId {
    return _fFirstRecordId = _fFirstRecordId ??
        SqlSyntax.setField(_fFirstRecordId, 'firstRecordId', DbType.integer);
  }

  static TableField _fLastRecordId;
  static TableField get lastRecordId {
    return _fLastRecordId = _fLastRecordId ??
        SqlSyntax.setField(_fLastRecordId, 'lastRecordId', DbType.integer);
  }

  static TableField _fAthletesId;
  static TableField get athletesId {
    return _fAthletesId = _fAthletesId ??
        SqlSyntax.setField(_fAthletesId, 'athletesId', DbType.integer);
  }

  static TableField _fActivitiesId;
  static TableField get activitiesId {
    return _fActivitiesId = _fActivitiesId ??
        SqlSyntax.setField(_fActivitiesId, 'activitiesId', DbType.integer);
  }
}
// endregion DbIntervalFields

//region DbIntervalManager
class DbIntervalManager extends SqfEntityProvider {
  DbIntervalManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'intervals';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbIntervalManager
// region DbWeight
class DbWeight {
  DbWeight({this.id, this.date, this.value, this.athletesId}) {
    _setDefaultValues();
  }
  DbWeight.withFields(this.date, this.value, this.athletesId) {
    _setDefaultValues();
  }
  DbWeight.withId(this.id, this.date, this.value, this.athletesId) {
    _setDefaultValues();
  }
  DbWeight.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString()))
          : DateTime.tryParse(o['date'].toString());
    }
    if (o['value'] != null) {
      value = double.tryParse(o['value'].toString());
    }
    athletesId = int.tryParse(o['athletesId'].toString());

    // RELATIONSHIPS FromMAP
    plDbAthlete = o['dbAthlete'] != null
        ? DbAthlete.fromMap(o['dbAthlete'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbWeight)
  int id;
  DateTime date;
  double value;
  int athletesId;

  BoolResult saveResult;
  // end FIELDS (DbWeight)

// RELATIONSHIPS (DbWeight)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbAthlete', 'plField2'..]) or so on..
  DbAthlete plDbAthlete;

  /// get DbAthlete By AthletesId
  Future<DbAthlete> getDbAthlete(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbAthlete().getById(athletesId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbWeight)

  static const bool _softDeleteActivated = false;
  DbWeightManager __mnDbWeight;

  DbWeightManager get _mnDbWeight {
    return __mnDbWeight = __mnDbWeight ?? DbWeightManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (value != null) {
      map['value'] = value;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (value != null) {
      map['value'] = value;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

    return map;
  }

  /// This method returns Json String [DbWeight]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbWeight]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [date, value, athletesId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, date, value, athletesId];
  }

  static Future<List<DbWeight>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbWeight.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbWeight>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbWeight>[];
    try {
      objList = list
          .map((dbweight) => DbWeight.fromMap(dbweight as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR DbWeight.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbWeight>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbWeight> objList = <DbWeight>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbWeight.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbWeight by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbWeight if exist, otherwise returns null
  Future<DbWeight> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbWeight obj;
    final data = await _mnDbWeight.getById([id]);
    if (data.length != 0) {
      obj = DbWeight.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbWeight) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbWeight.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbWeight.update(this);
    }

    return id;
  }

  /// saveAs DbWeight. Returns a new Primary Key value of DbWeight

  /// <returns>Returns a new Primary Key value of DbWeight
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbWeight> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DbWeight> dbweights) async {
    // final results = _mnDbWeight.saveAll('INSERT OR REPLACE INTO weights (id,date, value, athletesId)  VALUES (?,?,?,?)',dbweights);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbweights) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbweights.length; i++) {
      if (dbweights[i].id == null) {
        dbweights[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbWeight.rawInsert(
              'INSERT OR REPLACE INTO weights (id,date, value, athletesId)  VALUES (?,?,?,?)',
              [id, date, value, athletesId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbWeight id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbWeight id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbWeight Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbWeight>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<DbWeight> dbweights) async {
    final results = await _mnDbWeight.rawInsertAll(
        'INSERT OR REPLACE INTO weights (id,date, value, athletesId)  VALUES (?,?,?,?)',
        dbweights);
    return results;
  }

  /// Deletes DbWeight

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbWeight invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbWeight
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbWeight.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbWeightFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbWeightFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbWeightFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbWeightFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    athletesId = athletesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbweight

// region DbWeightField
class DbWeightField extends SearchCriteria {
  DbWeightField(this.dbweightFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbWeightFilterBuilder dbweightFB;

  DbWeightField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbWeightFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param, SqlSyntax.EQuals,
            dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param, SqlSyntax.NotEQuals,
            dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder isNull() {
    dbweightFB._addedBlocks = setCriteria(
        0,
        dbweightFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbweightFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbweightFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbweightFB._addedBlocks);
      _waitingNot = '';
      dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
          dbweightFB._addedBlocks.retVal;
    }
    return dbweightFB;
  }

  DbWeightFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbweightFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbweightFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbweightFB._addedBlocks);
      _waitingNot = '';
      dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
          dbweightFB._addedBlocks.retVal;
      dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
          dbweightFB._addedBlocks.retVal;
    }
    return dbweightFB;
  }

  DbWeightFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbweightFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbweightFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbweightFB._addedBlocks);
      _waitingNot = '';
      dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
          dbweightFB._addedBlocks.retVal;
    }
    return dbweightFB;
  }

  DbWeightFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbweightFB._addedBlocks = setCriteria(
          pFirst,
          dbweightFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbweightFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbweightFB._addedBlocks = setCriteria(pFirst, dbweightFB.parameters,
            param, SqlSyntax.LessThan, dbweightFB._addedBlocks);
      } else {
        dbweightFB._addedBlocks = setCriteria(pFirst, dbweightFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbweightFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbweightFB._addedBlocks = setCriteria(pLast, dbweightFB.parameters,
            param, SqlSyntax.GreaterThan, dbweightFB._addedBlocks);
      } else {
        dbweightFB._addedBlocks = setCriteria(pLast, dbweightFB.parameters,
            param, SqlSyntax.LessThanOrEquals, dbweightFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.GreaterThan, dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param, SqlSyntax.LessThan,
            dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param, SqlSyntax.LessThan,
            dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.GreaterThan, dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder inValues(dynamic pValue) {
    dbweightFB._addedBlocks = setCriteria(
        pValue,
        dbweightFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }
}
// endregion DbWeightField

// region DbWeightFilterBuilder
class DbWeightFilterBuilder extends SearchCriteria {
  DbWeightFilterBuilder(DbWeight obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbWeight _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbWeightFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbWeightFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbWeightFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbWeightFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbWeightFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbWeightFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbWeightFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbWeightFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbWeightFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbWeightFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbWeightFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbWeightField setField(DbWeightField field, String colName, DbType dbtype) {
    return DbWeightField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbWeightField _id;
  DbWeightField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbWeightField _date;
  DbWeightField get date {
    return _date = setField(_date, 'date', DbType.date);
  }

  DbWeightField _value;
  DbWeightField get value {
    return _value = setField(_value, 'value', DbType.real);
  }

  DbWeightField _athletesId;
  DbWeightField get athletesId {
    return _athletesId = setField(_athletesId, 'athletesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbWeight._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbWeight> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (DbWeight._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbWeight.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbWeight.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from weights ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbWeight.updateBatch(qparams, values);
  }

  /// This method always returns DbWeight Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbWeight>
  Future<DbWeight> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbWeight.toList(qparams);
    final data = await objFuture;
    DbWeight obj;
    if (data.isNotEmpty) {
      obj = DbWeight.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbWeight]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbweightCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbweightsFuture = await _obj._mnDbWeight.toList(qparams);
    final int count = dbweightsFuture[0]['CNT'] as int;
    if (dbweightCount != null) {
      dbweightCount(count);
    }
    return count;
  }

  /// This method returns List<DbWeight> [DbWeight]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbWeight>
  Future<List<DbWeight>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbWeight> dbweightsData = await DbWeight.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return dbweightsData;
  }

  /// This method returns Json String [DbWeight]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbWeight]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbWeight]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbWeight.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbWeight]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM weights WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbWeight.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbWeight]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbWeight.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbWeight.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbWeight.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbWeightFilterBuilder

// region DbWeightFields
class DbWeightFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fDate;
  static TableField get date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.date);
  }

  static TableField _fValue;
  static TableField get value {
    return _fValue =
        _fValue ?? SqlSyntax.setField(_fValue, 'value', DbType.real);
  }

  static TableField _fAthletesId;
  static TableField get athletesId {
    return _fAthletesId = _fAthletesId ??
        SqlSyntax.setField(_fAthletesId, 'athletesId', DbType.integer);
  }
}
// endregion DbWeightFields

//region DbWeightManager
class DbWeightManager extends SqfEntityProvider {
  DbWeightManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'weights';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbWeightManager
// region DbHeartRateZoneSchema
class DbHeartRateZoneSchema {
  DbHeartRateZoneSchema(
      {this.id, this.date, this.name, this.base, this.athletesId}) {
    _setDefaultValues();
  }
  DbHeartRateZoneSchema.withFields(
      this.date, this.name, this.base, this.athletesId) {
    _setDefaultValues();
  }
  DbHeartRateZoneSchema.withId(
      this.id, this.date, this.name, this.base, this.athletesId) {
    _setDefaultValues();
  }
  DbHeartRateZoneSchema.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString()))
          : DateTime.tryParse(o['date'].toString());
    }
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['base'] != null) {
      base = int.tryParse(o['base'].toString());
    }
    athletesId = int.tryParse(o['athletesId'].toString());

    // RELATIONSHIPS FromMAP
    plDbAthlete = o['dbAthlete'] != null
        ? DbAthlete.fromMap(o['dbAthlete'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbHeartRateZoneSchema)
  int id;
  DateTime date;
  String name;
  int base;
  int athletesId;

  BoolResult saveResult;
  // end FIELDS (DbHeartRateZoneSchema)

// RELATIONSHIPS (DbHeartRateZoneSchema)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbAthlete', 'plField2'..]) or so on..
  DbAthlete plDbAthlete;

  /// get DbAthlete By AthletesId
  Future<DbAthlete> getDbAthlete(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbAthlete().getById(athletesId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbHeartRateZoneSchema)

// COLLECTIONS & VIRTUALS (DbHeartRateZoneSchema)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbHeartRateZones', 'plField2'..]) or so on..
  List<DbHeartRateZone> plDbHeartRateZones;

  /// get DbHeartRateZone(s) filtered by id=heartRateZoneSchemataId
  DbHeartRateZoneFilterBuilder getDbHeartRateZones(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbHeartRateZone()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .heartRateZoneSchemataId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (DbHeartRateZoneSchema)

  static const bool _softDeleteActivated = false;
  DbHeartRateZoneSchemaManager __mnDbHeartRateZoneSchema;

  DbHeartRateZoneSchemaManager get _mnDbHeartRateZoneSchema {
    return __mnDbHeartRateZoneSchema =
        __mnDbHeartRateZoneSchema ?? DbHeartRateZoneSchemaManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (base != null) {
      map['base'] = base;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (base != null) {
      map['base'] = base;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

// COLLECTIONS (DbHeartRateZoneSchema)
    if (!forQuery) {
      map['DbHeartRateZones'] = await getDbHeartRateZones().toMapList();
    }
// END COLLECTIONS (DbHeartRateZoneSchema)

    return map;
  }

  /// This method returns Json String [DbHeartRateZoneSchema]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbHeartRateZoneSchema]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [date, name, base, athletesId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, date, name, base, athletesId];
  }

  static Future<List<DbHeartRateZoneSchema>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbHeartRateZoneSchema.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbHeartRateZoneSchema>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbHeartRateZoneSchema>[];
    try {
      objList = list
          .map((dbheartratezoneschema) => DbHeartRateZoneSchema.fromMap(
              dbheartratezoneschema as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbHeartRateZoneSchema.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbHeartRateZoneSchema>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbHeartRateZoneSchema> objList = <DbHeartRateZoneSchema>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbHeartRateZoneSchema.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('heartRateZoneSchemata.plDbHeartRateZones') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbHeartRateZones'))) {
          /*_loadedFields.add('heartRateZoneSchemata.plDbHeartRateZones'); */
          obj.plDbHeartRateZones = obj.plDbHeartRateZones ??
              await obj.getDbHeartRateZones().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbHeartRateZoneSchema by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbHeartRateZoneSchema if exist, otherwise returns null
  Future<DbHeartRateZoneSchema> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbHeartRateZoneSchema obj;
    final data = await _mnDbHeartRateZoneSchema.getById([id]);
    if (data.length != 0) {
      obj = DbHeartRateZoneSchema.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('heartRateZoneSchemata.plDbHeartRateZones') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbHeartRateZones'))) {
          /*_loadedFields.add('heartRateZoneSchemata.plDbHeartRateZones'); */
          obj.plDbHeartRateZones = obj.plDbHeartRateZones ??
              await obj.getDbHeartRateZones().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbHeartRateZoneSchema) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbHeartRateZoneSchema.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbHeartRateZoneSchema.update(this);
    }

    return id;
  }

  /// saveAs DbHeartRateZoneSchema. Returns a new Primary Key value of DbHeartRateZoneSchema

  /// <returns>Returns a new Primary Key value of DbHeartRateZoneSchema
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbHeartRateZoneSchema> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<DbHeartRateZoneSchema> dbheartratezoneschemas) async {
    // final results = _mnDbHeartRateZoneSchema.saveAll('INSERT OR REPLACE INTO heartRateZoneSchemata (id,date, name, base, athletesId)  VALUES (?,?,?,?,?)',dbheartratezoneschemas);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbheartratezoneschemas) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbheartratezoneschemas.length; i++) {
      if (dbheartratezoneschemas[i].id == null) {
        dbheartratezoneschemas[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbHeartRateZoneSchema.rawInsert(
              'INSERT OR REPLACE INTO heartRateZoneSchemata (id,date, name, base, athletesId)  VALUES (?,?,?,?,?)',
              [id, date, name, base, athletesId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'DbHeartRateZoneSchema id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DbHeartRateZoneSchema id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'DbHeartRateZoneSchema Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbHeartRateZoneSchema>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<DbHeartRateZoneSchema> dbheartratezoneschemas) async {
    final results = await _mnDbHeartRateZoneSchema.rawInsertAll(
        'INSERT OR REPLACE INTO heartRateZoneSchemata (id,date, name, base, athletesId)  VALUES (?,?,?,?,?)',
        dbheartratezoneschemas);
    return results;
  }

  /// Deletes DbHeartRateZoneSchema

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbHeartRateZoneSchema invoked (id=$id)');
    var result = BoolResult();
    {
      result = await DbHeartRateZone()
          .select()
          .heartRateZoneSchemataId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbHeartRateZoneSchema
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbHeartRateZoneSchema.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbHeartRateZoneSchemaFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbHeartRateZoneSchemaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbHeartRateZoneSchemaFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbHeartRateZoneSchemaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    athletesId = athletesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbheartratezoneschema

// region DbHeartRateZoneSchemaField
class DbHeartRateZoneSchemaField extends SearchCriteria {
  DbHeartRateZoneSchemaField(this.dbheartratezoneschemaFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbHeartRateZoneSchemaFilterBuilder dbheartratezoneschemaFB;

  DbHeartRateZoneSchemaField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbHeartRateZoneSchemaFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.EQuals, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.NotEQuals, dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder isNull() {
    dbheartratezoneschemaFB._addedBlocks = setCriteria(
        0,
        dbheartratezoneschemaFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneschemaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbheartratezoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneschemaFB
              ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
          dbheartratezoneschemaFB._addedBlocks.retVal;
    }
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneschemaFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbheartratezoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneschemaFB
              ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
          dbheartratezoneschemaFB._addedBlocks.retVal;
      dbheartratezoneschemaFB
              ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
          dbheartratezoneschemaFB._addedBlocks.retVal;
    }
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneschemaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbheartratezoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneschemaFB
              ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
          dbheartratezoneschemaFB._addedBlocks.retVal;
    }
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbheartratezoneschemaFB._addedBlocks = setCriteria(
          pFirst,
          dbheartratezoneschemaFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneschemaFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbheartratezoneschemaFB._addedBlocks = setCriteria(
            pFirst,
            dbheartratezoneschemaFB.parameters,
            param,
            SqlSyntax.LessThan,
            dbheartratezoneschemaFB._addedBlocks);
      } else {
        dbheartratezoneschemaFB._addedBlocks = setCriteria(
            pFirst,
            dbheartratezoneschemaFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbheartratezoneschemaFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbheartratezoneschemaFB._addedBlocks = setCriteria(
            pLast,
            dbheartratezoneschemaFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            dbheartratezoneschemaFB._addedBlocks);
      } else {
        dbheartratezoneschemaFB._addedBlocks = setCriteria(
            pLast,
            dbheartratezoneschemaFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            dbheartratezoneschemaFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.GreaterThan, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.LessThan, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(
            pValue,
            dbheartratezoneschemaFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.LessThan, dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.GreaterThan, dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder inValues(dynamic pValue) {
    dbheartratezoneschemaFB._addedBlocks = setCriteria(
        pValue,
        dbheartratezoneschemaFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }
}
// endregion DbHeartRateZoneSchemaField

// region DbHeartRateZoneSchemaFilterBuilder
class DbHeartRateZoneSchemaFilterBuilder extends SearchCriteria {
  DbHeartRateZoneSchemaFilterBuilder(DbHeartRateZoneSchema obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbHeartRateZoneSchema _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbHeartRateZoneSchemaFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbHeartRateZoneSchemaFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbHeartRateZoneSchemaFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbHeartRateZoneSchemaFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbHeartRateZoneSchemaFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbHeartRateZoneSchemaFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbHeartRateZoneSchemaFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbHeartRateZoneSchemaFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbHeartRateZoneSchemaFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbHeartRateZoneSchemaFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbHeartRateZoneSchemaFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbHeartRateZoneSchemaField setField(
      DbHeartRateZoneSchemaField field, String colName, DbType dbtype) {
    return DbHeartRateZoneSchemaField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbHeartRateZoneSchemaField _id;
  DbHeartRateZoneSchemaField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbHeartRateZoneSchemaField _date;
  DbHeartRateZoneSchemaField get date {
    return _date = setField(_date, 'date', DbType.date);
  }

  DbHeartRateZoneSchemaField _name;
  DbHeartRateZoneSchemaField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbHeartRateZoneSchemaField _base;
  DbHeartRateZoneSchemaField get base {
    return _base = setField(_base, 'base', DbType.integer);
  }

  DbHeartRateZoneSchemaField _athletesId;
  DbHeartRateZoneSchemaField get athletesId {
    return _athletesId = setField(_athletesId, 'athletesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbHeartRateZoneSchema._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbHeartRateZoneSchema> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Delete sub records where in (DbHeartRateZone) according to DeleteRule.CASCADE
    final idListDbHeartRateZoneBYheartRateZoneSchemataId =
        toListPrimaryKeySQL(false);
    final resDbHeartRateZoneBYheartRateZoneSchemataId = await DbHeartRateZone()
        .select()
        .where(
            'heartRateZoneSchemataId IN (${idListDbHeartRateZoneBYheartRateZoneSchemataId['sql']})',
            parameterValue:
                idListDbHeartRateZoneBYheartRateZoneSchemataId['args'])
        .delete(hardDelete);
    if (!resDbHeartRateZoneBYheartRateZoneSchemataId.success) {
      return resDbHeartRateZoneBYheartRateZoneSchemataId;
    }

    if (DbHeartRateZoneSchema._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbHeartRateZoneSchema
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbHeartRateZoneSchema.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from heartRateZoneSchemata ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbHeartRateZoneSchema.updateBatch(qparams, values);
  }

  /// This method always returns DbHeartRateZoneSchema Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbHeartRateZoneSchema>
  Future<DbHeartRateZoneSchema> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbHeartRateZoneSchema.toList(qparams);
    final data = await objFuture;
    DbHeartRateZoneSchema obj;
    if (data.isNotEmpty) {
      obj = DbHeartRateZoneSchema.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('heartRateZoneSchemata.plDbHeartRateZones') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbHeartRateZones'))) {
          /*_loadedFields.add('heartRateZoneSchemata.plDbHeartRateZones'); */
          obj.plDbHeartRateZones = obj.plDbHeartRateZones ??
              await obj.getDbHeartRateZones().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbHeartRateZoneSchema]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) dbheartratezoneschemaCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbheartratezoneschemasFuture =
        await _obj._mnDbHeartRateZoneSchema.toList(qparams);
    final int count = dbheartratezoneschemasFuture[0]['CNT'] as int;
    if (dbheartratezoneschemaCount != null) {
      dbheartratezoneschemaCount(count);
    }
    return count;
  }

  /// This method returns List<DbHeartRateZoneSchema> [DbHeartRateZoneSchema]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbHeartRateZoneSchema>
  Future<List<DbHeartRateZoneSchema>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbHeartRateZoneSchema> dbheartratezoneschemasData =
        await DbHeartRateZoneSchema.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return dbheartratezoneschemasData;
  }

  /// This method returns Json String [DbHeartRateZoneSchema]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbHeartRateZoneSchema]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbHeartRateZoneSchema]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbHeartRateZoneSchema.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbHeartRateZoneSchema]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM heartRateZoneSchemata WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbHeartRateZoneSchema.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbHeartRateZoneSchema]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbHeartRateZoneSchema.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbHeartRateZoneSchema.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbHeartRateZoneSchema.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbHeartRateZoneSchemaFilterBuilder

// region DbHeartRateZoneSchemaFields
class DbHeartRateZoneSchemaFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fDate;
  static TableField get date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.date);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fBase;
  static TableField get base {
    return _fBase =
        _fBase ?? SqlSyntax.setField(_fBase, 'base', DbType.integer);
  }

  static TableField _fAthletesId;
  static TableField get athletesId {
    return _fAthletesId = _fAthletesId ??
        SqlSyntax.setField(_fAthletesId, 'athletesId', DbType.integer);
  }
}
// endregion DbHeartRateZoneSchemaFields

//region DbHeartRateZoneSchemaManager
class DbHeartRateZoneSchemaManager extends SqfEntityProvider {
  DbHeartRateZoneSchemaManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'heartRateZoneSchemata';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbHeartRateZoneSchemaManager
// region DbHeartRateZone
class DbHeartRateZone {
  DbHeartRateZone(
      {this.id,
      this.name,
      this.lowerPercentage,
      this.upperPercentage,
      this.lowerLimit,
      this.upperLimit,
      this.color,
      this.heartRateZoneSchemataId}) {
    _setDefaultValues();
  }
  DbHeartRateZone.withFields(
      this.name,
      this.lowerPercentage,
      this.upperPercentage,
      this.lowerLimit,
      this.upperLimit,
      this.color,
      this.heartRateZoneSchemataId) {
    _setDefaultValues();
  }
  DbHeartRateZone.withId(
      this.id,
      this.name,
      this.lowerPercentage,
      this.upperPercentage,
      this.lowerLimit,
      this.upperLimit,
      this.color,
      this.heartRateZoneSchemataId) {
    _setDefaultValues();
  }
  DbHeartRateZone.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['lowerPercentage'] != null) {
      lowerPercentage = int.tryParse(o['lowerPercentage'].toString());
    }
    if (o['upperPercentage'] != null) {
      upperPercentage = int.tryParse(o['upperPercentage'].toString());
    }
    if (o['lowerLimit'] != null) {
      lowerLimit = int.tryParse(o['lowerLimit'].toString());
    }
    if (o['upperLimit'] != null) {
      upperLimit = int.tryParse(o['upperLimit'].toString());
    }
    if (o['color'] != null) {
      color = int.tryParse(o['color'].toString());
    }
    heartRateZoneSchemataId =
        int.tryParse(o['heartRateZoneSchemataId'].toString());

    // RELATIONSHIPS FromMAP
    plDbHeartRateZoneSchema = o['dbHeartRateZoneSchema'] != null
        ? DbHeartRateZoneSchema.fromMap(
            o['dbHeartRateZoneSchema'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbHeartRateZone)
  int id;
  String name;
  int lowerPercentage;
  int upperPercentage;
  int lowerLimit;
  int upperLimit;
  int color;
  int heartRateZoneSchemataId;

  BoolResult saveResult;
  // end FIELDS (DbHeartRateZone)

// RELATIONSHIPS (DbHeartRateZone)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbHeartRateZoneSchema', 'plField2'..]) or so on..
  DbHeartRateZoneSchema plDbHeartRateZoneSchema;

  /// get DbHeartRateZoneSchema By HeartRateZoneSchemataId
  Future<DbHeartRateZoneSchema> getDbHeartRateZoneSchema(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbHeartRateZoneSchema().getById(heartRateZoneSchemataId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbHeartRateZone)

  static const bool _softDeleteActivated = false;
  DbHeartRateZoneManager __mnDbHeartRateZone;

  DbHeartRateZoneManager get _mnDbHeartRateZone {
    return __mnDbHeartRateZone =
        __mnDbHeartRateZone ?? DbHeartRateZoneManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (lowerPercentage != null) {
      map['lowerPercentage'] = lowerPercentage;
    }

    if (upperPercentage != null) {
      map['upperPercentage'] = upperPercentage;
    }

    if (lowerLimit != null) {
      map['lowerLimit'] = lowerLimit;
    }

    if (upperLimit != null) {
      map['upperLimit'] = upperLimit;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (heartRateZoneSchemataId != null) {
      map['heartRateZoneSchemataId'] =
          forView ? plDbHeartRateZoneSchema.name : heartRateZoneSchemataId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (lowerPercentage != null) {
      map['lowerPercentage'] = lowerPercentage;
    }

    if (upperPercentage != null) {
      map['upperPercentage'] = upperPercentage;
    }

    if (lowerLimit != null) {
      map['lowerLimit'] = lowerLimit;
    }

    if (upperLimit != null) {
      map['upperLimit'] = upperLimit;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (heartRateZoneSchemataId != null) {
      map['heartRateZoneSchemataId'] =
          forView ? plDbHeartRateZoneSchema.name : heartRateZoneSchemataId;
    }

    return map;
  }

  /// This method returns Json String [DbHeartRateZone]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbHeartRateZone]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      name,
      lowerPercentage,
      upperPercentage,
      lowerLimit,
      upperLimit,
      color,
      heartRateZoneSchemataId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      lowerPercentage,
      upperPercentage,
      lowerLimit,
      upperLimit,
      color,
      heartRateZoneSchemataId
    ];
  }

  static Future<List<DbHeartRateZone>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbHeartRateZone.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbHeartRateZone>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbHeartRateZone>[];
    try {
      objList = list
          .map((dbheartratezone) =>
              DbHeartRateZone.fromMap(dbheartratezone as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbHeartRateZone.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbHeartRateZone>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbHeartRateZone> objList = <DbHeartRateZone>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbHeartRateZone.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('heartRateZoneSchemata.plDbHeartRateZoneSchema') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbHeartRateZoneSchema'))) {
          /*_loadedFields.add('heartRateZoneSchemata.plDbHeartRateZoneSchema');*/
          obj.plDbHeartRateZoneSchema = obj.plDbHeartRateZoneSchema ??
              await obj.getDbHeartRateZoneSchema(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbHeartRateZone by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbHeartRateZone if exist, otherwise returns null
  Future<DbHeartRateZone> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbHeartRateZone obj;
    final data = await _mnDbHeartRateZone.getById([id]);
    if (data.length != 0) {
      obj = DbHeartRateZone.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('heartRateZoneSchemata.plDbHeartRateZoneSchema') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbHeartRateZoneSchema'))) {
          /*_loadedFields.add('heartRateZoneSchemata.plDbHeartRateZoneSchema');*/
          obj.plDbHeartRateZoneSchema = obj.plDbHeartRateZoneSchema ??
              await obj.getDbHeartRateZoneSchema(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbHeartRateZone) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbHeartRateZone.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbHeartRateZone.update(this);
    }

    return id;
  }

  /// saveAs DbHeartRateZone. Returns a new Primary Key value of DbHeartRateZone

  /// <returns>Returns a new Primary Key value of DbHeartRateZone
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbHeartRateZone> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<DbHeartRateZone> dbheartratezones) async {
    // final results = _mnDbHeartRateZone.saveAll('INSERT OR REPLACE INTO heartRateZone (id,name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, heartRateZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',dbheartratezones);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbheartratezones) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbheartratezones.length; i++) {
      if (dbheartratezones[i].id == null) {
        dbheartratezones[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbHeartRateZone.rawInsert(
              'INSERT OR REPLACE INTO heartRateZone (id,name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, heartRateZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',
              [
                id,
                name,
                lowerPercentage,
                upperPercentage,
                lowerLimit,
                upperLimit,
                color,
                heartRateZoneSchemataId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbHeartRateZone id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DbHeartRateZone id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbHeartRateZone Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbHeartRateZone>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<DbHeartRateZone> dbheartratezones) async {
    final results = await _mnDbHeartRateZone.rawInsertAll(
        'INSERT OR REPLACE INTO heartRateZone (id,name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, heartRateZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',
        dbheartratezones);
    return results;
  }

  /// Deletes DbHeartRateZone

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbHeartRateZone invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbHeartRateZone
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbHeartRateZone.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbHeartRateZoneFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbHeartRateZoneFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbHeartRateZoneFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbHeartRateZoneFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    heartRateZoneSchemataId = heartRateZoneSchemataId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbheartratezone

// region DbHeartRateZoneField
class DbHeartRateZoneField extends SearchCriteria {
  DbHeartRateZoneField(this.dbheartratezoneFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbHeartRateZoneFilterBuilder dbheartratezoneFB;

  DbHeartRateZoneField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbHeartRateZoneFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.EQuals, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.NotEQuals, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder isNull() {
    dbheartratezoneFB._addedBlocks = setCriteria(
        0,
        dbheartratezoneFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbheartratezoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneFB
              ._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
          dbheartratezoneFB._addedBlocks.retVal;
    }
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbheartratezoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneFB
              ._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
          dbheartratezoneFB._addedBlocks.retVal;
      dbheartratezoneFB
              ._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
          dbheartratezoneFB._addedBlocks.retVal;
    }
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbheartratezoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneFB
              ._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
          dbheartratezoneFB._addedBlocks.retVal;
    }
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbheartratezoneFB._addedBlocks = setCriteria(
          pFirst,
          dbheartratezoneFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbheartratezoneFB._addedBlocks = setCriteria(
            pFirst,
            dbheartratezoneFB.parameters,
            param,
            SqlSyntax.LessThan,
            dbheartratezoneFB._addedBlocks);
      } else {
        dbheartratezoneFB._addedBlocks = setCriteria(
            pFirst,
            dbheartratezoneFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbheartratezoneFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbheartratezoneFB._addedBlocks = setCriteria(
            pLast,
            dbheartratezoneFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            dbheartratezoneFB._addedBlocks);
      } else {
        dbheartratezoneFB._addedBlocks = setCriteria(
            pLast,
            dbheartratezoneFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            dbheartratezoneFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.GreaterThan, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.LessThan, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.LessThan, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.GreaterThan, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder inValues(dynamic pValue) {
    dbheartratezoneFB._addedBlocks = setCriteria(
        pValue,
        dbheartratezoneFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }
}
// endregion DbHeartRateZoneField

// region DbHeartRateZoneFilterBuilder
class DbHeartRateZoneFilterBuilder extends SearchCriteria {
  DbHeartRateZoneFilterBuilder(DbHeartRateZone obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbHeartRateZone _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbHeartRateZoneFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbHeartRateZoneFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbHeartRateZoneFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbHeartRateZoneFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbHeartRateZoneFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbHeartRateZoneFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbHeartRateZoneFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbHeartRateZoneFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbHeartRateZoneFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbHeartRateZoneFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbHeartRateZoneFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbHeartRateZoneField setField(
      DbHeartRateZoneField field, String colName, DbType dbtype) {
    return DbHeartRateZoneField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbHeartRateZoneField _id;
  DbHeartRateZoneField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbHeartRateZoneField _name;
  DbHeartRateZoneField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbHeartRateZoneField _lowerPercentage;
  DbHeartRateZoneField get lowerPercentage {
    return _lowerPercentage =
        setField(_lowerPercentage, 'lowerPercentage', DbType.integer);
  }

  DbHeartRateZoneField _upperPercentage;
  DbHeartRateZoneField get upperPercentage {
    return _upperPercentage =
        setField(_upperPercentage, 'upperPercentage', DbType.integer);
  }

  DbHeartRateZoneField _lowerLimit;
  DbHeartRateZoneField get lowerLimit {
    return _lowerLimit = setField(_lowerLimit, 'lowerLimit', DbType.integer);
  }

  DbHeartRateZoneField _upperLimit;
  DbHeartRateZoneField get upperLimit {
    return _upperLimit = setField(_upperLimit, 'upperLimit', DbType.integer);
  }

  DbHeartRateZoneField _color;
  DbHeartRateZoneField get color {
    return _color = setField(_color, 'color', DbType.integer);
  }

  DbHeartRateZoneField _heartRateZoneSchemataId;
  DbHeartRateZoneField get heartRateZoneSchemataId {
    return _heartRateZoneSchemataId = setField(
        _heartRateZoneSchemataId, 'heartRateZoneSchemataId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbHeartRateZone._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbHeartRateZone> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (DbHeartRateZone._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbHeartRateZone.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbHeartRateZone.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from heartRateZone ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbHeartRateZone.updateBatch(qparams, values);
  }

  /// This method always returns DbHeartRateZone Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbHeartRateZone>
  Future<DbHeartRateZone> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbHeartRateZone.toList(qparams);
    final data = await objFuture;
    DbHeartRateZone obj;
    if (data.isNotEmpty) {
      obj = DbHeartRateZone.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('heartRateZoneSchemata.plDbHeartRateZoneSchema') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbHeartRateZoneSchema'))) {
          /*_loadedFields.add('heartRateZoneSchemata.plDbHeartRateZoneSchema');*/
          obj.plDbHeartRateZoneSchema = obj.plDbHeartRateZoneSchema ??
              await obj.getDbHeartRateZoneSchema(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbHeartRateZone]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) dbheartratezoneCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbheartratezonesFuture =
        await _obj._mnDbHeartRateZone.toList(qparams);
    final int count = dbheartratezonesFuture[0]['CNT'] as int;
    if (dbheartratezoneCount != null) {
      dbheartratezoneCount(count);
    }
    return count;
  }

  /// This method returns List<DbHeartRateZone> [DbHeartRateZone]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbHeartRateZone>
  Future<List<DbHeartRateZone>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbHeartRateZone> dbheartratezonesData =
        await DbHeartRateZone.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return dbheartratezonesData;
  }

  /// This method returns Json String [DbHeartRateZone]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbHeartRateZone]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbHeartRateZone]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbHeartRateZone.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbHeartRateZone]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM heartRateZone WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbHeartRateZone.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbHeartRateZone]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbHeartRateZone.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbHeartRateZone.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbHeartRateZone.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbHeartRateZoneFilterBuilder

// region DbHeartRateZoneFields
class DbHeartRateZoneFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fLowerPercentage;
  static TableField get lowerPercentage {
    return _fLowerPercentage = _fLowerPercentage ??
        SqlSyntax.setField(
            _fLowerPercentage, 'lowerPercentage', DbType.integer);
  }

  static TableField _fUpperPercentage;
  static TableField get upperPercentage {
    return _fUpperPercentage = _fUpperPercentage ??
        SqlSyntax.setField(
            _fUpperPercentage, 'upperPercentage', DbType.integer);
  }

  static TableField _fLowerLimit;
  static TableField get lowerLimit {
    return _fLowerLimit = _fLowerLimit ??
        SqlSyntax.setField(_fLowerLimit, 'lowerLimit', DbType.integer);
  }

  static TableField _fUpperLimit;
  static TableField get upperLimit {
    return _fUpperLimit = _fUpperLimit ??
        SqlSyntax.setField(_fUpperLimit, 'upperLimit', DbType.integer);
  }

  static TableField _fColor;
  static TableField get color {
    return _fColor =
        _fColor ?? SqlSyntax.setField(_fColor, 'color', DbType.integer);
  }

  static TableField _fHeartRateZoneSchemataId;
  static TableField get heartRateZoneSchemataId {
    return _fHeartRateZoneSchemataId = _fHeartRateZoneSchemataId ??
        SqlSyntax.setField(_fHeartRateZoneSchemataId, 'heartRateZoneSchemataId',
            DbType.integer);
  }
}
// endregion DbHeartRateZoneFields

//region DbHeartRateZoneManager
class DbHeartRateZoneManager extends SqfEntityProvider {
  DbHeartRateZoneManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'heartRateZone';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbHeartRateZoneManager
// region DbPowerZoneSchema
class DbPowerZoneSchema {
  DbPowerZoneSchema(
      {this.id, this.date, this.name, this.base, this.athletesId}) {
    _setDefaultValues();
  }
  DbPowerZoneSchema.withFields(
      this.date, this.name, this.base, this.athletesId) {
    _setDefaultValues();
  }
  DbPowerZoneSchema.withId(
      this.id, this.date, this.name, this.base, this.athletesId) {
    _setDefaultValues();
  }
  DbPowerZoneSchema.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['date'] != null) {
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['date'].toString()))
          : DateTime.tryParse(o['date'].toString());
    }
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['base'] != null) {
      base = int.tryParse(o['base'].toString());
    }
    athletesId = int.tryParse(o['athletesId'].toString());

    // RELATIONSHIPS FromMAP
    plDbAthlete = o['dbAthlete'] != null
        ? DbAthlete.fromMap(o['dbAthlete'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbPowerZoneSchema)
  int id;
  DateTime date;
  String name;
  int base;
  int athletesId;

  BoolResult saveResult;
  // end FIELDS (DbPowerZoneSchema)

// RELATIONSHIPS (DbPowerZoneSchema)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbAthlete', 'plField2'..]) or so on..
  DbAthlete plDbAthlete;

  /// get DbAthlete By AthletesId
  Future<DbAthlete> getDbAthlete(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbAthlete().getById(athletesId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbPowerZoneSchema)

// COLLECTIONS & VIRTUALS (DbPowerZoneSchema)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbPowerZones', 'plField2'..]) or so on..
  List<DbPowerZone> plDbPowerZones;

  /// get DbPowerZone(s) filtered by id=powerZoneSchemataId
  DbPowerZoneFilterBuilder getDbPowerZones(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbPowerZone()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .powerZoneSchemataId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (DbPowerZoneSchema)

  static const bool _softDeleteActivated = false;
  DbPowerZoneSchemaManager __mnDbPowerZoneSchema;

  DbPowerZoneSchemaManager get _mnDbPowerZoneSchema {
    return __mnDbPowerZoneSchema =
        __mnDbPowerZoneSchema ?? DbPowerZoneSchemaManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (base != null) {
      map['base'] = base;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (base != null) {
      map['base'] = base;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

// COLLECTIONS (DbPowerZoneSchema)
    if (!forQuery) {
      map['DbPowerZones'] = await getDbPowerZones().toMapList();
    }
// END COLLECTIONS (DbPowerZoneSchema)

    return map;
  }

  /// This method returns Json String [DbPowerZoneSchema]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbPowerZoneSchema]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [date, name, base, athletesId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, date, name, base, athletesId];
  }

  static Future<List<DbPowerZoneSchema>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbPowerZoneSchema.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbPowerZoneSchema>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbPowerZoneSchema>[];
    try {
      objList = list
          .map((dbpowerzoneschema) => DbPowerZoneSchema.fromMap(
              dbpowerzoneschema as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbPowerZoneSchema.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbPowerZoneSchema>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbPowerZoneSchema> objList = <DbPowerZoneSchema>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbPowerZoneSchema.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('powerZoneSchemata.plDbPowerZones') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbPowerZones'))) {
          /*_loadedFields.add('powerZoneSchemata.plDbPowerZones'); */
          obj.plDbPowerZones = obj.plDbPowerZones ??
              await obj.getDbPowerZones().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbPowerZoneSchema by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbPowerZoneSchema if exist, otherwise returns null
  Future<DbPowerZoneSchema> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbPowerZoneSchema obj;
    final data = await _mnDbPowerZoneSchema.getById([id]);
    if (data.length != 0) {
      obj = DbPowerZoneSchema.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('powerZoneSchemata.plDbPowerZones') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbPowerZones'))) {
          /*_loadedFields.add('powerZoneSchemata.plDbPowerZones'); */
          obj.plDbPowerZones = obj.plDbPowerZones ??
              await obj.getDbPowerZones().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbPowerZoneSchema) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbPowerZoneSchema.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbPowerZoneSchema.update(this);
    }

    return id;
  }

  /// saveAs DbPowerZoneSchema. Returns a new Primary Key value of DbPowerZoneSchema

  /// <returns>Returns a new Primary Key value of DbPowerZoneSchema
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbPowerZoneSchema> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<DbPowerZoneSchema> dbpowerzoneschemas) async {
    // final results = _mnDbPowerZoneSchema.saveAll('INSERT OR REPLACE INTO powerZoneSchemata (id,date, name, base, athletesId)  VALUES (?,?,?,?,?)',dbpowerzoneschemas);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbpowerzoneschemas) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbpowerzoneschemas.length; i++) {
      if (dbpowerzoneschemas[i].id == null) {
        dbpowerzoneschemas[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbPowerZoneSchema.rawInsert(
              'INSERT OR REPLACE INTO powerZoneSchemata (id,date, name, base, athletesId)  VALUES (?,?,?,?,?)',
              [id, date, name, base, athletesId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbPowerZoneSchema id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DbPowerZoneSchema id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'DbPowerZoneSchema Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbPowerZoneSchema>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<DbPowerZoneSchema> dbpowerzoneschemas) async {
    final results = await _mnDbPowerZoneSchema.rawInsertAll(
        'INSERT OR REPLACE INTO powerZoneSchemata (id,date, name, base, athletesId)  VALUES (?,?,?,?,?)',
        dbpowerzoneschemas);
    return results;
  }

  /// Deletes DbPowerZoneSchema

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbPowerZoneSchema invoked (id=$id)');
    var result = BoolResult();
    {
      result = await DbPowerZone()
          .select()
          .powerZoneSchemataId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbPowerZoneSchema
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbPowerZoneSchema.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbPowerZoneSchemaFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbPowerZoneSchemaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbPowerZoneSchemaFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbPowerZoneSchemaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    athletesId = athletesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbpowerzoneschema

// region DbPowerZoneSchemaField
class DbPowerZoneSchemaField extends SearchCriteria {
  DbPowerZoneSchemaField(this.dbpowerzoneschemaFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbPowerZoneSchemaFilterBuilder dbpowerzoneschemaFB;

  DbPowerZoneSchemaField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbPowerZoneSchemaFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.EQuals, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.NotEQuals, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder isNull() {
    dbpowerzoneschemaFB._addedBlocks = setCriteria(
        0,
        dbpowerzoneschemaFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneschemaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbpowerzoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneschemaFB
              ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
          dbpowerzoneschemaFB._addedBlocks.retVal;
    }
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneschemaFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbpowerzoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneschemaFB
              ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
          dbpowerzoneschemaFB._addedBlocks.retVal;
      dbpowerzoneschemaFB
              ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
          dbpowerzoneschemaFB._addedBlocks.retVal;
    }
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneschemaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbpowerzoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneschemaFB
              ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
          dbpowerzoneschemaFB._addedBlocks.retVal;
    }
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbpowerzoneschemaFB._addedBlocks = setCriteria(
          pFirst,
          dbpowerzoneschemaFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneschemaFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbpowerzoneschemaFB._addedBlocks = setCriteria(
            pFirst,
            dbpowerzoneschemaFB.parameters,
            param,
            SqlSyntax.LessThan,
            dbpowerzoneschemaFB._addedBlocks);
      } else {
        dbpowerzoneschemaFB._addedBlocks = setCriteria(
            pFirst,
            dbpowerzoneschemaFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbpowerzoneschemaFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbpowerzoneschemaFB._addedBlocks = setCriteria(
            pLast,
            dbpowerzoneschemaFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            dbpowerzoneschemaFB._addedBlocks);
      } else {
        dbpowerzoneschemaFB._addedBlocks = setCriteria(
            pLast,
            dbpowerzoneschemaFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            dbpowerzoneschemaFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.GreaterThan, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.LessThan, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.LessThan, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.GreaterThan, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder inValues(dynamic pValue) {
    dbpowerzoneschemaFB._addedBlocks = setCriteria(
        pValue,
        dbpowerzoneschemaFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }
}
// endregion DbPowerZoneSchemaField

// region DbPowerZoneSchemaFilterBuilder
class DbPowerZoneSchemaFilterBuilder extends SearchCriteria {
  DbPowerZoneSchemaFilterBuilder(DbPowerZoneSchema obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbPowerZoneSchema _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbPowerZoneSchemaFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbPowerZoneSchemaFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbPowerZoneSchemaFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbPowerZoneSchemaFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbPowerZoneSchemaFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbPowerZoneSchemaFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbPowerZoneSchemaFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbPowerZoneSchemaFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbPowerZoneSchemaFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbPowerZoneSchemaFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbPowerZoneSchemaFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbPowerZoneSchemaField setField(
      DbPowerZoneSchemaField field, String colName, DbType dbtype) {
    return DbPowerZoneSchemaField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbPowerZoneSchemaField _id;
  DbPowerZoneSchemaField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbPowerZoneSchemaField _date;
  DbPowerZoneSchemaField get date {
    return _date = setField(_date, 'date', DbType.date);
  }

  DbPowerZoneSchemaField _name;
  DbPowerZoneSchemaField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbPowerZoneSchemaField _base;
  DbPowerZoneSchemaField get base {
    return _base = setField(_base, 'base', DbType.integer);
  }

  DbPowerZoneSchemaField _athletesId;
  DbPowerZoneSchemaField get athletesId {
    return _athletesId = setField(_athletesId, 'athletesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbPowerZoneSchema._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbPowerZoneSchema> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Delete sub records where in (DbPowerZone) according to DeleteRule.CASCADE
    final idListDbPowerZoneBYpowerZoneSchemataId = toListPrimaryKeySQL(false);
    final resDbPowerZoneBYpowerZoneSchemataId = await DbPowerZone()
        .select()
        .where(
            'powerZoneSchemataId IN (${idListDbPowerZoneBYpowerZoneSchemataId['sql']})',
            parameterValue: idListDbPowerZoneBYpowerZoneSchemataId['args'])
        .delete(hardDelete);
    if (!resDbPowerZoneBYpowerZoneSchemataId.success) {
      return resDbPowerZoneBYpowerZoneSchemataId;
    }

    if (DbPowerZoneSchema._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbPowerZoneSchema
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbPowerZoneSchema.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from powerZoneSchemata ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbPowerZoneSchema.updateBatch(qparams, values);
  }

  /// This method always returns DbPowerZoneSchema Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbPowerZoneSchema>
  Future<DbPowerZoneSchema> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbPowerZoneSchema.toList(qparams);
    final data = await objFuture;
    DbPowerZoneSchema obj;
    if (data.isNotEmpty) {
      obj = DbPowerZoneSchema.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('powerZoneSchemata.plDbPowerZones') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbPowerZones'))) {
          /*_loadedFields.add('powerZoneSchemata.plDbPowerZones'); */
          obj.plDbPowerZones = obj.plDbPowerZones ??
              await obj.getDbPowerZones().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbPowerZoneSchema]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) dbpowerzoneschemaCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbpowerzoneschemasFuture =
        await _obj._mnDbPowerZoneSchema.toList(qparams);
    final int count = dbpowerzoneschemasFuture[0]['CNT'] as int;
    if (dbpowerzoneschemaCount != null) {
      dbpowerzoneschemaCount(count);
    }
    return count;
  }

  /// This method returns List<DbPowerZoneSchema> [DbPowerZoneSchema]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbPowerZoneSchema>
  Future<List<DbPowerZoneSchema>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbPowerZoneSchema> dbpowerzoneschemasData =
        await DbPowerZoneSchema.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return dbpowerzoneschemasData;
  }

  /// This method returns Json String [DbPowerZoneSchema]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbPowerZoneSchema]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbPowerZoneSchema]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbPowerZoneSchema.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbPowerZoneSchema]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM powerZoneSchemata WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbPowerZoneSchema.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbPowerZoneSchema]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbPowerZoneSchema.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbPowerZoneSchema.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbPowerZoneSchema.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbPowerZoneSchemaFilterBuilder

// region DbPowerZoneSchemaFields
class DbPowerZoneSchemaFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fDate;
  static TableField get date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.date);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fBase;
  static TableField get base {
    return _fBase =
        _fBase ?? SqlSyntax.setField(_fBase, 'base', DbType.integer);
  }

  static TableField _fAthletesId;
  static TableField get athletesId {
    return _fAthletesId = _fAthletesId ??
        SqlSyntax.setField(_fAthletesId, 'athletesId', DbType.integer);
  }
}
// endregion DbPowerZoneSchemaFields

//region DbPowerZoneSchemaManager
class DbPowerZoneSchemaManager extends SqfEntityProvider {
  DbPowerZoneSchemaManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'powerZoneSchemata';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbPowerZoneSchemaManager
// region DbPowerZone
class DbPowerZone {
  DbPowerZone(
      {this.id,
      this.name,
      this.lowerPercentage,
      this.upperPercentage,
      this.lowerLimit,
      this.upperLimit,
      this.color,
      this.powerZoneSchemataId}) {
    _setDefaultValues();
  }
  DbPowerZone.withFields(this.name, this.lowerPercentage, this.upperPercentage,
      this.lowerLimit, this.upperLimit, this.color, this.powerZoneSchemataId) {
    _setDefaultValues();
  }
  DbPowerZone.withId(
      this.id,
      this.name,
      this.lowerPercentage,
      this.upperPercentage,
      this.lowerLimit,
      this.upperLimit,
      this.color,
      this.powerZoneSchemataId) {
    _setDefaultValues();
  }
  DbPowerZone.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['lowerPercentage'] != null) {
      lowerPercentage = int.tryParse(o['lowerPercentage'].toString());
    }
    if (o['upperPercentage'] != null) {
      upperPercentage = int.tryParse(o['upperPercentage'].toString());
    }
    if (o['lowerLimit'] != null) {
      lowerLimit = int.tryParse(o['lowerLimit'].toString());
    }
    if (o['upperLimit'] != null) {
      upperLimit = int.tryParse(o['upperLimit'].toString());
    }
    if (o['color'] != null) {
      color = int.tryParse(o['color'].toString());
    }
    powerZoneSchemataId = int.tryParse(o['powerZoneSchemataId'].toString());

    // RELATIONSHIPS FromMAP
    plDbPowerZoneSchema = o['dbPowerZoneSchema'] != null
        ? DbPowerZoneSchema.fromMap(
            o['dbPowerZoneSchema'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbPowerZone)
  int id;
  String name;
  int lowerPercentage;
  int upperPercentage;
  int lowerLimit;
  int upperLimit;
  int color;
  int powerZoneSchemataId;

  BoolResult saveResult;
  // end FIELDS (DbPowerZone)

// RELATIONSHIPS (DbPowerZone)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbPowerZoneSchema', 'plField2'..]) or so on..
  DbPowerZoneSchema plDbPowerZoneSchema;

  /// get DbPowerZoneSchema By PowerZoneSchemataId
  Future<DbPowerZoneSchema> getDbPowerZoneSchema(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbPowerZoneSchema().getById(powerZoneSchemataId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbPowerZone)

  static const bool _softDeleteActivated = false;
  DbPowerZoneManager __mnDbPowerZone;

  DbPowerZoneManager get _mnDbPowerZone {
    return __mnDbPowerZone = __mnDbPowerZone ?? DbPowerZoneManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (lowerPercentage != null) {
      map['lowerPercentage'] = lowerPercentage;
    }

    if (upperPercentage != null) {
      map['upperPercentage'] = upperPercentage;
    }

    if (lowerLimit != null) {
      map['lowerLimit'] = lowerLimit;
    }

    if (upperLimit != null) {
      map['upperLimit'] = upperLimit;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (powerZoneSchemataId != null) {
      map['powerZoneSchemataId'] =
          forView ? plDbPowerZoneSchema.name : powerZoneSchemataId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (lowerPercentage != null) {
      map['lowerPercentage'] = lowerPercentage;
    }

    if (upperPercentage != null) {
      map['upperPercentage'] = upperPercentage;
    }

    if (lowerLimit != null) {
      map['lowerLimit'] = lowerLimit;
    }

    if (upperLimit != null) {
      map['upperLimit'] = upperLimit;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (powerZoneSchemataId != null) {
      map['powerZoneSchemataId'] =
          forView ? plDbPowerZoneSchema.name : powerZoneSchemataId;
    }

    return map;
  }

  /// This method returns Json String [DbPowerZone]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbPowerZone]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [
      name,
      lowerPercentage,
      upperPercentage,
      lowerLimit,
      upperLimit,
      color,
      powerZoneSchemataId
    ];
  }

  List<dynamic> toArgsWithIds() {
    return [
      id,
      name,
      lowerPercentage,
      upperPercentage,
      lowerLimit,
      upperLimit,
      color,
      powerZoneSchemataId
    ];
  }

  static Future<List<DbPowerZone>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbPowerZone.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbPowerZone>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbPowerZone>[];
    try {
      objList = list
          .map((dbpowerzone) =>
              DbPowerZone.fromMap(dbpowerzone as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbPowerZone.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbPowerZone>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbPowerZone> objList = <DbPowerZone>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbPowerZone.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('powerZoneSchemata.plDbPowerZoneSchema') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbPowerZoneSchema'))) {
          /*_loadedFields.add('powerZoneSchemata.plDbPowerZoneSchema');*/
          obj.plDbPowerZoneSchema = obj.plDbPowerZoneSchema ??
              await obj.getDbPowerZoneSchema(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbPowerZone by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbPowerZone if exist, otherwise returns null
  Future<DbPowerZone> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbPowerZone obj;
    final data = await _mnDbPowerZone.getById([id]);
    if (data.length != 0) {
      obj = DbPowerZone.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('powerZoneSchemata.plDbPowerZoneSchema') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbPowerZoneSchema'))) {
          /*_loadedFields.add('powerZoneSchemata.plDbPowerZoneSchema');*/
          obj.plDbPowerZoneSchema = obj.plDbPowerZoneSchema ??
              await obj.getDbPowerZoneSchema(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbPowerZone) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbPowerZone.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbPowerZone.update(this);
    }

    return id;
  }

  /// saveAs DbPowerZone. Returns a new Primary Key value of DbPowerZone

  /// <returns>Returns a new Primary Key value of DbPowerZone
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbPowerZone> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DbPowerZone> dbpowerzones) async {
    // final results = _mnDbPowerZone.saveAll('INSERT OR REPLACE INTO powerZone (id,name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, powerZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',dbpowerzones);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbpowerzones) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbpowerzones.length; i++) {
      if (dbpowerzones[i].id == null) {
        dbpowerzones[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbPowerZone.rawInsert(
              'INSERT OR REPLACE INTO powerZone (id,name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, powerZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',
              [
                id,
                name,
                lowerPercentage,
                upperPercentage,
                lowerLimit,
                upperLimit,
                color,
                powerZoneSchemataId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbPowerZone id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbPowerZone id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbPowerZone Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbPowerZone>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<DbPowerZone> dbpowerzones) async {
    final results = await _mnDbPowerZone.rawInsertAll(
        'INSERT OR REPLACE INTO powerZone (id,name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, powerZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',
        dbpowerzones);
    return results;
  }

  /// Deletes DbPowerZone

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbPowerZone invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbPowerZone
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbPowerZone.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbPowerZoneFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbPowerZoneFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbPowerZoneFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbPowerZoneFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    powerZoneSchemataId = powerZoneSchemataId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbpowerzone

// region DbPowerZoneField
class DbPowerZoneField extends SearchCriteria {
  DbPowerZoneField(this.dbpowerzoneFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbPowerZoneFilterBuilder dbpowerzoneFB;

  DbPowerZoneField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbPowerZoneFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param, SqlSyntax.EQuals,
            dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.NotEQuals, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder isNull() {
    dbpowerzoneFB._addedBlocks = setCriteria(
        0,
        dbpowerzoneFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbpowerzoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
          dbpowerzoneFB._addedBlocks.retVal;
    }
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbpowerzoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
          dbpowerzoneFB._addedBlocks.retVal;
      dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
          dbpowerzoneFB._addedBlocks.retVal;
    }
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbpowerzoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
          dbpowerzoneFB._addedBlocks.retVal;
    }
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbpowerzoneFB._addedBlocks = setCriteria(
          pFirst,
          dbpowerzoneFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbpowerzoneFB._addedBlocks = setCriteria(
            pFirst,
            dbpowerzoneFB.parameters,
            param,
            SqlSyntax.LessThan,
            dbpowerzoneFB._addedBlocks);
      } else {
        dbpowerzoneFB._addedBlocks = setCriteria(
            pFirst,
            dbpowerzoneFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbpowerzoneFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbpowerzoneFB._addedBlocks = setCriteria(
            pLast,
            dbpowerzoneFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            dbpowerzoneFB._addedBlocks);
      } else {
        dbpowerzoneFB._addedBlocks = setCriteria(
            pLast,
            dbpowerzoneFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            dbpowerzoneFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.GreaterThan, dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.LessThan, dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.LessThan, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.GreaterThan, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder inValues(dynamic pValue) {
    dbpowerzoneFB._addedBlocks = setCriteria(
        pValue,
        dbpowerzoneFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }
}
// endregion DbPowerZoneField

// region DbPowerZoneFilterBuilder
class DbPowerZoneFilterBuilder extends SearchCriteria {
  DbPowerZoneFilterBuilder(DbPowerZone obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbPowerZone _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbPowerZoneFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbPowerZoneFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbPowerZoneFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbPowerZoneFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbPowerZoneFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbPowerZoneFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbPowerZoneFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbPowerZoneFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbPowerZoneFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbPowerZoneFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbPowerZoneFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbPowerZoneField setField(
      DbPowerZoneField field, String colName, DbType dbtype) {
    return DbPowerZoneField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbPowerZoneField _id;
  DbPowerZoneField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbPowerZoneField _name;
  DbPowerZoneField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbPowerZoneField _lowerPercentage;
  DbPowerZoneField get lowerPercentage {
    return _lowerPercentage =
        setField(_lowerPercentage, 'lowerPercentage', DbType.integer);
  }

  DbPowerZoneField _upperPercentage;
  DbPowerZoneField get upperPercentage {
    return _upperPercentage =
        setField(_upperPercentage, 'upperPercentage', DbType.integer);
  }

  DbPowerZoneField _lowerLimit;
  DbPowerZoneField get lowerLimit {
    return _lowerLimit = setField(_lowerLimit, 'lowerLimit', DbType.integer);
  }

  DbPowerZoneField _upperLimit;
  DbPowerZoneField get upperLimit {
    return _upperLimit = setField(_upperLimit, 'upperLimit', DbType.integer);
  }

  DbPowerZoneField _color;
  DbPowerZoneField get color {
    return _color = setField(_color, 'color', DbType.integer);
  }

  DbPowerZoneField _powerZoneSchemataId;
  DbPowerZoneField get powerZoneSchemataId {
    return _powerZoneSchemataId =
        setField(_powerZoneSchemataId, 'powerZoneSchemataId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbPowerZone._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbPowerZone> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (DbPowerZone._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbPowerZone.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbPowerZone.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from powerZone ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbPowerZone.updateBatch(qparams, values);
  }

  /// This method always returns DbPowerZone Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbPowerZone>
  Future<DbPowerZone> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbPowerZone.toList(qparams);
    final data = await objFuture;
    DbPowerZone obj;
    if (data.isNotEmpty) {
      obj = DbPowerZone.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('powerZoneSchemata.plDbPowerZoneSchema') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbPowerZoneSchema'))) {
          /*_loadedFields.add('powerZoneSchemata.plDbPowerZoneSchema');*/
          obj.plDbPowerZoneSchema = obj.plDbPowerZoneSchema ??
              await obj.getDbPowerZoneSchema(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbPowerZone]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbpowerzoneCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbpowerzonesFuture = await _obj._mnDbPowerZone.toList(qparams);
    final int count = dbpowerzonesFuture[0]['CNT'] as int;
    if (dbpowerzoneCount != null) {
      dbpowerzoneCount(count);
    }
    return count;
  }

  /// This method returns List<DbPowerZone> [DbPowerZone]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbPowerZone>
  Future<List<DbPowerZone>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbPowerZone> dbpowerzonesData = await DbPowerZone.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return dbpowerzonesData;
  }

  /// This method returns Json String [DbPowerZone]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbPowerZone]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbPowerZone]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbPowerZone.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbPowerZone]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM powerZone WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbPowerZone.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbPowerZone]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbPowerZone.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbPowerZone.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbPowerZone.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbPowerZoneFilterBuilder

// region DbPowerZoneFields
class DbPowerZoneFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fLowerPercentage;
  static TableField get lowerPercentage {
    return _fLowerPercentage = _fLowerPercentage ??
        SqlSyntax.setField(
            _fLowerPercentage, 'lowerPercentage', DbType.integer);
  }

  static TableField _fUpperPercentage;
  static TableField get upperPercentage {
    return _fUpperPercentage = _fUpperPercentage ??
        SqlSyntax.setField(
            _fUpperPercentage, 'upperPercentage', DbType.integer);
  }

  static TableField _fLowerLimit;
  static TableField get lowerLimit {
    return _fLowerLimit = _fLowerLimit ??
        SqlSyntax.setField(_fLowerLimit, 'lowerLimit', DbType.integer);
  }

  static TableField _fUpperLimit;
  static TableField get upperLimit {
    return _fUpperLimit = _fUpperLimit ??
        SqlSyntax.setField(_fUpperLimit, 'upperLimit', DbType.integer);
  }

  static TableField _fColor;
  static TableField get color {
    return _fColor =
        _fColor ?? SqlSyntax.setField(_fColor, 'color', DbType.integer);
  }

  static TableField _fPowerZoneSchemataId;
  static TableField get powerZoneSchemataId {
    return _fPowerZoneSchemataId = _fPowerZoneSchemataId ??
        SqlSyntax.setField(
            _fPowerZoneSchemataId, 'powerZoneSchemataId', DbType.integer);
  }
}
// endregion DbPowerZoneFields

//region DbPowerZoneManager
class DbPowerZoneManager extends SqfEntityProvider {
  DbPowerZoneManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'powerZone';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbPowerZoneManager
// region DbTag
class DbTag {
  DbTag(
      {this.id,
      this.name,
      this.color,
      this.sortOrder,
      this.system,
      this.tagGroupsId}) {
    _setDefaultValues();
  }
  DbTag.withFields(
      this.name, this.color, this.sortOrder, this.system, this.tagGroupsId) {
    _setDefaultValues();
  }
  DbTag.withId(this.id, this.name, this.color, this.sortOrder, this.system,
      this.tagGroupsId) {
    _setDefaultValues();
  }
  DbTag.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['color'] != null) {
      color = int.tryParse(o['color'].toString());
    }
    if (o['sortOrder'] != null) {
      sortOrder = int.tryParse(o['sortOrder'].toString());
    }
    if (o['system'] != null) {
      system = o['system'] == 1 || o['system'] == true;
    }
    tagGroupsId = int.tryParse(o['tagGroupsId'].toString());

    // RELATIONSHIPS FromMAP
    plDbTagGroup = o['dbTagGroup'] != null
        ? DbTagGroup.fromMap(o['dbTagGroup'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbTag)
  int id;
  String name;
  int color;
  int sortOrder;
  bool system;
  int tagGroupsId;

  BoolResult saveResult;
  // end FIELDS (DbTag)

// RELATIONSHIPS (DbTag)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbTagGroup', 'plField2'..]) or so on..
  DbTagGroup plDbTagGroup;

  /// get DbTagGroup By TagGroupsId
  Future<DbTagGroup> getDbTagGroup(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbTagGroup().getById(tagGroupsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbTag)

// COLLECTIONS & VIRTUALS (DbTag)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbLapTaggings', 'plField2'..]) or so on..
  List<DbLapTagging> plDbLapTaggings;

  /// get DbLapTagging(s) filtered by id=tagsId
  DbLapTaggingFilterBuilder getDbLapTaggings(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbLapTagging()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .tagsId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbActivityTaggings', 'plField2'..]) or so on..
  List<DbActivityTagging> plDbActivityTaggings;

  /// get DbActivityTagging(s) filtered by id=tagsId
  DbActivityTaggingFilterBuilder getDbActivityTaggings(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbActivityTagging()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .tagsId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbIntervalTaggings', 'plField2'..]) or so on..
  List<DbIntervalTagging> plDbIntervalTaggings;

  /// get DbIntervalTagging(s) filtered by id=tagsId
  DbIntervalTaggingFilterBuilder getDbIntervalTaggings(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbIntervalTagging()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .tagsId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (DbTag)

  static const bool _softDeleteActivated = false;
  DbTagManager __mnDbTag;

  DbTagManager get _mnDbTag {
    return __mnDbTag = __mnDbTag ?? DbTagManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (sortOrder != null) {
      map['sortOrder'] = sortOrder;
    }

    if (system != null) {
      map['system'] = forQuery ? (system ? 1 : 0) : system;
    }

    if (tagGroupsId != null) {
      map['tagGroupsId'] = forView ? plDbTagGroup.name : tagGroupsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (sortOrder != null) {
      map['sortOrder'] = sortOrder;
    }

    if (system != null) {
      map['system'] = forQuery ? (system ? 1 : 0) : system;
    }

    if (tagGroupsId != null) {
      map['tagGroupsId'] = forView ? plDbTagGroup.name : tagGroupsId;
    }

// COLLECTIONS (DbTag)
    if (!forQuery) {
      map['DbLapTaggings'] = await getDbLapTaggings().toMapList();
    }
    if (!forQuery) {
      map['DbActivityTaggings'] = await getDbActivityTaggings().toMapList();
    }
    if (!forQuery) {
      map['DbIntervalTaggings'] = await getDbIntervalTaggings().toMapList();
    }
// END COLLECTIONS (DbTag)

    return map;
  }

  /// This method returns Json String [DbTag]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbTag]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [name, color, sortOrder, system, tagGroupsId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name, color, sortOrder, system, tagGroupsId];
  }

  static Future<List<DbTag>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR DbTag.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbTag>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbTag>[];
    try {
      objList = list
          .map((dbtag) => DbTag.fromMap(dbtag as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR DbTag.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbTag>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbTag> objList = <DbTag>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbTag.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbLapTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbLapTaggings'))) {
          /*_loadedFields.add('tags.plDbLapTaggings'); */
          obj.plDbLapTaggings = obj.plDbLapTaggings ??
              await obj.getDbLapTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('tags.plDbActivityTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbActivityTaggings'))) {
          /*_loadedFields.add('tags.plDbActivityTaggings'); */
          obj.plDbActivityTaggings = obj.plDbActivityTaggings ??
              await obj.getDbActivityTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('tags.plDbIntervalTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervalTaggings'))) {
          /*_loadedFields.add('tags.plDbIntervalTaggings'); */
          obj.plDbIntervalTaggings = obj.plDbIntervalTaggings ??
              await obj.getDbIntervalTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tagGroups.plDbTagGroup') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTagGroup'))) {
          /*_loadedFields.add('tagGroups.plDbTagGroup');*/
          obj.plDbTagGroup = obj.plDbTagGroup ??
              await obj.getDbTagGroup(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbTag by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbTag if exist, otherwise returns null
  Future<DbTag> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbTag obj;
    final data = await _mnDbTag.getById([id]);
    if (data.length != 0) {
      obj = DbTag.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbLapTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbLapTaggings'))) {
          /*_loadedFields.add('tags.plDbLapTaggings'); */
          obj.plDbLapTaggings = obj.plDbLapTaggings ??
              await obj.getDbLapTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('tags.plDbActivityTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbActivityTaggings'))) {
          /*_loadedFields.add('tags.plDbActivityTaggings'); */
          obj.plDbActivityTaggings = obj.plDbActivityTaggings ??
              await obj.getDbActivityTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('tags.plDbIntervalTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervalTaggings'))) {
          /*_loadedFields.add('tags.plDbIntervalTaggings'); */
          obj.plDbIntervalTaggings = obj.plDbIntervalTaggings ??
              await obj.getDbIntervalTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tagGroups.plDbTagGroup') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTagGroup'))) {
          /*_loadedFields.add('tagGroups.plDbTagGroup');*/
          obj.plDbTagGroup = obj.plDbTagGroup ??
              await obj.getDbTagGroup(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbTag) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbTag.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbTag.update(this);
    }

    return id;
  }

  /// saveAs DbTag. Returns a new Primary Key value of DbTag

  /// <returns>Returns a new Primary Key value of DbTag
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbTag> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DbTag> dbtags) async {
    // final results = _mnDbTag.saveAll('INSERT OR REPLACE INTO tags (id,name, color, sortOrder, system, tagGroupsId)  VALUES (?,?,?,?,?,?)',dbtags);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbtags) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbtags.length; i++) {
      if (dbtags[i].id == null) {
        dbtags[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbTag.rawInsert(
              'INSERT OR REPLACE INTO tags (id,name, color, sortOrder, system, tagGroupsId)  VALUES (?,?,?,?,?,?)',
              [id, name, color, sortOrder, system, tagGroupsId]) ==
          1) {
        saveResult = BoolResult(
            success: true, successMessage: 'DbTag id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbTag id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbTag Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbTag>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<DbTag> dbtags) async {
    final results = await _mnDbTag.rawInsertAll(
        'INSERT OR REPLACE INTO tags (id,name, color, sortOrder, system, tagGroupsId)  VALUES (?,?,?,?,?,?)',
        dbtags);
    return results;
  }

  /// Deletes DbTag

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbTag invoked (id=$id)');
    var result = BoolResult();
    {
      result = await DbLapTagging()
          .select()
          .tagsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbActivityTagging()
          .select()
          .tagsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbIntervalTagging()
          .select()
          .tagsId
          .equals(id)
          .and
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbTag
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbTag.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbTagFilterBuilder select({List<String> columnsToSelect, bool getIsDeleted}) {
    return DbTagFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbTagFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbTagFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    tagGroupsId = tagGroupsId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbtag

// region DbTagField
class DbTagField extends SearchCriteria {
  DbTagField(this.dbtagFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbTagFilterBuilder dbtagFB;

  DbTagField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbTagFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbtagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtagFB.parameters, param, SqlSyntax.EQuals,
            dbtagFB._addedBlocks)
        : setCriteria(pValue, dbtagFB.parameters, param, SqlSyntax.NotEQuals,
            dbtagFB._addedBlocks);
    _waitingNot = '';
    dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
        dbtagFB._addedBlocks.retVal;
    return dbtagFB;
  }

  DbTagFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbtagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtagFB.parameters, param, SqlSyntax.EQualsOrNull,
            dbtagFB._addedBlocks)
        : setCriteria(pValue, dbtagFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbtagFB._addedBlocks);
    _waitingNot = '';
    dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
        dbtagFB._addedBlocks.retVal;
    return dbtagFB;
  }

  DbTagFilterBuilder isNull() {
    dbtagFB._addedBlocks = setCriteria(
        0,
        dbtagFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbtagFB._addedBlocks);
    _waitingNot = '';
    dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
        dbtagFB._addedBlocks.retVal;
    return dbtagFB;
  }

  DbTagFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbtagFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbtagFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbtagFB._addedBlocks);
      _waitingNot = '';
      dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
          dbtagFB._addedBlocks.retVal;
    }
    return dbtagFB;
  }

  DbTagFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbtagFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbtagFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbtagFB._addedBlocks);
      _waitingNot = '';
      dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
          dbtagFB._addedBlocks.retVal;
      dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
          dbtagFB._addedBlocks.retVal;
    }
    return dbtagFB;
  }

  DbTagFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbtagFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbtagFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbtagFB._addedBlocks);
      _waitingNot = '';
      dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
          dbtagFB._addedBlocks.retVal;
    }
    return dbtagFB;
  }

  DbTagFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbtagFB._addedBlocks = setCriteria(
          pFirst,
          dbtagFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbtagFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbtagFB._addedBlocks = setCriteria(pFirst, dbtagFB.parameters, param,
            SqlSyntax.LessThan, dbtagFB._addedBlocks);
      } else {
        dbtagFB._addedBlocks = setCriteria(pFirst, dbtagFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbtagFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbtagFB._addedBlocks = setCriteria(pLast, dbtagFB.parameters, param,
            SqlSyntax.GreaterThan, dbtagFB._addedBlocks);
      } else {
        dbtagFB._addedBlocks = setCriteria(pLast, dbtagFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbtagFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
        dbtagFB._addedBlocks.retVal;
    return dbtagFB;
  }

  DbTagFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbtagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtagFB.parameters, param, SqlSyntax.GreaterThan,
            dbtagFB._addedBlocks)
        : setCriteria(pValue, dbtagFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbtagFB._addedBlocks);
    _waitingNot = '';
    dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
        dbtagFB._addedBlocks.retVal;
    return dbtagFB;
  }

  DbTagFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbtagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtagFB.parameters, param, SqlSyntax.LessThan,
            dbtagFB._addedBlocks)
        : setCriteria(pValue, dbtagFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbtagFB._addedBlocks);
    _waitingNot = '';
    dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
        dbtagFB._addedBlocks.retVal;
    return dbtagFB;
  }

  DbTagFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbtagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtagFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbtagFB._addedBlocks)
        : setCriteria(pValue, dbtagFB.parameters, param, SqlSyntax.LessThan,
            dbtagFB._addedBlocks);
    _waitingNot = '';
    dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
        dbtagFB._addedBlocks.retVal;
    return dbtagFB;
  }

  DbTagFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbtagFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtagFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbtagFB._addedBlocks)
        : setCriteria(pValue, dbtagFB.parameters, param, SqlSyntax.GreaterThan,
            dbtagFB._addedBlocks);
    _waitingNot = '';
    dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
        dbtagFB._addedBlocks.retVal;
    return dbtagFB;
  }

  DbTagFilterBuilder inValues(dynamic pValue) {
    dbtagFB._addedBlocks = setCriteria(
        pValue,
        dbtagFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbtagFB._addedBlocks);
    _waitingNot = '';
    dbtagFB._addedBlocks.needEndBlock[dbtagFB._blockIndex] =
        dbtagFB._addedBlocks.retVal;
    return dbtagFB;
  }
}
// endregion DbTagField

// region DbTagFilterBuilder
class DbTagFilterBuilder extends SearchCriteria {
  DbTagFilterBuilder(DbTag obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbTag _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbTagFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbTagFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbTagFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbTagFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbTagFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbTagFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbTagFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbTagFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbTagFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbTagFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbTagFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbTagField setField(DbTagField field, String colName, DbType dbtype) {
    return DbTagField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbTagField _id;
  DbTagField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbTagField _name;
  DbTagField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbTagField _color;
  DbTagField get color {
    return _color = setField(_color, 'color', DbType.integer);
  }

  DbTagField _sortOrder;
  DbTagField get sortOrder {
    return _sortOrder = setField(_sortOrder, 'sortOrder', DbType.integer);
  }

  DbTagField _system;
  DbTagField get system {
    return _system = setField(_system, 'system', DbType.bool);
  }

  DbTagField _tagGroupsId;
  DbTagField get tagGroupsId {
    return _tagGroupsId = setField(_tagGroupsId, 'tagGroupsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbTag._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbTag> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Delete sub records where in (DbLapTagging) according to DeleteRule.CASCADE
    final idListDbLapTaggingBYtagsId = toListPrimaryKeySQL(false);
    final resDbLapTaggingBYtagsId = await DbLapTagging()
        .select()
        .where('tagsId IN (${idListDbLapTaggingBYtagsId['sql']})',
            parameterValue: idListDbLapTaggingBYtagsId['args'])
        .delete(hardDelete);
    if (!resDbLapTaggingBYtagsId.success) {
      return resDbLapTaggingBYtagsId;
    }
// Delete sub records where in (DbActivityTagging) according to DeleteRule.CASCADE
    final idListDbActivityTaggingBYtagsId = toListPrimaryKeySQL(false);
    final resDbActivityTaggingBYtagsId = await DbActivityTagging()
        .select()
        .where('tagsId IN (${idListDbActivityTaggingBYtagsId['sql']})',
            parameterValue: idListDbActivityTaggingBYtagsId['args'])
        .delete(hardDelete);
    if (!resDbActivityTaggingBYtagsId.success) {
      return resDbActivityTaggingBYtagsId;
    }
// Delete sub records where in (DbIntervalTagging) according to DeleteRule.CASCADE
    final idListDbIntervalTaggingBYtagsId = toListPrimaryKeySQL(false);
    final resDbIntervalTaggingBYtagsId = await DbIntervalTagging()
        .select()
        .where('tagsId IN (${idListDbIntervalTaggingBYtagsId['sql']})',
            parameterValue: idListDbIntervalTaggingBYtagsId['args'])
        .delete(hardDelete);
    if (!resDbIntervalTaggingBYtagsId.success) {
      return resDbIntervalTaggingBYtagsId;
    }

    if (DbTag._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbTag.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbTag.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from tags ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbTag.updateBatch(qparams, values);
  }

  /// This method always returns DbTag Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbTag>
  Future<DbTag> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbTag.toList(qparams);
    final data = await objFuture;
    DbTag obj;
    if (data.isNotEmpty) {
      obj = DbTag.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbLapTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbLapTaggings'))) {
          /*_loadedFields.add('tags.plDbLapTaggings'); */
          obj.plDbLapTaggings = obj.plDbLapTaggings ??
              await obj.getDbLapTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('tags.plDbActivityTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbActivityTaggings'))) {
          /*_loadedFields.add('tags.plDbActivityTaggings'); */
          obj.plDbActivityTaggings = obj.plDbActivityTaggings ??
              await obj.getDbActivityTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
        if (/*!_loadedFields.contains('tags.plDbIntervalTaggings') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbIntervalTaggings'))) {
          /*_loadedFields.add('tags.plDbIntervalTaggings'); */
          obj.plDbIntervalTaggings = obj.plDbIntervalTaggings ??
              await obj.getDbIntervalTaggings().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tagGroups.plDbTagGroup') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTagGroup'))) {
          /*_loadedFields.add('tagGroups.plDbTagGroup');*/
          obj.plDbTagGroup = obj.plDbTagGroup ??
              await obj.getDbTagGroup(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbTag]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbtagCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbtagsFuture = await _obj._mnDbTag.toList(qparams);
    final int count = dbtagsFuture[0]['CNT'] as int;
    if (dbtagCount != null) {
      dbtagCount(count);
    }
    return count;
  }

  /// This method returns List<DbTag> [DbTag]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbTag>
  Future<List<DbTag>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbTag> dbtagsData = await DbTag.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return dbtagsData;
  }

  /// This method returns Json String [DbTag]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbTag]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbTag]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbTag.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbTag]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM tags WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbTag.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbTag]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbTag.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbTag.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbTag.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbTagFilterBuilder

// region DbTagFields
class DbTagFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fColor;
  static TableField get color {
    return _fColor =
        _fColor ?? SqlSyntax.setField(_fColor, 'color', DbType.integer);
  }

  static TableField _fSortOrder;
  static TableField get sortOrder {
    return _fSortOrder = _fSortOrder ??
        SqlSyntax.setField(_fSortOrder, 'sortOrder', DbType.integer);
  }

  static TableField _fSystem;
  static TableField get system {
    return _fSystem =
        _fSystem ?? SqlSyntax.setField(_fSystem, 'system', DbType.bool);
  }

  static TableField _fTagGroupsId;
  static TableField get tagGroupsId {
    return _fTagGroupsId = _fTagGroupsId ??
        SqlSyntax.setField(_fTagGroupsId, 'tagGroupsId', DbType.integer);
  }
}
// endregion DbTagFields

//region DbTagManager
class DbTagManager extends SqfEntityProvider {
  DbTagManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'tags';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbTagManager
// region DbTagGroup
class DbTagGroup {
  DbTagGroup({this.id, this.name, this.color, this.system, this.athletesId}) {
    _setDefaultValues();
  }
  DbTagGroup.withFields(this.name, this.color, this.system, this.athletesId) {
    _setDefaultValues();
  }
  DbTagGroup.withId(
      this.id, this.name, this.color, this.system, this.athletesId) {
    _setDefaultValues();
  }
  DbTagGroup.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['name'] != null) {
      name = o['name'] as String;
    }
    if (o['color'] != null) {
      color = int.tryParse(o['color'].toString());
    }
    if (o['system'] != null) {
      system = o['system'] == 1 || o['system'] == true;
    }
    athletesId = int.tryParse(o['athletesId'].toString());

    // RELATIONSHIPS FromMAP
    plDbAthlete = o['dbAthlete'] != null
        ? DbAthlete.fromMap(o['dbAthlete'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbTagGroup)
  int id;
  String name;
  int color;
  bool system;
  int athletesId;

  BoolResult saveResult;
  // end FIELDS (DbTagGroup)

// RELATIONSHIPS (DbTagGroup)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbAthlete', 'plField2'..]) or so on..
  DbAthlete plDbAthlete;

  /// get DbAthlete By AthletesId
  Future<DbAthlete> getDbAthlete(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbAthlete().getById(athletesId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbTagGroup)

// COLLECTIONS & VIRTUALS (DbTagGroup)
  /// to load children of items to this field, use preload parameter. Ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbTags', 'plField2'..]) or so on..
  List<DbTag> plDbTags;

  /// get DbTag(s) filtered by id=tagGroupsId
  DbTagFilterBuilder getDbTags(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    if (id == null) {
      return null;
    }
    return DbTag()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .tagGroupsId
        .equals(id)
        .and;
  }

// END COLLECTIONS & VIRTUALS (DbTagGroup)

  static const bool _softDeleteActivated = false;
  DbTagGroupManager __mnDbTagGroup;

  DbTagGroupManager get _mnDbTagGroup {
    return __mnDbTagGroup = __mnDbTagGroup ?? DbTagGroupManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (system != null) {
      map['system'] = forQuery ? (system ? 1 : 0) : system;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (system != null) {
      map['system'] = forQuery ? (system ? 1 : 0) : system;
    }

    if (athletesId != null) {
      map['athletesId'] = forView ? plDbAthlete.state : athletesId;
    }

// COLLECTIONS (DbTagGroup)
    if (!forQuery) {
      map['DbTags'] = await getDbTags().toMapList();
    }
// END COLLECTIONS (DbTagGroup)

    return map;
  }

  /// This method returns Json String [DbTagGroup]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbTagGroup]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [name, color, system, athletesId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, name, color, system, athletesId];
  }

  static Future<List<DbTagGroup>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbTagGroup.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbTagGroup>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbTagGroup>[];
    try {
      objList = list
          .map((dbtaggroup) =>
              DbTagGroup.fromMap(dbtaggroup as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbTagGroup.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbTagGroup>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbTagGroup> objList = <DbTagGroup>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbTagGroup.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tagGroups.plDbTags') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbTags'))) {
          /*_loadedFields.add('tagGroups.plDbTags'); */
          obj.plDbTags = obj.plDbTags ??
              await obj.getDbTags().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbTagGroup by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbTagGroup if exist, otherwise returns null
  Future<DbTagGroup> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbTagGroup obj;
    final data = await _mnDbTagGroup.getById([id]);
    if (data.length != 0) {
      obj = DbTagGroup.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tagGroups.plDbTags') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbTags'))) {
          /*_loadedFields.add('tagGroups.plDbTags'); */
          obj.plDbTags = obj.plDbTags ??
              await obj.getDbTags().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbTagGroup) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbTagGroup.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbTagGroup.update(this);
    }

    return id;
  }

  /// saveAs DbTagGroup. Returns a new Primary Key value of DbTagGroup

  /// <returns>Returns a new Primary Key value of DbTagGroup
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbTagGroup> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DbTagGroup> dbtaggroups) async {
    // final results = _mnDbTagGroup.saveAll('INSERT OR REPLACE INTO tagGroups (id,name, color, system, athletesId)  VALUES (?,?,?,?,?)',dbtaggroups);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbtaggroups) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbtaggroups.length; i++) {
      if (dbtaggroups[i].id == null) {
        dbtaggroups[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbTagGroup.rawInsert(
              'INSERT OR REPLACE INTO tagGroups (id,name, color, system, athletesId)  VALUES (?,?,?,?,?)',
              [id, name, color, system, athletesId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbTagGroup id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbTagGroup id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbTagGroup Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbTagGroup>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<DbTagGroup> dbtaggroups) async {
    final results = await _mnDbTagGroup.rawInsertAll(
        'INSERT OR REPLACE INTO tagGroups (id,name, color, system, athletesId)  VALUES (?,?,?,?,?)',
        dbtaggroups);
    return results;
  }

  /// Deletes DbTagGroup

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbTagGroup invoked (id=$id)');
    var result = BoolResult();
    {
      result =
          await DbTag().select().tagGroupsId.equals(id).and.delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbTagGroup
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbTagGroup.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbTagGroupFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbTagGroupFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbTagGroupFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbTagGroupFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    athletesId = athletesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbtaggroup

// region DbTagGroupField
class DbTagGroupField extends SearchCriteria {
  DbTagGroupField(this.dbtaggroupFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbTagGroupFilterBuilder dbtaggroupFB;

  DbTagGroupField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbTagGroupFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbtaggroupFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtaggroupFB.parameters, param, SqlSyntax.EQuals,
            dbtaggroupFB._addedBlocks)
        : setCriteria(pValue, dbtaggroupFB.parameters, param,
            SqlSyntax.NotEQuals, dbtaggroupFB._addedBlocks);
    _waitingNot = '';
    dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
        dbtaggroupFB._addedBlocks.retVal;
    return dbtaggroupFB;
  }

  DbTagGroupFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbtaggroupFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtaggroupFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbtaggroupFB._addedBlocks)
        : setCriteria(pValue, dbtaggroupFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbtaggroupFB._addedBlocks);
    _waitingNot = '';
    dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
        dbtaggroupFB._addedBlocks.retVal;
    return dbtaggroupFB;
  }

  DbTagGroupFilterBuilder isNull() {
    dbtaggroupFB._addedBlocks = setCriteria(
        0,
        dbtaggroupFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbtaggroupFB._addedBlocks);
    _waitingNot = '';
    dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
        dbtaggroupFB._addedBlocks.retVal;
    return dbtaggroupFB;
  }

  DbTagGroupFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbtaggroupFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbtaggroupFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbtaggroupFB._addedBlocks);
      _waitingNot = '';
      dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
          dbtaggroupFB._addedBlocks.retVal;
    }
    return dbtaggroupFB;
  }

  DbTagGroupFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbtaggroupFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbtaggroupFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbtaggroupFB._addedBlocks);
      _waitingNot = '';
      dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
          dbtaggroupFB._addedBlocks.retVal;
      dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
          dbtaggroupFB._addedBlocks.retVal;
    }
    return dbtaggroupFB;
  }

  DbTagGroupFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbtaggroupFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbtaggroupFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbtaggroupFB._addedBlocks);
      _waitingNot = '';
      dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
          dbtaggroupFB._addedBlocks.retVal;
    }
    return dbtaggroupFB;
  }

  DbTagGroupFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbtaggroupFB._addedBlocks = setCriteria(
          pFirst,
          dbtaggroupFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbtaggroupFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbtaggroupFB._addedBlocks = setCriteria(pFirst, dbtaggroupFB.parameters,
            param, SqlSyntax.LessThan, dbtaggroupFB._addedBlocks);
      } else {
        dbtaggroupFB._addedBlocks = setCriteria(pFirst, dbtaggroupFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbtaggroupFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbtaggroupFB._addedBlocks = setCriteria(pLast, dbtaggroupFB.parameters,
            param, SqlSyntax.GreaterThan, dbtaggroupFB._addedBlocks);
      } else {
        dbtaggroupFB._addedBlocks = setCriteria(pLast, dbtaggroupFB.parameters,
            param, SqlSyntax.LessThanOrEquals, dbtaggroupFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
        dbtaggroupFB._addedBlocks.retVal;
    return dbtaggroupFB;
  }

  DbTagGroupFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbtaggroupFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtaggroupFB.parameters, param,
            SqlSyntax.GreaterThan, dbtaggroupFB._addedBlocks)
        : setCriteria(pValue, dbtaggroupFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbtaggroupFB._addedBlocks);
    _waitingNot = '';
    dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
        dbtaggroupFB._addedBlocks.retVal;
    return dbtaggroupFB;
  }

  DbTagGroupFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbtaggroupFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtaggroupFB.parameters, param,
            SqlSyntax.LessThan, dbtaggroupFB._addedBlocks)
        : setCriteria(pValue, dbtaggroupFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbtaggroupFB._addedBlocks);
    _waitingNot = '';
    dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
        dbtaggroupFB._addedBlocks.retVal;
    return dbtaggroupFB;
  }

  DbTagGroupFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbtaggroupFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtaggroupFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbtaggroupFB._addedBlocks)
        : setCriteria(pValue, dbtaggroupFB.parameters, param,
            SqlSyntax.LessThan, dbtaggroupFB._addedBlocks);
    _waitingNot = '';
    dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
        dbtaggroupFB._addedBlocks.retVal;
    return dbtaggroupFB;
  }

  DbTagGroupFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbtaggroupFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbtaggroupFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbtaggroupFB._addedBlocks)
        : setCriteria(pValue, dbtaggroupFB.parameters, param,
            SqlSyntax.GreaterThan, dbtaggroupFB._addedBlocks);
    _waitingNot = '';
    dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
        dbtaggroupFB._addedBlocks.retVal;
    return dbtaggroupFB;
  }

  DbTagGroupFilterBuilder inValues(dynamic pValue) {
    dbtaggroupFB._addedBlocks = setCriteria(
        pValue,
        dbtaggroupFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbtaggroupFB._addedBlocks);
    _waitingNot = '';
    dbtaggroupFB._addedBlocks.needEndBlock[dbtaggroupFB._blockIndex] =
        dbtaggroupFB._addedBlocks.retVal;
    return dbtaggroupFB;
  }
}
// endregion DbTagGroupField

// region DbTagGroupFilterBuilder
class DbTagGroupFilterBuilder extends SearchCriteria {
  DbTagGroupFilterBuilder(DbTagGroup obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbTagGroup _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbTagGroupFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbTagGroupFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbTagGroupFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbTagGroupFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbTagGroupFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbTagGroupFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbTagGroupFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbTagGroupFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbTagGroupFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbTagGroupFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbTagGroupFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbTagGroupField setField(
      DbTagGroupField field, String colName, DbType dbtype) {
    return DbTagGroupField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbTagGroupField _id;
  DbTagGroupField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbTagGroupField _name;
  DbTagGroupField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbTagGroupField _color;
  DbTagGroupField get color {
    return _color = setField(_color, 'color', DbType.integer);
  }

  DbTagGroupField _system;
  DbTagGroupField get system {
    return _system = setField(_system, 'system', DbType.bool);
  }

  DbTagGroupField _athletesId;
  DbTagGroupField get athletesId {
    return _athletesId = setField(_athletesId, 'athletesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbTagGroup._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbTagGroup> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    // Delete sub records where in (DbTag) according to DeleteRule.CASCADE
    final idListDbTagBYtagGroupsId = toListPrimaryKeySQL(false);
    final resDbTagBYtagGroupsId = await DbTag()
        .select()
        .where('tagGroupsId IN (${idListDbTagBYtagGroupsId['sql']})',
            parameterValue: idListDbTagBYtagGroupsId['args'])
        .delete(hardDelete);
    if (!resDbTagBYtagGroupsId.success) {
      return resDbTagBYtagGroupsId;
    }

    if (DbTagGroup._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbTagGroup.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbTagGroup.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from tagGroups ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbTagGroup.updateBatch(qparams, values);
  }

  /// This method always returns DbTagGroup Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbTagGroup>
  Future<DbTagGroup> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbTagGroup.toList(qparams);
    final data = await objFuture;
    DbTagGroup obj;
    if (data.isNotEmpty) {
      obj = DbTagGroup.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD CHILD
      if (preload) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tagGroups.plDbTags') && */ (preloadFields ==
                null ||
            preloadFields.contains('plDbTags'))) {
          /*_loadedFields.add('tagGroups.plDbTags'); */
          obj.plDbTags = obj.plDbTags ??
              await obj.getDbTags().toList(
                  preload: preload,
                  preloadFields: preloadFields,
                  loadParents: false /*, loadedFields:_loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD CHILD

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('athletes.plDbAthlete') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbAthlete'))) {
          /*_loadedFields.add('athletes.plDbAthlete');*/
          obj.plDbAthlete = obj.plDbAthlete ??
              await obj.getDbAthlete(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbTagGroup]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbtaggroupCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbtaggroupsFuture = await _obj._mnDbTagGroup.toList(qparams);
    final int count = dbtaggroupsFuture[0]['CNT'] as int;
    if (dbtaggroupCount != null) {
      dbtaggroupCount(count);
    }
    return count;
  }

  /// This method returns List<DbTagGroup> [DbTagGroup]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbTagGroup>
  Future<List<DbTagGroup>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbTagGroup> dbtaggroupsData = await DbTagGroup.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return dbtaggroupsData;
  }

  /// This method returns Json String [DbTagGroup]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbTagGroup]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbTagGroup]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbTagGroup.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbTagGroup]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM tagGroups WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbTagGroup.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbTagGroup]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbTagGroup.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbTagGroup.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbTagGroup.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbTagGroupFilterBuilder

// region DbTagGroupFields
class DbTagGroupFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fColor;
  static TableField get color {
    return _fColor =
        _fColor ?? SqlSyntax.setField(_fColor, 'color', DbType.integer);
  }

  static TableField _fSystem;
  static TableField get system {
    return _fSystem =
        _fSystem ?? SqlSyntax.setField(_fSystem, 'system', DbType.bool);
  }

  static TableField _fAthletesId;
  static TableField get athletesId {
    return _fAthletesId = _fAthletesId ??
        SqlSyntax.setField(_fAthletesId, 'athletesId', DbType.integer);
  }
}
// endregion DbTagGroupFields

//region DbTagGroupManager
class DbTagGroupManager extends SqfEntityProvider {
  DbTagGroupManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'tagGroups';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbTagGroupManager
// region DbLapTagging
class DbLapTagging {
  DbLapTagging({this.id, this.system, this.tagsId, this.lapsId}) {
    _setDefaultValues();
  }
  DbLapTagging.withFields(this.system, this.tagsId, this.lapsId) {
    _setDefaultValues();
  }
  DbLapTagging.withId(this.id, this.system, this.tagsId, this.lapsId) {
    _setDefaultValues();
  }
  DbLapTagging.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['system'] != null) {
      system = o['system'] == 1 || o['system'] == true;
    }
    tagsId = int.tryParse(o['tagsId'].toString());

    lapsId = int.tryParse(o['lapsId'].toString());

    // RELATIONSHIPS FromMAP
    plDbTag = o['dbTag'] != null
        ? DbTag.fromMap(o['dbTag'] as Map<String, dynamic>)
        : null;
    plDbLap = o['dbLap'] != null
        ? DbLap.fromMap(o['dbLap'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbLapTagging)
  int id;
  bool system;
  int tagsId;
  int lapsId;

  BoolResult saveResult;
  // end FIELDS (DbLapTagging)

// RELATIONSHIPS (DbLapTagging)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbTag', 'plField2'..]) or so on..
  DbTag plDbTag;

  /// get DbTag By TagsId
  Future<DbTag> getDbTag(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbTag()
        .getById(tagsId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbLap', 'plField2'..]) or so on..
  DbLap plDbLap;

  /// get DbLap By LapsId
  Future<DbLap> getDbLap(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbLap()
        .getById(lapsId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbLapTagging)

  static const bool _softDeleteActivated = false;
  DbLapTaggingManager __mnDbLapTagging;

  DbLapTaggingManager get _mnDbLapTagging {
    return __mnDbLapTagging = __mnDbLapTagging ?? DbLapTaggingManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (system != null) {
      map['system'] = forQuery ? (system ? 1 : 0) : system;
    }

    if (tagsId != null) {
      map['tagsId'] = forView ? plDbTag.name : tagsId;
    }

    if (lapsId != null) {
      map['lapsId'] = forView ? plDbLap.event : lapsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (system != null) {
      map['system'] = forQuery ? (system ? 1 : 0) : system;
    }

    if (tagsId != null) {
      map['tagsId'] = forView ? plDbTag.name : tagsId;
    }

    if (lapsId != null) {
      map['lapsId'] = forView ? plDbLap.event : lapsId;
    }

    return map;
  }

  /// This method returns Json String [DbLapTagging]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbLapTagging]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [system, tagsId, lapsId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, system, tagsId, lapsId];
  }

  static Future<List<DbLapTagging>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbLapTagging.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbLapTagging>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbLapTagging>[];
    try {
      objList = list
          .map((dblaptagging) =>
              DbLapTagging.fromMap(dblaptagging as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbLapTagging.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbLapTagging>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbLapTagging> objList = <DbLapTagging>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbLapTagging.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTag'))) {
          /*_loadedFields.add('tags.plDbTag');*/
          obj.plDbTag = obj.plDbTag ??
              await obj.getDbTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('laps.plDbLap') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbLap'))) {
          /*_loadedFields.add('laps.plDbLap');*/
          obj.plDbLap = obj.plDbLap ??
              await obj.getDbLap(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbLapTagging by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbLapTagging if exist, otherwise returns null
  Future<DbLapTagging> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbLapTagging obj;
    final data = await _mnDbLapTagging.getById([id]);
    if (data.length != 0) {
      obj = DbLapTagging.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTag'))) {
          /*_loadedFields.add('tags.plDbTag');*/
          obj.plDbTag = obj.plDbTag ??
              await obj.getDbTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('laps.plDbLap') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbLap'))) {
          /*_loadedFields.add('laps.plDbLap');*/
          obj.plDbLap = obj.plDbLap ??
              await obj.getDbLap(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbLapTagging) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbLapTagging.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbLapTagging.update(this);
    }

    return id;
  }

  /// saveAs DbLapTagging. Returns a new Primary Key value of DbLapTagging

  /// <returns>Returns a new Primary Key value of DbLapTagging
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbLapTagging> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DbLapTagging> dblaptaggings) async {
    // final results = _mnDbLapTagging.saveAll('INSERT OR REPLACE INTO lapTaggings (id,system, tagsId, lapsId)  VALUES (?,?,?,?)',dblaptaggings);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dblaptaggings) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dblaptaggings.length; i++) {
      if (dblaptaggings[i].id == null) {
        dblaptaggings[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbLapTagging.rawInsert(
              'INSERT OR REPLACE INTO lapTaggings (id,system, tagsId, lapsId)  VALUES (?,?,?,?)',
              [id, system, tagsId, lapsId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbLapTagging id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbLapTagging id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbLapTagging Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbLapTagging>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<DbLapTagging> dblaptaggings) async {
    final results = await _mnDbLapTagging.rawInsertAll(
        'INSERT OR REPLACE INTO lapTaggings (id,system, tagsId, lapsId)  VALUES (?,?,?,?)',
        dblaptaggings);
    return results;
  }

  /// Deletes DbLapTagging

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbLapTagging invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbLapTagging
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbLapTagging.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbLapTaggingFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLapTaggingFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbLapTaggingFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLapTaggingFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    tagsId = tagsId ?? 0;
    lapsId = lapsId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dblaptagging

// region DbLapTaggingField
class DbLapTaggingField extends SearchCriteria {
  DbLapTaggingField(this.dblaptaggingFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbLapTaggingFilterBuilder dblaptaggingFB;

  DbLapTaggingField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbLapTaggingFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dblaptaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.EQuals, dblaptaggingFB._addedBlocks)
        : setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.NotEQuals, dblaptaggingFB._addedBlocks);
    _waitingNot = '';
    dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
        dblaptaggingFB._addedBlocks.retVal;
    return dblaptaggingFB;
  }

  DbLapTaggingFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dblaptaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.EQualsOrNull, dblaptaggingFB._addedBlocks)
        : setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dblaptaggingFB._addedBlocks);
    _waitingNot = '';
    dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
        dblaptaggingFB._addedBlocks.retVal;
    return dblaptaggingFB;
  }

  DbLapTaggingFilterBuilder isNull() {
    dblaptaggingFB._addedBlocks = setCriteria(
        0,
        dblaptaggingFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dblaptaggingFB._addedBlocks);
    _waitingNot = '';
    dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
        dblaptaggingFB._addedBlocks.retVal;
    return dblaptaggingFB;
  }

  DbLapTaggingFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dblaptaggingFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dblaptaggingFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblaptaggingFB._addedBlocks);
      _waitingNot = '';
      dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
          dblaptaggingFB._addedBlocks.retVal;
    }
    return dblaptaggingFB;
  }

  DbLapTaggingFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dblaptaggingFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dblaptaggingFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblaptaggingFB._addedBlocks);
      _waitingNot = '';
      dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
          dblaptaggingFB._addedBlocks.retVal;
      dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
          dblaptaggingFB._addedBlocks.retVal;
    }
    return dblaptaggingFB;
  }

  DbLapTaggingFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dblaptaggingFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dblaptaggingFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblaptaggingFB._addedBlocks);
      _waitingNot = '';
      dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
          dblaptaggingFB._addedBlocks.retVal;
    }
    return dblaptaggingFB;
  }

  DbLapTaggingFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dblaptaggingFB._addedBlocks = setCriteria(
          pFirst,
          dblaptaggingFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblaptaggingFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dblaptaggingFB._addedBlocks = setCriteria(
            pFirst,
            dblaptaggingFB.parameters,
            param,
            SqlSyntax.LessThan,
            dblaptaggingFB._addedBlocks);
      } else {
        dblaptaggingFB._addedBlocks = setCriteria(
            pFirst,
            dblaptaggingFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dblaptaggingFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dblaptaggingFB._addedBlocks = setCriteria(
            pLast,
            dblaptaggingFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            dblaptaggingFB._addedBlocks);
      } else {
        dblaptaggingFB._addedBlocks = setCriteria(
            pLast,
            dblaptaggingFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            dblaptaggingFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
        dblaptaggingFB._addedBlocks.retVal;
    return dblaptaggingFB;
  }

  DbLapTaggingFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dblaptaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.GreaterThan, dblaptaggingFB._addedBlocks)
        : setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblaptaggingFB._addedBlocks);
    _waitingNot = '';
    dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
        dblaptaggingFB._addedBlocks.retVal;
    return dblaptaggingFB;
  }

  DbLapTaggingFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dblaptaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.LessThan, dblaptaggingFB._addedBlocks)
        : setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblaptaggingFB._addedBlocks);
    _waitingNot = '';
    dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
        dblaptaggingFB._addedBlocks.retVal;
    return dblaptaggingFB;
  }

  DbLapTaggingFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dblaptaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblaptaggingFB._addedBlocks)
        : setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.LessThan, dblaptaggingFB._addedBlocks);
    _waitingNot = '';
    dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
        dblaptaggingFB._addedBlocks.retVal;
    return dblaptaggingFB;
  }

  DbLapTaggingFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dblaptaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblaptaggingFB._addedBlocks)
        : setCriteria(pValue, dblaptaggingFB.parameters, param,
            SqlSyntax.GreaterThan, dblaptaggingFB._addedBlocks);
    _waitingNot = '';
    dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
        dblaptaggingFB._addedBlocks.retVal;
    return dblaptaggingFB;
  }

  DbLapTaggingFilterBuilder inValues(dynamic pValue) {
    dblaptaggingFB._addedBlocks = setCriteria(
        pValue,
        dblaptaggingFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dblaptaggingFB._addedBlocks);
    _waitingNot = '';
    dblaptaggingFB._addedBlocks.needEndBlock[dblaptaggingFB._blockIndex] =
        dblaptaggingFB._addedBlocks.retVal;
    return dblaptaggingFB;
  }
}
// endregion DbLapTaggingField

// region DbLapTaggingFilterBuilder
class DbLapTaggingFilterBuilder extends SearchCriteria {
  DbLapTaggingFilterBuilder(DbLapTagging obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbLapTagging _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbLapTaggingFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbLapTaggingFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbLapTaggingFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbLapTaggingFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbLapTaggingFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbLapTaggingFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbLapTaggingFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbLapTaggingFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbLapTaggingFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbLapTaggingFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbLapTaggingFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbLapTaggingField setField(
      DbLapTaggingField field, String colName, DbType dbtype) {
    return DbLapTaggingField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbLapTaggingField _id;
  DbLapTaggingField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbLapTaggingField _system;
  DbLapTaggingField get system {
    return _system = setField(_system, 'system', DbType.bool);
  }

  DbLapTaggingField _tagsId;
  DbLapTaggingField get tagsId {
    return _tagsId = setField(_tagsId, 'tagsId', DbType.integer);
  }

  DbLapTaggingField _lapsId;
  DbLapTaggingField get lapsId {
    return _lapsId = setField(_lapsId, 'lapsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbLapTagging._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbLapTagging> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (DbLapTagging._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbLapTagging.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbLapTagging.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from lapTaggings ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbLapTagging.updateBatch(qparams, values);
  }

  /// This method always returns DbLapTagging Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbLapTagging>
  Future<DbLapTagging> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbLapTagging.toList(qparams);
    final data = await objFuture;
    DbLapTagging obj;
    if (data.isNotEmpty) {
      obj = DbLapTagging.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTag'))) {
          /*_loadedFields.add('tags.plDbTag');*/
          obj.plDbTag = obj.plDbTag ??
              await obj.getDbTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('laps.plDbLap') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbLap'))) {
          /*_loadedFields.add('laps.plDbLap');*/
          obj.plDbLap = obj.plDbLap ??
              await obj.getDbLap(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbLapTagging]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dblaptaggingCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dblaptaggingsFuture = await _obj._mnDbLapTagging.toList(qparams);
    final int count = dblaptaggingsFuture[0]['CNT'] as int;
    if (dblaptaggingCount != null) {
      dblaptaggingCount(count);
    }
    return count;
  }

  /// This method returns List<DbLapTagging> [DbLapTagging]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbLapTagging>
  Future<List<DbLapTagging>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbLapTagging> dblaptaggingsData = await DbLapTagging.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return dblaptaggingsData;
  }

  /// This method returns Json String [DbLapTagging]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbLapTagging]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbLapTagging]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbLapTagging.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbLapTagging]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM lapTaggings WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbLapTagging.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbLapTagging]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbLapTagging.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbLapTagging.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbLapTagging.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbLapTaggingFilterBuilder

// region DbLapTaggingFields
class DbLapTaggingFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fSystem;
  static TableField get system {
    return _fSystem =
        _fSystem ?? SqlSyntax.setField(_fSystem, 'system', DbType.bool);
  }

  static TableField _fTagsId;
  static TableField get tagsId {
    return _fTagsId =
        _fTagsId ?? SqlSyntax.setField(_fTagsId, 'tagsId', DbType.integer);
  }

  static TableField _fLapsId;
  static TableField get lapsId {
    return _fLapsId =
        _fLapsId ?? SqlSyntax.setField(_fLapsId, 'lapsId', DbType.integer);
  }
}
// endregion DbLapTaggingFields

//region DbLapTaggingManager
class DbLapTaggingManager extends SqfEntityProvider {
  DbLapTaggingManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'lapTaggings';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbLapTaggingManager
// region DbActivityTagging
class DbActivityTagging {
  DbActivityTagging({this.id, this.system, this.tagsId, this.activitiesId}) {
    _setDefaultValues();
  }
  DbActivityTagging.withFields(this.system, this.tagsId, this.activitiesId) {
    _setDefaultValues();
  }
  DbActivityTagging.withId(
      this.id, this.system, this.tagsId, this.activitiesId) {
    _setDefaultValues();
  }
  DbActivityTagging.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['system'] != null) {
      system = o['system'] == 1 || o['system'] == true;
    }
    tagsId = int.tryParse(o['tagsId'].toString());

    activitiesId = int.tryParse(o['activitiesId'].toString());

    // RELATIONSHIPS FromMAP
    plDbTag = o['dbTag'] != null
        ? DbTag.fromMap(o['dbTag'] as Map<String, dynamic>)
        : null;
    plDbActivity = o['dbActivity'] != null
        ? DbActivity.fromMap(o['dbActivity'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbActivityTagging)
  int id;
  bool system;
  int tagsId;
  int activitiesId;

  BoolResult saveResult;
  // end FIELDS (DbActivityTagging)

// RELATIONSHIPS (DbActivityTagging)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbTag', 'plField2'..]) or so on..
  DbTag plDbTag;

  /// get DbTag By TagsId
  Future<DbTag> getDbTag(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbTag()
        .getById(tagsId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbActivity', 'plField2'..]) or so on..
  DbActivity plDbActivity;

  /// get DbActivity By ActivitiesId
  Future<DbActivity> getDbActivity(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbActivity().getById(activitiesId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbActivityTagging)

  static const bool _softDeleteActivated = false;
  DbActivityTaggingManager __mnDbActivityTagging;

  DbActivityTaggingManager get _mnDbActivityTagging {
    return __mnDbActivityTagging =
        __mnDbActivityTagging ?? DbActivityTaggingManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (system != null) {
      map['system'] = forQuery ? (system ? 1 : 0) : system;
    }

    if (tagsId != null) {
      map['tagsId'] = forView ? plDbTag.name : tagsId;
    }

    if (activitiesId != null) {
      map['activitiesId'] = forView ? plDbActivity.state : activitiesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (system != null) {
      map['system'] = forQuery ? (system ? 1 : 0) : system;
    }

    if (tagsId != null) {
      map['tagsId'] = forView ? plDbTag.name : tagsId;
    }

    if (activitiesId != null) {
      map['activitiesId'] = forView ? plDbActivity.state : activitiesId;
    }

    return map;
  }

  /// This method returns Json String [DbActivityTagging]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbActivityTagging]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [system, tagsId, activitiesId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, system, tagsId, activitiesId];
  }

  static Future<List<DbActivityTagging>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbActivityTagging.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbActivityTagging>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbActivityTagging>[];
    try {
      objList = list
          .map((dbactivitytagging) => DbActivityTagging.fromMap(
              dbactivitytagging as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbActivityTagging.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbActivityTagging>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbActivityTagging> objList = <DbActivityTagging>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbActivityTagging.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTag'))) {
          /*_loadedFields.add('tags.plDbTag');*/
          obj.plDbTag = obj.plDbTag ??
              await obj.getDbTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbActivityTagging by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbActivityTagging if exist, otherwise returns null
  Future<DbActivityTagging> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbActivityTagging obj;
    final data = await _mnDbActivityTagging.getById([id]);
    if (data.length != 0) {
      obj = DbActivityTagging.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTag'))) {
          /*_loadedFields.add('tags.plDbTag');*/
          obj.plDbTag = obj.plDbTag ??
              await obj.getDbTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbActivityTagging) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbActivityTagging.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbActivityTagging.update(this);
    }

    return id;
  }

  /// saveAs DbActivityTagging. Returns a new Primary Key value of DbActivityTagging

  /// <returns>Returns a new Primary Key value of DbActivityTagging
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbActivityTagging> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<DbActivityTagging> dbactivitytaggings) async {
    // final results = _mnDbActivityTagging.saveAll('INSERT OR REPLACE INTO activityTaggings (id,system, tagsId, activitiesId)  VALUES (?,?,?,?)',dbactivitytaggings);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbactivitytaggings) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbactivitytaggings.length; i++) {
      if (dbactivitytaggings[i].id == null) {
        dbactivitytaggings[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbActivityTagging.rawInsert(
              'INSERT OR REPLACE INTO activityTaggings (id,system, tagsId, activitiesId)  VALUES (?,?,?,?)',
              [id, system, tagsId, activitiesId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbActivityTagging id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DbActivityTagging id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'DbActivityTagging Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbActivityTagging>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<DbActivityTagging> dbactivitytaggings) async {
    final results = await _mnDbActivityTagging.rawInsertAll(
        'INSERT OR REPLACE INTO activityTaggings (id,system, tagsId, activitiesId)  VALUES (?,?,?,?)',
        dbactivitytaggings);
    return results;
  }

  /// Deletes DbActivityTagging

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbActivityTagging invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbActivityTagging
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbActivityTagging.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbActivityTaggingFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbActivityTaggingFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbActivityTaggingFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbActivityTaggingFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    tagsId = tagsId ?? 0;
    activitiesId = activitiesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbactivitytagging

// region DbActivityTaggingField
class DbActivityTaggingField extends SearchCriteria {
  DbActivityTaggingField(this.dbactivitytaggingFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbActivityTaggingFilterBuilder dbactivitytaggingFB;

  DbActivityTaggingField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbActivityTaggingFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbactivitytaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.EQuals, dbactivitytaggingFB._addedBlocks)
        : setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.NotEQuals, dbactivitytaggingFB._addedBlocks);
    _waitingNot = '';
    dbactivitytaggingFB
            ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
        dbactivitytaggingFB._addedBlocks.retVal;
    return dbactivitytaggingFB;
  }

  DbActivityTaggingFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbactivitytaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbactivitytaggingFB._addedBlocks)
        : setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbactivitytaggingFB._addedBlocks);
    _waitingNot = '';
    dbactivitytaggingFB
            ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
        dbactivitytaggingFB._addedBlocks.retVal;
    return dbactivitytaggingFB;
  }

  DbActivityTaggingFilterBuilder isNull() {
    dbactivitytaggingFB._addedBlocks = setCriteria(
        0,
        dbactivitytaggingFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbactivitytaggingFB._addedBlocks);
    _waitingNot = '';
    dbactivitytaggingFB
            ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
        dbactivitytaggingFB._addedBlocks.retVal;
    return dbactivitytaggingFB;
  }

  DbActivityTaggingFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbactivitytaggingFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbactivitytaggingFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivitytaggingFB._addedBlocks);
      _waitingNot = '';
      dbactivitytaggingFB
              ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
          dbactivitytaggingFB._addedBlocks.retVal;
    }
    return dbactivitytaggingFB;
  }

  DbActivityTaggingFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbactivitytaggingFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbactivitytaggingFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivitytaggingFB._addedBlocks);
      _waitingNot = '';
      dbactivitytaggingFB
              ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
          dbactivitytaggingFB._addedBlocks.retVal;
      dbactivitytaggingFB
              ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
          dbactivitytaggingFB._addedBlocks.retVal;
    }
    return dbactivitytaggingFB;
  }

  DbActivityTaggingFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbactivitytaggingFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbactivitytaggingFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivitytaggingFB._addedBlocks);
      _waitingNot = '';
      dbactivitytaggingFB
              ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
          dbactivitytaggingFB._addedBlocks.retVal;
    }
    return dbactivitytaggingFB;
  }

  DbActivityTaggingFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbactivitytaggingFB._addedBlocks = setCriteria(
          pFirst,
          dbactivitytaggingFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivitytaggingFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbactivitytaggingFB._addedBlocks = setCriteria(
            pFirst,
            dbactivitytaggingFB.parameters,
            param,
            SqlSyntax.LessThan,
            dbactivitytaggingFB._addedBlocks);
      } else {
        dbactivitytaggingFB._addedBlocks = setCriteria(
            pFirst,
            dbactivitytaggingFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbactivitytaggingFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbactivitytaggingFB._addedBlocks = setCriteria(
            pLast,
            dbactivitytaggingFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            dbactivitytaggingFB._addedBlocks);
      } else {
        dbactivitytaggingFB._addedBlocks = setCriteria(
            pLast,
            dbactivitytaggingFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            dbactivitytaggingFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbactivitytaggingFB
            ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
        dbactivitytaggingFB._addedBlocks.retVal;
    return dbactivitytaggingFB;
  }

  DbActivityTaggingFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbactivitytaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.GreaterThan, dbactivitytaggingFB._addedBlocks)
        : setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbactivitytaggingFB._addedBlocks);
    _waitingNot = '';
    dbactivitytaggingFB
            ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
        dbactivitytaggingFB._addedBlocks.retVal;
    return dbactivitytaggingFB;
  }

  DbActivityTaggingFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbactivitytaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.LessThan, dbactivitytaggingFB._addedBlocks)
        : setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbactivitytaggingFB._addedBlocks);
    _waitingNot = '';
    dbactivitytaggingFB
            ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
        dbactivitytaggingFB._addedBlocks.retVal;
    return dbactivitytaggingFB;
  }

  DbActivityTaggingFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbactivitytaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbactivitytaggingFB._addedBlocks)
        : setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.LessThan, dbactivitytaggingFB._addedBlocks);
    _waitingNot = '';
    dbactivitytaggingFB
            ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
        dbactivitytaggingFB._addedBlocks.retVal;
    return dbactivitytaggingFB;
  }

  DbActivityTaggingFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbactivitytaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbactivitytaggingFB._addedBlocks)
        : setCriteria(pValue, dbactivitytaggingFB.parameters, param,
            SqlSyntax.GreaterThan, dbactivitytaggingFB._addedBlocks);
    _waitingNot = '';
    dbactivitytaggingFB
            ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
        dbactivitytaggingFB._addedBlocks.retVal;
    return dbactivitytaggingFB;
  }

  DbActivityTaggingFilterBuilder inValues(dynamic pValue) {
    dbactivitytaggingFB._addedBlocks = setCriteria(
        pValue,
        dbactivitytaggingFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbactivitytaggingFB._addedBlocks);
    _waitingNot = '';
    dbactivitytaggingFB
            ._addedBlocks.needEndBlock[dbactivitytaggingFB._blockIndex] =
        dbactivitytaggingFB._addedBlocks.retVal;
    return dbactivitytaggingFB;
  }
}
// endregion DbActivityTaggingField

// region DbActivityTaggingFilterBuilder
class DbActivityTaggingFilterBuilder extends SearchCriteria {
  DbActivityTaggingFilterBuilder(DbActivityTagging obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbActivityTagging _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbActivityTaggingFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbActivityTaggingFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbActivityTaggingFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbActivityTaggingFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbActivityTaggingFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbActivityTaggingFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbActivityTaggingFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbActivityTaggingFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbActivityTaggingFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbActivityTaggingFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbActivityTaggingFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbActivityTaggingField setField(
      DbActivityTaggingField field, String colName, DbType dbtype) {
    return DbActivityTaggingField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbActivityTaggingField _id;
  DbActivityTaggingField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbActivityTaggingField _system;
  DbActivityTaggingField get system {
    return _system = setField(_system, 'system', DbType.bool);
  }

  DbActivityTaggingField _tagsId;
  DbActivityTaggingField get tagsId {
    return _tagsId = setField(_tagsId, 'tagsId', DbType.integer);
  }

  DbActivityTaggingField _activitiesId;
  DbActivityTaggingField get activitiesId {
    return _activitiesId =
        setField(_activitiesId, 'activitiesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbActivityTagging._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbActivityTagging> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (DbActivityTagging._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbActivityTagging
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbActivityTagging.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from activityTaggings ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbActivityTagging.updateBatch(qparams, values);
  }

  /// This method always returns DbActivityTagging Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbActivityTagging>
  Future<DbActivityTagging> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbActivityTagging.toList(qparams);
    final data = await objFuture;
    DbActivityTagging obj;
    if (data.isNotEmpty) {
      obj = DbActivityTagging.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTag'))) {
          /*_loadedFields.add('tags.plDbTag');*/
          obj.plDbTag = obj.plDbTag ??
              await obj.getDbTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('activities.plDbActivity') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbActivity'))) {
          /*_loadedFields.add('activities.plDbActivity');*/
          obj.plDbActivity = obj.plDbActivity ??
              await obj.getDbActivity(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbActivityTagging]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) dbactivitytaggingCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbactivitytaggingsFuture =
        await _obj._mnDbActivityTagging.toList(qparams);
    final int count = dbactivitytaggingsFuture[0]['CNT'] as int;
    if (dbactivitytaggingCount != null) {
      dbactivitytaggingCount(count);
    }
    return count;
  }

  /// This method returns List<DbActivityTagging> [DbActivityTagging]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbActivityTagging>
  Future<List<DbActivityTagging>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbActivityTagging> dbactivitytaggingsData =
        await DbActivityTagging.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return dbactivitytaggingsData;
  }

  /// This method returns Json String [DbActivityTagging]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbActivityTagging]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbActivityTagging]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbActivityTagging.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbActivityTagging]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM activityTaggings WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbActivityTagging.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbActivityTagging]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbActivityTagging.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbActivityTagging.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbActivityTagging.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbActivityTaggingFilterBuilder

// region DbActivityTaggingFields
class DbActivityTaggingFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fSystem;
  static TableField get system {
    return _fSystem =
        _fSystem ?? SqlSyntax.setField(_fSystem, 'system', DbType.bool);
  }

  static TableField _fTagsId;
  static TableField get tagsId {
    return _fTagsId =
        _fTagsId ?? SqlSyntax.setField(_fTagsId, 'tagsId', DbType.integer);
  }

  static TableField _fActivitiesId;
  static TableField get activitiesId {
    return _fActivitiesId = _fActivitiesId ??
        SqlSyntax.setField(_fActivitiesId, 'activitiesId', DbType.integer);
  }
}
// endregion DbActivityTaggingFields

//region DbActivityTaggingManager
class DbActivityTaggingManager extends SqfEntityProvider {
  DbActivityTaggingManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'activityTaggings';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbActivityTaggingManager
// region DbIntervalTagging
class DbIntervalTagging {
  DbIntervalTagging({this.id, this.system, this.tagsId, this.intervalsId}) {
    _setDefaultValues();
  }
  DbIntervalTagging.withFields(this.system, this.tagsId, this.intervalsId) {
    _setDefaultValues();
  }
  DbIntervalTagging.withId(
      this.id, this.system, this.tagsId, this.intervalsId) {
    _setDefaultValues();
  }
  DbIntervalTagging.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['system'] != null) {
      system = o['system'] == 1 || o['system'] == true;
    }
    tagsId = int.tryParse(o['tagsId'].toString());

    intervalsId = int.tryParse(o['intervalsId'].toString());

    // RELATIONSHIPS FromMAP
    plDbTag = o['dbTag'] != null
        ? DbTag.fromMap(o['dbTag'] as Map<String, dynamic>)
        : null;
    plDbInterval = o['dbInterval'] != null
        ? DbInterval.fromMap(o['dbInterval'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbIntervalTagging)
  int id;
  bool system;
  int tagsId;
  int intervalsId;

  BoolResult saveResult;
  // end FIELDS (DbIntervalTagging)

// RELATIONSHIPS (DbIntervalTagging)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbTag', 'plField2'..]) or so on..
  DbTag plDbTag;

  /// get DbTag By TagsId
  Future<DbTag> getDbTag(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbTag()
        .getById(tagsId, loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true) or getById(preload:true)
  /// You can also specify this object into certain preload fields. Ex: toList(preload:true, preloadFields:['plDbInterval', 'plField2'..]) or so on..
  DbInterval plDbInterval;

  /// get DbInterval By IntervalsId
  Future<DbInterval> getDbInterval(
      {bool loadParents = false, List<String> loadedFields}) async {
    final _obj = await DbInterval().getById(intervalsId,
        loadParents: loadParents, loadedFields: loadedFields);
    return _obj;
  }
  // END RELATIONSHIPS (DbIntervalTagging)

  static const bool _softDeleteActivated = false;
  DbIntervalTaggingManager __mnDbIntervalTagging;

  DbIntervalTaggingManager get _mnDbIntervalTagging {
    return __mnDbIntervalTagging =
        __mnDbIntervalTagging ?? DbIntervalTaggingManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (system != null) {
      map['system'] = forQuery ? (system ? 1 : 0) : system;
    }

    if (tagsId != null) {
      map['tagsId'] = forView ? plDbTag.name : tagsId;
    }

    if (intervalsId != null) {
      map['intervalsId'] = forView ? plDbInterval.id : intervalsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (system != null) {
      map['system'] = forQuery ? (system ? 1 : 0) : system;
    }

    if (tagsId != null) {
      map['tagsId'] = forView ? plDbTag.name : tagsId;
    }

    if (intervalsId != null) {
      map['intervalsId'] = forView ? plDbInterval.id : intervalsId;
    }

    return map;
  }

  /// This method returns Json String [DbIntervalTagging]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbIntervalTagging]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [system, tagsId, intervalsId];
  }

  List<dynamic> toArgsWithIds() {
    return [id, system, tagsId, intervalsId];
  }

  static Future<List<DbIntervalTagging>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbIntervalTagging.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbIntervalTagging>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbIntervalTagging>[];
    try {
      objList = list
          .map((dbintervaltagging) => DbIntervalTagging.fromMap(
              dbintervaltagging as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbIntervalTagging.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbIntervalTagging>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbIntervalTagging> objList = <DbIntervalTagging>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbIntervalTagging.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);
      // final List<String> _loadedFields = List<String>.from(loadedFields);

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTag'))) {
          /*_loadedFields.add('tags.plDbTag');*/
          obj.plDbTag = obj.plDbTag ??
              await obj.getDbTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('intervals.plDbInterval') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbInterval'))) {
          /*_loadedFields.add('intervals.plDbInterval');*/
          obj.plDbInterval = obj.plDbInterval ??
              await obj.getDbInterval(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbIntervalTagging by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbIntervalTagging if exist, otherwise returns null
  Future<DbIntervalTagging> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbIntervalTagging obj;
    final data = await _mnDbIntervalTagging.getById([id]);
    if (data.length != 0) {
      obj = DbIntervalTagging.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTag'))) {
          /*_loadedFields.add('tags.plDbTag');*/
          obj.plDbTag = obj.plDbTag ??
              await obj.getDbTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('intervals.plDbInterval') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbInterval'))) {
          /*_loadedFields.add('intervals.plDbInterval');*/
          obj.plDbInterval = obj.plDbInterval ??
              await obj.getDbInterval(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbIntervalTagging) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbIntervalTagging.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbIntervalTagging.update(this);
    }

    return id;
  }

  /// saveAs DbIntervalTagging. Returns a new Primary Key value of DbIntervalTagging

  /// <returns>Returns a new Primary Key value of DbIntervalTagging
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbIntervalTagging> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<DbIntervalTagging> dbintervaltaggings) async {
    // final results = _mnDbIntervalTagging.saveAll('INSERT OR REPLACE INTO intervalTaggings (id,system, tagsId, intervalsId)  VALUES (?,?,?,?)',dbintervaltaggings);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dbintervaltaggings) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dbintervaltaggings.length; i++) {
      if (dbintervaltaggings[i].id == null) {
        dbintervaltaggings[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbIntervalTagging.rawInsert(
              'INSERT OR REPLACE INTO intervalTaggings (id,system, tagsId, intervalsId)  VALUES (?,?,?,?)',
              [id, system, tagsId, intervalsId]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbIntervalTagging id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DbIntervalTagging id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'DbIntervalTagging Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbIntervalTagging>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(
      List<DbIntervalTagging> dbintervaltaggings) async {
    final results = await _mnDbIntervalTagging.rawInsertAll(
        'INSERT OR REPLACE INTO intervalTaggings (id,system, tagsId, intervalsId)  VALUES (?,?,?,?)',
        dbintervaltaggings);
    return results;
  }

  /// Deletes DbIntervalTagging

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbIntervalTagging invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbIntervalTagging
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbIntervalTagging.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbIntervalTaggingFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbIntervalTaggingFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbIntervalTaggingFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbIntervalTaggingFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    tagsId = tagsId ?? 0;
    intervalsId = intervalsId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbintervaltagging

// region DbIntervalTaggingField
class DbIntervalTaggingField extends SearchCriteria {
  DbIntervalTaggingField(this.dbintervaltaggingFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbIntervalTaggingFilterBuilder dbintervaltaggingFB;

  DbIntervalTaggingField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbIntervalTaggingFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbintervaltaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.EQuals, dbintervaltaggingFB._addedBlocks)
        : setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.NotEQuals, dbintervaltaggingFB._addedBlocks);
    _waitingNot = '';
    dbintervaltaggingFB
            ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
        dbintervaltaggingFB._addedBlocks.retVal;
    return dbintervaltaggingFB;
  }

  DbIntervalTaggingFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbintervaltaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbintervaltaggingFB._addedBlocks)
        : setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbintervaltaggingFB._addedBlocks);
    _waitingNot = '';
    dbintervaltaggingFB
            ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
        dbintervaltaggingFB._addedBlocks.retVal;
    return dbintervaltaggingFB;
  }

  DbIntervalTaggingFilterBuilder isNull() {
    dbintervaltaggingFB._addedBlocks = setCriteria(
        0,
        dbintervaltaggingFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbintervaltaggingFB._addedBlocks);
    _waitingNot = '';
    dbintervaltaggingFB
            ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
        dbintervaltaggingFB._addedBlocks.retVal;
    return dbintervaltaggingFB;
  }

  DbIntervalTaggingFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbintervaltaggingFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbintervaltaggingFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbintervaltaggingFB._addedBlocks);
      _waitingNot = '';
      dbintervaltaggingFB
              ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
          dbintervaltaggingFB._addedBlocks.retVal;
    }
    return dbintervaltaggingFB;
  }

  DbIntervalTaggingFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbintervaltaggingFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbintervaltaggingFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbintervaltaggingFB._addedBlocks);
      _waitingNot = '';
      dbintervaltaggingFB
              ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
          dbintervaltaggingFB._addedBlocks.retVal;
      dbintervaltaggingFB
              ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
          dbintervaltaggingFB._addedBlocks.retVal;
    }
    return dbintervaltaggingFB;
  }

  DbIntervalTaggingFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbintervaltaggingFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbintervaltaggingFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbintervaltaggingFB._addedBlocks);
      _waitingNot = '';
      dbintervaltaggingFB
              ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
          dbintervaltaggingFB._addedBlocks.retVal;
    }
    return dbintervaltaggingFB;
  }

  DbIntervalTaggingFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbintervaltaggingFB._addedBlocks = setCriteria(
          pFirst,
          dbintervaltaggingFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbintervaltaggingFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbintervaltaggingFB._addedBlocks = setCriteria(
            pFirst,
            dbintervaltaggingFB.parameters,
            param,
            SqlSyntax.LessThan,
            dbintervaltaggingFB._addedBlocks);
      } else {
        dbintervaltaggingFB._addedBlocks = setCriteria(
            pFirst,
            dbintervaltaggingFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbintervaltaggingFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbintervaltaggingFB._addedBlocks = setCriteria(
            pLast,
            dbintervaltaggingFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            dbintervaltaggingFB._addedBlocks);
      } else {
        dbintervaltaggingFB._addedBlocks = setCriteria(
            pLast,
            dbintervaltaggingFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            dbintervaltaggingFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbintervaltaggingFB
            ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
        dbintervaltaggingFB._addedBlocks.retVal;
    return dbintervaltaggingFB;
  }

  DbIntervalTaggingFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbintervaltaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.GreaterThan, dbintervaltaggingFB._addedBlocks)
        : setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbintervaltaggingFB._addedBlocks);
    _waitingNot = '';
    dbintervaltaggingFB
            ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
        dbintervaltaggingFB._addedBlocks.retVal;
    return dbintervaltaggingFB;
  }

  DbIntervalTaggingFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbintervaltaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.LessThan, dbintervaltaggingFB._addedBlocks)
        : setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbintervaltaggingFB._addedBlocks);
    _waitingNot = '';
    dbintervaltaggingFB
            ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
        dbintervaltaggingFB._addedBlocks.retVal;
    return dbintervaltaggingFB;
  }

  DbIntervalTaggingFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbintervaltaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbintervaltaggingFB._addedBlocks)
        : setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.LessThan, dbintervaltaggingFB._addedBlocks);
    _waitingNot = '';
    dbintervaltaggingFB
            ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
        dbintervaltaggingFB._addedBlocks.retVal;
    return dbintervaltaggingFB;
  }

  DbIntervalTaggingFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbintervaltaggingFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbintervaltaggingFB._addedBlocks)
        : setCriteria(pValue, dbintervaltaggingFB.parameters, param,
            SqlSyntax.GreaterThan, dbintervaltaggingFB._addedBlocks);
    _waitingNot = '';
    dbintervaltaggingFB
            ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
        dbintervaltaggingFB._addedBlocks.retVal;
    return dbintervaltaggingFB;
  }

  DbIntervalTaggingFilterBuilder inValues(dynamic pValue) {
    dbintervaltaggingFB._addedBlocks = setCriteria(
        pValue,
        dbintervaltaggingFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbintervaltaggingFB._addedBlocks);
    _waitingNot = '';
    dbintervaltaggingFB
            ._addedBlocks.needEndBlock[dbintervaltaggingFB._blockIndex] =
        dbintervaltaggingFB._addedBlocks.retVal;
    return dbintervaltaggingFB;
  }
}
// endregion DbIntervalTaggingField

// region DbIntervalTaggingFilterBuilder
class DbIntervalTaggingFilterBuilder extends SearchCriteria {
  DbIntervalTaggingFilterBuilder(DbIntervalTagging obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbIntervalTagging _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbIntervalTaggingFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbIntervalTaggingFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbIntervalTaggingFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbIntervalTaggingFilterBuilder where(String whereCriteria,
      {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbIntervalTaggingFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbIntervalTaggingFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbIntervalTaggingFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbIntervalTaggingFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbIntervalTaggingFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbIntervalTaggingFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbIntervalTaggingFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbIntervalTaggingField setField(
      DbIntervalTaggingField field, String colName, DbType dbtype) {
    return DbIntervalTaggingField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbIntervalTaggingField _id;
  DbIntervalTaggingField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbIntervalTaggingField _system;
  DbIntervalTaggingField get system {
    return _system = setField(_system, 'system', DbType.bool);
  }

  DbIntervalTaggingField _tagsId;
  DbIntervalTaggingField get tagsId {
    return _tagsId = setField(_tagsId, 'tagsId', DbType.integer);
  }

  DbIntervalTaggingField _intervalsId;
  DbIntervalTaggingField get intervalsId {
    return _intervalsId = setField(_intervalsId, 'intervalsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbIntervalTagging._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbIntervalTagging> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (DbIntervalTagging._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbIntervalTagging
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbIntervalTagging.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from intervalTaggings ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbIntervalTagging.updateBatch(qparams, values);
  }

  /// This method always returns DbIntervalTagging Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbIntervalTagging>
  Future<DbIntervalTagging> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbIntervalTagging.toList(qparams);
    final data = await objFuture;
    DbIntervalTagging obj;
    if (data.isNotEmpty) {
      obj = DbIntervalTagging.fromMap(data[0] as Map<String, dynamic>);
      // final List<String> _loadedFields = loadedFields ?? [];

      // RELATIONSHIPS PRELOAD
      if (preload || loadParents) {
        loadedFields = loadedFields ?? [];
        if (/*!_loadedFields.contains('tags.plDbTag') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbTag'))) {
          /*_loadedFields.add('tags.plDbTag');*/
          obj.plDbTag = obj.plDbTag ??
              await obj.getDbTag(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
        if (/*!_loadedFields.contains('intervals.plDbInterval') && */ (preloadFields ==
                null ||
            loadParents ||
            preloadFields.contains('plDbInterval'))) {
          /*_loadedFields.add('intervals.plDbInterval');*/
          obj.plDbInterval = obj.plDbInterval ??
              await obj.getDbInterval(
                  loadParents: loadParents /*, loadedFields: _loadedFields*/);
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbIntervalTagging]
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) dbintervaltaggingCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbintervaltaggingsFuture =
        await _obj._mnDbIntervalTagging.toList(qparams);
    final int count = dbintervaltaggingsFuture[0]['CNT'] as int;
    if (dbintervaltaggingCount != null) {
      dbintervaltaggingCount(count);
    }
    return count;
  }

  /// This method returns List<DbIntervalTagging> [DbIntervalTagging]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbIntervalTagging>
  Future<List<DbIntervalTagging>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbIntervalTagging> dbintervaltaggingsData =
        await DbIntervalTagging.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return dbintervaltaggingsData;
  }

  /// This method returns Json String [DbIntervalTagging]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbIntervalTagging]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbIntervalTagging]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbIntervalTagging.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbIntervalTagging]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM intervalTaggings WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbIntervalTagging.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbIntervalTagging]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbIntervalTagging.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbIntervalTagging.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbIntervalTagging.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbIntervalTaggingFilterBuilder

// region DbIntervalTaggingFields
class DbIntervalTaggingFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fSystem;
  static TableField get system {
    return _fSystem =
        _fSystem ?? SqlSyntax.setField(_fSystem, 'system', DbType.bool);
  }

  static TableField _fTagsId;
  static TableField get tagsId {
    return _fTagsId =
        _fTagsId ?? SqlSyntax.setField(_fTagsId, 'tagsId', DbType.integer);
  }

  static TableField _fIntervalsId;
  static TableField get intervalsId {
    return _fIntervalsId = _fIntervalsId ??
        SqlSyntax.setField(_fIntervalsId, 'intervalsId', DbType.integer);
  }
}
// endregion DbIntervalTaggingFields

//region DbIntervalTaggingManager
class DbIntervalTaggingManager extends SqfEntityProvider {
  DbIntervalTaggingManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'intervalTaggings';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbIntervalTaggingManager
// region DbLog
class DbLog {
  DbLog(
      {this.id,
      this.dateTime,
      this.message,
      this.method,
      this.comment,
      this.stackTrace}) {
    _setDefaultValues();
  }
  DbLog.withFields(
      this.dateTime, this.message, this.method, this.comment, this.stackTrace) {
    _setDefaultValues();
  }
  DbLog.withId(this.id, this.dateTime, this.message, this.method, this.comment,
      this.stackTrace) {
    _setDefaultValues();
  }
  DbLog.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['dateTime'] != null) {
      dateTime = int.tryParse(o['dateTime'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['dateTime'].toString()))
          : DateTime.tryParse(o['dateTime'].toString());
    }
    if (o['message'] != null) {
      message = o['message'] as String;
    }
    if (o['method'] != null) {
      method = o['method'] as String;
    }
    if (o['comment'] != null) {
      comment = o['comment'] as String;
    }
    if (o['stackTrace'] != null) {
      stackTrace = o['stackTrace'] as String;
    }
  }
  // FIELDS (DbLog)
  int id;
  DateTime dateTime;
  String message;
  String method;
  String comment;
  String stackTrace;

  BoolResult saveResult;
  // end FIELDS (DbLog)

  static const bool _softDeleteActivated = false;
  DbLogManager __mnDbLog;

  DbLogManager get _mnDbLog {
    return __mnDbLog = __mnDbLog ?? DbLogManager();
  }

  // METHODS
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (dateTime != null) {
      map['dateTime'] = forJson
          ? dateTime.toString()
          : forQuery ? dateTime.millisecondsSinceEpoch : dateTime;
    }

    if (message != null) {
      map['message'] = message;
    }

    if (method != null) {
      map['method'] = method;
    }

    if (comment != null) {
      map['comment'] = comment;
    }

    if (stackTrace != null) {
      map['stackTrace'] = stackTrace;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (dateTime != null) {
      map['dateTime'] = forJson
          ? dateTime.toString()
          : forQuery ? dateTime.millisecondsSinceEpoch : dateTime;
    }

    if (message != null) {
      map['message'] = message;
    }

    if (method != null) {
      map['method'] = method;
    }

    if (comment != null) {
      map['comment'] = comment;
    }

    if (stackTrace != null) {
      map['stackTrace'] = stackTrace;
    }

    return map;
  }

  /// This method returns Json String [DbLog]
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DbLog]
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  List<dynamic> toArgs() {
    return [dateTime, message, method, comment, stackTrace];
  }

  List<dynamic> toArgsWithIds() {
    return [id, dateTime, message, method, comment, stackTrace];
  }

  static Future<List<DbLog>> fromWebUrl(String url,
      {Map<String, String> headers}) async {
    try {
      final response = await http.get(url, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR DbLog.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(String url, {Map<String, String> headers}) {
    return http.post(url, headers: headers, body: toJson());
  }

  static Future<List<DbLog>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbLog>[];
    try {
      objList = list
          .map((dblog) => DbLog.fromMap(dblog as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR DbLog.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DbLog>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields,
      bool setDefaultValues = true}) async {
    final List<DbLog> objList = <DbLog>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DbLog.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbLog by ID if exist, otherwise returns null
  ///
  /// Primary Keys: int id
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: getById(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>returns DbLog if exist, otherwise returns null
  Future<DbLog> getById(int id,
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    if (id == null) {
      return null;
    }
    DbLog obj;
    final data = await _mnDbLog.getById([id]);
    if (data.length != 0) {
      obj = DbLog.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbLog) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbLog.insert(this);
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDbLog.update(this);
    }

    return id;
  }

  /// saveAs DbLog. Returns a new Primary Key value of DbLog

  /// <returns>Returns a new Primary Key value of DbLog
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbLog> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DbLog> dblogs) async {
    // final results = _mnDbLog.saveAll('INSERT OR REPLACE INTO logs (id,dateTime, message, method, comment, stackTrace)  VALUES (?,?,?,?,?,?)',dblogs);
    // return results; removed in sqfentity_gen 1.3.0+6
    await DbEncrateia().batchStart();
    for (final obj in dblogs) {
      await obj.save();
    }
    //    return DbEncrateia().batchCommit();
    final result = await DbEncrateia().batchCommit();
    for (int i = 0; i < dblogs.length; i++) {
      if (dblogs[i].id == null) {
        dblogs[i].id = result[i] as int;
      }
    }

    return result;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> upsert() async {
    try {
      if (await _mnDbLog.rawInsert(
              'INSERT OR REPLACE INTO logs (id,dateTime, message, method, comment, stackTrace)  VALUES (?,?,?,?,?,?)',
              [id, dateTime, message, method, comment, stackTrace]) ==
          1) {
        saveResult = BoolResult(
            success: true, successMessage: 'DbLog id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbLog id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbLog Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbLog>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a BoolCommitResult
  Future<BoolCommitResult> upsertAll(List<DbLog> dblogs) async {
    final results = await _mnDbLog.rawInsertAll(
        'INSERT OR REPLACE INTO logs (id,dateTime, message, method, comment, stackTrace)  VALUES (?,?,?,?,?,?)',
        dblogs);
    return results;
  }

  /// Deletes DbLog

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbLog invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbLog
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbLog.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  DbLogFilterBuilder select({List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLogFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbLogFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLogFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dblog

// region DbLogField
class DbLogField extends SearchCriteria {
  DbLogField(this.dblogFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbLogFilterBuilder dblogFB;

  DbLogField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbLogFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dblogFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblogFB.parameters, param, SqlSyntax.EQuals,
            dblogFB._addedBlocks)
        : setCriteria(pValue, dblogFB.parameters, param, SqlSyntax.NotEQuals,
            dblogFB._addedBlocks);
    _waitingNot = '';
    dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
        dblogFB._addedBlocks.retVal;
    return dblogFB;
  }

  DbLogFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dblogFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblogFB.parameters, param, SqlSyntax.EQualsOrNull,
            dblogFB._addedBlocks)
        : setCriteria(pValue, dblogFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dblogFB._addedBlocks);
    _waitingNot = '';
    dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
        dblogFB._addedBlocks.retVal;
    return dblogFB;
  }

  DbLogFilterBuilder isNull() {
    dblogFB._addedBlocks = setCriteria(
        0,
        dblogFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dblogFB._addedBlocks);
    _waitingNot = '';
    dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
        dblogFB._addedBlocks.retVal;
    return dblogFB;
  }

  DbLogFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dblogFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dblogFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblogFB._addedBlocks);
      _waitingNot = '';
      dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
          dblogFB._addedBlocks.retVal;
    }
    return dblogFB;
  }

  DbLogFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dblogFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dblogFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblogFB._addedBlocks);
      _waitingNot = '';
      dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
          dblogFB._addedBlocks.retVal;
      dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
          dblogFB._addedBlocks.retVal;
    }
    return dblogFB;
  }

  DbLogFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dblogFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dblogFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblogFB._addedBlocks);
      _waitingNot = '';
      dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
          dblogFB._addedBlocks.retVal;
    }
    return dblogFB;
  }

  DbLogFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dblogFB._addedBlocks = setCriteria(
          pFirst,
          dblogFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblogFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dblogFB._addedBlocks = setCriteria(pFirst, dblogFB.parameters, param,
            SqlSyntax.LessThan, dblogFB._addedBlocks);
      } else {
        dblogFB._addedBlocks = setCriteria(pFirst, dblogFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblogFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dblogFB._addedBlocks = setCriteria(pLast, dblogFB.parameters, param,
            SqlSyntax.GreaterThan, dblogFB._addedBlocks);
      } else {
        dblogFB._addedBlocks = setCriteria(pLast, dblogFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblogFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
        dblogFB._addedBlocks.retVal;
    return dblogFB;
  }

  DbLogFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dblogFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblogFB.parameters, param, SqlSyntax.GreaterThan,
            dblogFB._addedBlocks)
        : setCriteria(pValue, dblogFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblogFB._addedBlocks);
    _waitingNot = '';
    dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
        dblogFB._addedBlocks.retVal;
    return dblogFB;
  }

  DbLogFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dblogFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblogFB.parameters, param, SqlSyntax.LessThan,
            dblogFB._addedBlocks)
        : setCriteria(pValue, dblogFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblogFB._addedBlocks);
    _waitingNot = '';
    dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
        dblogFB._addedBlocks.retVal;
    return dblogFB;
  }

  DbLogFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dblogFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblogFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblogFB._addedBlocks)
        : setCriteria(pValue, dblogFB.parameters, param, SqlSyntax.LessThan,
            dblogFB._addedBlocks);
    _waitingNot = '';
    dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
        dblogFB._addedBlocks.retVal;
    return dblogFB;
  }

  DbLogFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dblogFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblogFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblogFB._addedBlocks)
        : setCriteria(pValue, dblogFB.parameters, param, SqlSyntax.GreaterThan,
            dblogFB._addedBlocks);
    _waitingNot = '';
    dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
        dblogFB._addedBlocks.retVal;
    return dblogFB;
  }

  DbLogFilterBuilder inValues(dynamic pValue) {
    dblogFB._addedBlocks = setCriteria(
        pValue,
        dblogFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dblogFB._addedBlocks);
    _waitingNot = '';
    dblogFB._addedBlocks.needEndBlock[dblogFB._blockIndex] =
        dblogFB._addedBlocks.retVal;
    return dblogFB;
  }
}
// endregion DbLogField

// region DbLogFilterBuilder
class DbLogFilterBuilder extends SearchCriteria {
  DbLogFilterBuilder(DbLog obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbLog _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbLogFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbLogFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbLogFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) {
      _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    }
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbLogFilterBuilder where(String whereCriteria, {dynamic parameterValue}) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter(
          columnName: parameterValue == null ? null : '',
          hasParameter: parameterValue != null);
      _addedBlocks = setCriteria(parameterValue ?? 0, parameters, param,
          '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbLogFilterBuilder page(int page, int pagesize) {
    if (page > 0) {
      _page = page;
    }
    if (pagesize > 0) {
      _pagesize = pagesize;
    }
    return this;
  }

  /// int count = LIMIT
  DbLogFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbLogFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbLogFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbLogFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            orderByList.add(' $s desc ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbLogFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            groupByList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbLogFilterBuilder having(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        havingList.add(argFields);
      } else {
        for (String s in argFields as List<String>) {
          if (s != null && s.isNotEmpty) {
            havingList.add(' $s ');
          }
        }
      }
    }
    return this;
  }

  DbLogField setField(DbLogField field, String colName, DbType dbtype) {
    return DbLogField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbLogField _id;
  DbLogField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbLogField _dateTime;
  DbLogField get dateTime {
    return _dateTime = setField(_dateTime, 'dateTime', DbType.datetime);
  }

  DbLogField _message;
  DbLogField get message {
    return _message = setField(_message, 'message', DbType.text);
  }

  DbLogField _method;
  DbLogField get method {
    return _method = setField(_method, 'method', DbType.text);
  }

  DbLogField _comment;
  DbLogField get comment {
    return _comment = setField(_comment, 'comment', DbType.text);
  }

  DbLogField _stackTrace;
  DbLogField get stackTrace {
    return _stackTrace = setField(_stackTrace, 'stackTrace', DbType.text);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List && !param.hasParameter) {
          param.value = param.dbType == DbType.text
              ? '\'${param.value.join('\',\'')}\''
              : param.value.join(',');
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          if (param.value is Map<String, dynamic> &&
              param.value['sql'] != null) {
            param
              ..whereString = param.whereString
                  .replaceAll('?', param.value['sql'].toString())
              ..dbType = DbType.integer
              ..value = param.value['args'];
          }
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
            case DbType.datetimeUtc:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            if (param.value is List) {
              for (var p in param.value) {
                whereArguments.add(p);
              }
            } else {
              whereArguments.add(param.value);
            }
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbLog._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',')
      ..having = havingList.join(',');
  }

  /// Deletes List<DbLog> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();

    if (DbLog._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbLog.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbLog.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from logs ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbLog.updateBatch(qparams, values);
  }

  /// This method always returns DbLog Obj if exist, otherwise returns null
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toSingle(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbLog>
  Future<DbLog> toSingle(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbLog.toList(qparams);
    final data = await objFuture;
    DbLog obj;
    if (data.isNotEmpty) {
      obj = DbLog.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method returns int. [DbLog]
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dblogCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dblogsFuture = await _obj._mnDbLog.toList(qparams);
    final int count = dblogsFuture[0]['CNT'] as int;
    if (dblogCount != null) {
      dblogCount(count);
    }
    return count;
  }

  /// This method returns List<DbLog> [DbLog]
  ///
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  ///
  /// ex: toList(preload:true) -> Loads all related objects
  ///
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  ///
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  ///
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  ///
  /// <returns>List<DbLog>
  Future<List<DbLog>> toList(
      {bool preload = false,
      List<String> preloadFields,
      bool loadParents = false,
      List<String> loadedFields}) async {
    final data = await toMapList();
    final List<DbLog> dblogsData = await DbLog.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return dblogsData;
  }

  /// This method returns Json String [DbLog]
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DbLog]
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DbLog]
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbLog.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DbLog]
  ///
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  ///
  /// <returns>List<String>
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParameters = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParameters) {
      _buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM logs WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) {
      _buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbLog.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DbLog]
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject() async {
    _buildParameters();

    final objectFuture = _obj._mnDbLog.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbLog.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbLog.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbLogFilterBuilder

// region DbLogFields
class DbLogFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fDateTime;
  static TableField get dateTime {
    return _fDateTime = _fDateTime ??
        SqlSyntax.setField(_fDateTime, 'dateTime', DbType.datetime);
  }

  static TableField _fMessage;
  static TableField get message {
    return _fMessage =
        _fMessage ?? SqlSyntax.setField(_fMessage, 'message', DbType.text);
  }

  static TableField _fMethod;
  static TableField get method {
    return _fMethod =
        _fMethod ?? SqlSyntax.setField(_fMethod, 'method', DbType.text);
  }

  static TableField _fComment;
  static TableField get comment {
    return _fComment =
        _fComment ?? SqlSyntax.setField(_fComment, 'comment', DbType.text);
  }

  static TableField _fStackTrace;
  static TableField get stackTrace {
    return _fStackTrace = _fStackTrace ??
        SqlSyntax.setField(_fStackTrace, 'stackTrace', DbType.text);
  }
}
// endregion DbLogFields

//region DbLogManager
class DbLogManager extends SqfEntityProvider {
  DbLogManager()
      : super(DbEncrateia(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static final String _tableName = 'logs';
  static final List<String> _primaryKeyList = ['id'];
  static final String _whereStr = 'id=?';
}

//endregion DbLogManager
class DbEncrateiaSequenceManager extends SqfEntityProvider {
  DbEncrateiaSequenceManager() : super(DbEncrateia());
}
// END OF ENTITIES
