// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'model.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:DbAthlete.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// DbAthlete TABLE
class TableDbAthlete extends SqfEntityTableBase {
  TableDbAthlete() {
    // declare properties of EntityTable
    tableName = 'athletes';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('state', DbType.text, defaultValue: 'new'),
      SqfEntityFieldBase('firstName', DbType.text),
      SqfEntityFieldBase('lastName', DbType.text),
      SqfEntityFieldBase('stravaUsername', DbType.text),
      SqfEntityFieldBase('photoPath', DbType.text),
      SqfEntityFieldBase('stravaId', DbType.integer),
      SqfEntityFieldBase('geoState', DbType.text),
      SqfEntityFieldBase('downloadInterval', DbType.integer),
      SqfEntityFieldBase('recordAggregationCount', DbType.integer),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbAthlete();
  }
}

// DbActivity TABLE
class TableDbActivity extends SqfEntityTableBase {
  TableDbActivity() {
    // declare properties of EntityTable
    tableName = 'activities';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('state', DbType.text, defaultValue: 'new'),
      SqfEntityFieldBase('path', DbType.text),
      SqfEntityFieldBase('stravaId', DbType.integer),
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('movingTime', DbType.integer),
      SqfEntityFieldBase('type', DbType.text),
      SqfEntityFieldBase('distance', DbType.integer),
      SqfEntityFieldBase('serialNumber', DbType.integer),
      SqfEntityFieldBase('timeCreated', DbType.datetime),
      SqfEntityFieldBase('sportName', DbType.text),
      SqfEntityFieldBase('sport', DbType.text),
      SqfEntityFieldBase('subSport', DbType.text),
      SqfEntityFieldBase('timeStamp', DbType.datetime),
      SqfEntityFieldBase('startTime', DbType.datetime),
      SqfEntityFieldBase('startPositionLat', DbType.real),
      SqfEntityFieldBase('startPositionLong', DbType.real),
      SqfEntityFieldBase('event', DbType.text),
      SqfEntityFieldBase('eventType', DbType.text),
      SqfEntityFieldBase('eventGroup', DbType.integer),
      SqfEntityFieldBase('totalDistance', DbType.integer),
      SqfEntityFieldBase('totalStrides', DbType.integer),
      SqfEntityFieldBase('totalCalories', DbType.integer),
      SqfEntityFieldBase('avgSpeed', DbType.real),
      SqfEntityFieldBase('maxSpeed', DbType.real),
      SqfEntityFieldBase('totalAscent', DbType.integer),
      SqfEntityFieldBase('totalDescent', DbType.integer),
      SqfEntityFieldBase('maxRunningCadence', DbType.integer),
      SqfEntityFieldBase('trigger', DbType.text),
      SqfEntityFieldBase('avgTemperature', DbType.integer),
      SqfEntityFieldBase('maxTemperature', DbType.integer),
      SqfEntityFieldBase('avgFractionalCadence', DbType.real),
      SqfEntityFieldBase('maxFractionalCadence', DbType.real),
      SqfEntityFieldBase('totalFractionalCycles', DbType.real),
      SqfEntityFieldBase('avgStanceTimePercent', DbType.real),
      SqfEntityFieldBase('avgStanceTime', DbType.real),
      SqfEntityFieldBase('avgHeartRate', DbType.integer),
      SqfEntityFieldBase('maxHeartRate', DbType.integer),
      SqfEntityFieldBase('avgRunningCadence', DbType.real),
      SqfEntityFieldBase('avgVerticalOscillation', DbType.real),
      SqfEntityFieldBase('totalElapsedTime', DbType.integer),
      SqfEntityFieldBase('totalTimerTime', DbType.integer),
      SqfEntityFieldBase('totalTrainingEffect', DbType.integer),
      SqfEntityFieldBase('necLat', DbType.real),
      SqfEntityFieldBase('necLong', DbType.real),
      SqfEntityFieldBase('swcLat', DbType.real),
      SqfEntityFieldBase('swcLong', DbType.real),
      SqfEntityFieldBase('firstLapIndex', DbType.integer),
      SqfEntityFieldBase('numLaps', DbType.integer),
      SqfEntityFieldBase('numSessions', DbType.integer),
      SqfEntityFieldBase('localTimestamp', DbType.datetime),
      SqfEntityFieldBase('avgPower', DbType.real),
      SqfEntityFieldBase('minPower', DbType.integer),
      SqfEntityFieldBase('maxPower', DbType.integer),
      SqfEntityFieldBase('sdevPower', DbType.real),
      SqfEntityFieldBase('avgGroundTime', DbType.real),
      SqfEntityFieldBase('sdevGroundTime', DbType.real),
      SqfEntityFieldBase('avgLegSpringStiffness', DbType.real),
      SqfEntityFieldBase('sdevLegSpringStiffness', DbType.real),
      SqfEntityFieldBase('avgFormPower', DbType.real),
      SqfEntityFieldBase('sdevFormPower', DbType.real),
      SqfEntityFieldBase('avgPowerRatio', DbType.real),
      SqfEntityFieldBase('sdevPowerRatio', DbType.real),
      SqfEntityFieldBase('avgStrideRatio', DbType.real),
      SqfEntityFieldBase('sdevStrideRatio', DbType.real),
      SqfEntityFieldBase('avgStrydCadence', DbType.real),
      SqfEntityFieldBase('sdevStrydCadence', DbType.real),
      SqfEntityFieldBase('sdevVerticalOscillation', DbType.real),
      SqfEntityFieldRelationshipBase(
          TableDbAthlete.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'athletesId'),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbActivity();
  }
}

// DbEvent TABLE
class TableDbEvent extends SqfEntityTableBase {
  TableDbEvent() {
    // declare properties of EntityTable
    tableName = 'events';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('event', DbType.text),
      SqfEntityFieldBase('eventType', DbType.text),
      SqfEntityFieldBase('eventGroup', DbType.integer),
      SqfEntityFieldBase('timerTrigger', DbType.text),
      SqfEntityFieldBase('timeStamp', DbType.datetime),
      SqfEntityFieldBase('positionLat', DbType.real),
      SqfEntityFieldBase('positionLong', DbType.real),
      SqfEntityFieldBase('distance', DbType.real),
      SqfEntityFieldBase('altitude', DbType.real),
      SqfEntityFieldBase('speed', DbType.real),
      SqfEntityFieldBase('heartRate', DbType.integer),
      SqfEntityFieldBase('cadence', DbType.real),
      SqfEntityFieldBase('fractionalCadence', DbType.real),
      SqfEntityFieldBase('power', DbType.integer),
      SqfEntityFieldBase('strydCadence', DbType.real),
      SqfEntityFieldBase('groundTime', DbType.real),
      SqfEntityFieldBase('verticalOscillation', DbType.real),
      SqfEntityFieldBase('formPower', DbType.integer),
      SqfEntityFieldBase('legSpringStiffness', DbType.real),
      SqfEntityFieldBase('data', DbType.real),
      SqfEntityFieldRelationshipBase(
          TableDbActivity.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'activitiesId'),
      SqfEntityFieldRelationshipBase(TableDbLap.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'lapsId'),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbEvent();
  }
}

// DbLap TABLE
class TableDbLap extends SqfEntityTableBase {
  TableDbLap() {
    // declare properties of EntityTable
    tableName = 'laps';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('timeStamp', DbType.datetime),
      SqfEntityFieldBase('startTime', DbType.datetime),
      SqfEntityFieldBase('startPositionLat', DbType.real),
      SqfEntityFieldBase('startPositionLong', DbType.real),
      SqfEntityFieldBase('endPositionLat', DbType.real),
      SqfEntityFieldBase('endPositionLong', DbType.real),
      SqfEntityFieldBase('avgHeartRate', DbType.integer),
      SqfEntityFieldBase('maxHeartRate', DbType.integer),
      SqfEntityFieldBase('avgRunningCadence', DbType.real),
      SqfEntityFieldBase('event', DbType.text),
      SqfEntityFieldBase('eventType', DbType.text),
      SqfEntityFieldBase('eventGroup', DbType.integer),
      SqfEntityFieldBase('sport', DbType.text),
      SqfEntityFieldBase('subSport', DbType.text),
      SqfEntityFieldBase('avgVerticalOscillation', DbType.real),
      SqfEntityFieldBase('totalElapsedTime', DbType.integer),
      SqfEntityFieldBase('totalTimerTime', DbType.integer),
      SqfEntityFieldBase('totalDistance', DbType.integer),
      SqfEntityFieldBase('totalStrides', DbType.integer),
      SqfEntityFieldBase('totalCalories', DbType.integer),
      SqfEntityFieldBase('avgSpeed', DbType.real),
      SqfEntityFieldBase('maxSpeed', DbType.real),
      SqfEntityFieldBase('totalAscent', DbType.integer),
      SqfEntityFieldBase('totalDescent', DbType.integer),
      SqfEntityFieldBase('avgStanceTimePercent', DbType.real),
      SqfEntityFieldBase('avgStanceTime', DbType.real),
      SqfEntityFieldBase('maxRunningCadence', DbType.integer),
      SqfEntityFieldBase('intensity', DbType.integer),
      SqfEntityFieldBase('lapTrigger', DbType.text),
      SqfEntityFieldBase('avgTemperature', DbType.integer),
      SqfEntityFieldBase('maxTemperature', DbType.integer),
      SqfEntityFieldBase('avgFractionalCadence', DbType.real),
      SqfEntityFieldBase('maxFractionalCadence', DbType.real),
      SqfEntityFieldBase('totalFractionalCycles', DbType.real),
      SqfEntityFieldBase('avgPower', DbType.real),
      SqfEntityFieldBase('minPower', DbType.integer),
      SqfEntityFieldBase('maxPower', DbType.integer),
      SqfEntityFieldBase('sdevPower', DbType.real),
      SqfEntityFieldBase('avgGroundTime', DbType.real),
      SqfEntityFieldBase('sdevGroundTime', DbType.real),
      SqfEntityFieldBase('avgLegSpringStiffness', DbType.real),
      SqfEntityFieldBase('sdevLegSpringStiffness', DbType.real),
      SqfEntityFieldBase('avgFormPower', DbType.real),
      SqfEntityFieldBase('sdevFormPower', DbType.real),
      SqfEntityFieldBase('avgStrydCadence', DbType.real),
      SqfEntityFieldBase('sdevStrydCadence', DbType.real),
      SqfEntityFieldBase('sdevVerticalOscillation', DbType.real),
      SqfEntityFieldRelationshipBase(
          TableDbActivity.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'activitiesId'),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbLap();
  }
}

// DbWeight TABLE
class TableDbWeight extends SqfEntityTableBase {
  TableDbWeight() {
    // declare properties of EntityTable
    tableName = 'weights';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('date', DbType.date),
      SqfEntityFieldBase('value', DbType.real),
      SqfEntityFieldRelationshipBase(
          TableDbAthlete.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'athletesId'),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbWeight();
  }
}

// DbHeartRateZoneSchema TABLE
class TableDbHeartRateZoneSchema extends SqfEntityTableBase {
  TableDbHeartRateZoneSchema() {
    // declare properties of EntityTable
    tableName = 'heartRateZoneSchemata';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('date', DbType.date),
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('base', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableDbAthlete.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'athletesId'),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbHeartRateZoneSchema();
  }
}

// DbHeartRateZone TABLE
class TableDbHeartRateZone extends SqfEntityTableBase {
  TableDbHeartRateZone() {
    // declare properties of EntityTable
    tableName = 'heartRateZone';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('lowerPercentage', DbType.integer),
      SqfEntityFieldBase('upperPercentage', DbType.integer),
      SqfEntityFieldBase('lowerLimit', DbType.integer),
      SqfEntityFieldBase('upperLimit', DbType.integer),
      SqfEntityFieldBase('color', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableDbHeartRateZoneSchema.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'heartRateZoneSchemataId'),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbHeartRateZone();
  }
}

// DbPowerZoneSchema TABLE
class TableDbPowerZoneSchema extends SqfEntityTableBase {
  TableDbPowerZoneSchema() {
    // declare properties of EntityTable
    tableName = 'powerZoneSchemata';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('date', DbType.date),
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('base', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableDbAthlete.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'athletesId'),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbPowerZoneSchema();
  }
}

// DbPowerZone TABLE
class TableDbPowerZone extends SqfEntityTableBase {
  TableDbPowerZone() {
    // declare properties of EntityTable
    tableName = 'powerZone';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('name', DbType.text),
      SqfEntityFieldBase('lowerPercentage', DbType.integer),
      SqfEntityFieldBase('upperPercentage', DbType.integer),
      SqfEntityFieldBase('lowerLimit', DbType.integer),
      SqfEntityFieldBase('upperLimit', DbType.integer),
      SqfEntityFieldBase('color', DbType.integer),
      SqfEntityFieldRelationshipBase(
          TableDbPowerZoneSchema.getInstance, DeleteRule.CASCADE,
          defaultValue: 0, fieldName: 'powerZoneSchemataId'),
    ];
    super.init();
  }
  static SqfEntityTableBase _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDbPowerZone();
  }
}
// END TABLES

// BEGIN SEQUENCES
// END SEQUENCES

// BEGIN DATABASE MODEL
class DbEncrateia extends SqfEntityModelProvider {
  DbEncrateia() {
    databaseName = encrateia.databaseName;
    databaseTables = [
      TableDbAthlete.getInstance,
      TableDbActivity.getInstance,
      TableDbEvent.getInstance,
      TableDbLap.getInstance,
      TableDbWeight.getInstance,
      TableDbHeartRateZoneSchema.getInstance,
      TableDbHeartRateZone.getInstance,
      TableDbPowerZoneSchema.getInstance,
      TableDbPowerZone.getInstance,
    ];

    bundledDatabasePath = encrateia
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region DbAthlete
class DbAthlete {
  DbAthlete(
      {this.id,
      this.state,
      this.firstName,
      this.lastName,
      this.stravaUsername,
      this.photoPath,
      this.stravaId,
      this.geoState,
      this.downloadInterval,
      this.recordAggregationCount}) {
    _setDefaultValues();
  }
  DbAthlete.withFields(
      this.state,
      this.firstName,
      this.lastName,
      this.stravaUsername,
      this.photoPath,
      this.stravaId,
      this.geoState,
      this.downloadInterval,
      this.recordAggregationCount) {
    _setDefaultValues();
  }
  DbAthlete.withId(
      this.id,
      this.state,
      this.firstName,
      this.lastName,
      this.stravaUsername,
      this.photoPath,
      this.stravaId,
      this.geoState,
      this.downloadInterval,
      this.recordAggregationCount) {
    _setDefaultValues();
  }
  DbAthlete.fromMap(Map<String, dynamic> o) {
    _setDefaultValues();
    id = o['id'] as int;
    if (o['state'] != null) state = o['state'] as String;
    if (o['firstName'] != null) firstName = o['firstName'] as String;
    if (o['lastName'] != null) lastName = o['lastName'] as String;
    if (o['stravaUsername'] != null)
      stravaUsername = o['stravaUsername'] as String;
    if (o['photoPath'] != null) photoPath = o['photoPath'] as String;
    if (o['stravaId'] != null) stravaId = o['stravaId'] as int;
    if (o['geoState'] != null) geoState = o['geoState'] as String;
    if (o['downloadInterval'] != null)
      downloadInterval = o['downloadInterval'] as int;
    if (o['recordAggregationCount'] != null)
      recordAggregationCount = o['recordAggregationCount'] as int;
  }
  // FIELDS (DbAthlete)
  int id;
  String state;
  String firstName;
  String lastName;
  String stravaUsername;
  String photoPath;
  int stravaId;
  String geoState;
  int downloadInterval;
  int recordAggregationCount;

  BoolResult saveResult;
  // end FIELDS (DbAthlete)

// COLLECTIONS & VIRTUALS (DbAthlete)
  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbActivity> plDbActivities;

  /// get DbActivity(s) filtered by athletesId=id
  DbActivityFilterBuilder getDbActivities(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbActivity()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .athletesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbWeight> plDbWeights;

  /// get DbWeight(s) filtered by athletesId=id
  DbWeightFilterBuilder getDbWeights(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbWeight()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .athletesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbHeartRateZoneSchema> plDbHeartRateZoneSchemas;

  /// get DbHeartRateZoneSchema(s) filtered by athletesId=id
  DbHeartRateZoneSchemaFilterBuilder getDbHeartRateZoneSchemas(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbHeartRateZoneSchema()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .athletesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbPowerZoneSchema> plDbPowerZoneSchemas;

  /// get DbPowerZoneSchema(s) filtered by athletesId=id
  DbPowerZoneSchemaFilterBuilder getDbPowerZoneSchemas(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbPowerZoneSchema()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .athletesId
        .equals(id)
        .and;
  }
// END COLLECTIONS & VIRTUALS (DbAthlete)

  static const bool _softDeleteActivated = false;
  DbAthleteManager __mnDbAthlete;

  DbAthleteManager get _mnDbAthlete {
    return __mnDbAthlete = __mnDbAthlete ?? DbAthleteManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (firstName != null) {
      map['firstName'] = firstName;
    }

    if (lastName != null) {
      map['lastName'] = lastName;
    }

    if (stravaUsername != null) {
      map['stravaUsername'] = stravaUsername;
    }

    if (photoPath != null) {
      map['photoPath'] = photoPath;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (geoState != null) {
      map['geoState'] = geoState;
    }

    if (downloadInterval != null) {
      map['downloadInterval'] = downloadInterval;
    }

    if (recordAggregationCount != null) {
      map['recordAggregationCount'] = recordAggregationCount;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (firstName != null) {
      map['firstName'] = firstName;
    }

    if (lastName != null) {
      map['lastName'] = lastName;
    }

    if (stravaUsername != null) {
      map['stravaUsername'] = stravaUsername;
    }

    if (photoPath != null) {
      map['photoPath'] = photoPath;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (geoState != null) {
      map['geoState'] = geoState;
    }

    if (downloadInterval != null) {
      map['downloadInterval'] = downloadInterval;
    }

    if (recordAggregationCount != null) {
      map['recordAggregationCount'] = recordAggregationCount;
    }

// COLLECTIONS (DbAthlete)
    if (!forQuery) {
      map['DbActivities'] = await getDbActivities().toMapList();
    }
    if (!forQuery) {
      map['DbWeights'] = await getDbWeights().toMapList();
    }
    if (!forQuery) {
      map['DbHeartRateZoneSchemas'] =
          await getDbHeartRateZoneSchemas().toMapList();
    }
    if (!forQuery) {
      map['DbPowerZoneSchemas'] = await getDbPowerZoneSchemas().toMapList();
    }
// END COLLECTIONS (DbAthlete)

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      state,
      firstName,
      lastName,
      stravaUsername,
      photoPath,
      stravaId,
      geoState,
      downloadInterval,
      recordAggregationCount
    ];
  }

  static Future<List<DbAthlete>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbAthlete.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbAthlete>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbAthlete>[];
    try {
      objList = list
          .map((dbathlete) =>
              DbAthlete.fromMap(dbathlete as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbAthlete.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbAthlete>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbAthlete.fromMapList(data);
    } 
    */

  static Future<List<DbAthlete>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbAthlete> objList = <DbAthlete>[];
    for (final map in data) {
      final obj = DbAthlete.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivities')) {
          obj.plDbActivities =
              obj.plDbActivities ?? await obj.getDbActivities().toList();
        }
        if (preloadFields == null || preloadFields.contains('plDbWeights')) {
          obj.plDbWeights =
              obj.plDbWeights ?? await obj.getDbWeights().toList();
        }
        if (preloadFields == null ||
            preloadFields.contains('plDbHeartRateZoneSchemas')) {
          obj.plDbHeartRateZoneSchemas = obj.plDbHeartRateZoneSchemas ??
              await obj.getDbHeartRateZoneSchemas().toList();
        }
        if (preloadFields == null ||
            preloadFields.contains('plDbPowerZoneSchemas')) {
          obj.plDbPowerZoneSchemas = obj.plDbPowerZoneSchemas ??
              await obj.getDbPowerZoneSchemas().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbAthlete by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbAthlete if exist, otherwise returns null
  Future<DbAthlete> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbAthlete obj;
    final data = await _mnDbAthlete.getById(id);
    if (data.length != 0) {
      obj = DbAthlete.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbAthlete) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbAthlete.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbAthlete. Returns a new Primary Key value of DbAthlete

  /// <returns>Returns a new Primary Key value of DbAthlete
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbAthlete> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(List<DbAthlete> dbathletes) async {
    final results = _mnDbAthlete.saveAll(
        'INSERT OR REPLACE INTO athletes (id,  state, firstName, lastName, stravaUsername, photoPath, stravaId, geoState, downloadInterval, recordAggregationCount)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        dbathletes);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbAthlete.rawInsert(
              'INSERT OR REPLACE INTO athletes (id,  state, firstName, lastName, stravaUsername, photoPath, stravaId, geoState, downloadInterval, recordAggregationCount)  VALUES (?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                state,
                firstName,
                lastName,
                stravaUsername,
                photoPath,
                stravaId,
                geoState,
                downloadInterval,
                recordAggregationCount
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbAthlete id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbAthlete id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbAthlete Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbAthlete>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(List<DbAthlete> dbathletes) async {
    final results = await _mnDbAthlete.rawInsertAll(
        'INSERT OR REPLACE INTO athletes (id,  state, firstName, lastName, stravaUsername, photoPath, stravaId, geoState, downloadInterval, recordAggregationCount)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        dbathletes);
    return results;
  }

  /// Deletes DbAthlete

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbAthlete invoked (id=$id)');
    var result = BoolResult();
    {
      result =
          await DbActivity().select().athletesId.equals(id).delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result =
          await DbWeight().select().athletesId.equals(id).delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbHeartRateZoneSchema()
          .select()
          .athletesId
          .equals(id)
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result = await DbPowerZoneSchema()
          .select()
          .athletesId
          .equals(id)
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbAthlete
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbAthlete.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbAthleteFilterBuilder _Select;
  DbAthleteFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbAthleteFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbAthleteFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbAthleteFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    state = state ?? 'new';
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbathlete

// region DbAthleteField
class DbAthleteField extends SearchCriteria {
  DbAthleteField(this.dbathleteFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbAthleteFilterBuilder dbathleteFB;

  DbAthleteField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbAthleteFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param, SqlSyntax.EQuals,
            dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.NotEQuals, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder isNull() {
    dbathleteFB._addedBlocks = setCriteria(
        0,
        dbathleteFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbathleteFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbathleteFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks);
      _waitingNot = '';
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
    }
    return dbathleteFB;
  }

  DbAthleteFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbathleteFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbathleteFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks);
      _waitingNot = '';
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
    }
    return dbathleteFB;
  }

  DbAthleteFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbathleteFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbathleteFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks);
      _waitingNot = '';
      dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
          dbathleteFB._addedBlocks.retVal;
    }
    return dbathleteFB;
  }

  DbAthleteFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbathleteFB._addedBlocks = setCriteria(
          pFirst,
          dbathleteFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbathleteFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbathleteFB._addedBlocks = setCriteria(pFirst, dbathleteFB.parameters,
            param, SqlSyntax.LessThan, dbathleteFB._addedBlocks);
      } else {
        dbathleteFB._addedBlocks = setCriteria(pFirst, dbathleteFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbathleteFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbathleteFB._addedBlocks = setCriteria(pLast, dbathleteFB.parameters,
            param, SqlSyntax.GreaterThan, dbathleteFB._addedBlocks);
      } else {
        dbathleteFB._addedBlocks = setCriteria(pLast, dbathleteFB.parameters,
            param, SqlSyntax.LessThanOrEquals, dbathleteFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThan, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param, SqlSyntax.LessThan,
            dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param, SqlSyntax.LessThan,
            dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbathleteFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbathleteFB._addedBlocks)
        : setCriteria(pValue, dbathleteFB.parameters, param,
            SqlSyntax.GreaterThan, dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }

  DbAthleteFilterBuilder inValues(dynamic pValue) {
    dbathleteFB._addedBlocks = setCriteria(
        pValue,
        dbathleteFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbathleteFB._addedBlocks);
    _waitingNot = '';
    dbathleteFB._addedBlocks.needEndBlock[dbathleteFB._blockIndex] =
        dbathleteFB._addedBlocks.retVal;
    return dbathleteFB;
  }
}
// endregion DbAthleteField

// region DbAthleteFilterBuilder
class DbAthleteFilterBuilder extends SearchCriteria {
  DbAthleteFilterBuilder(DbAthlete obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbAthlete _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbAthleteFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbAthleteFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbAthleteFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbAthleteFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbAthleteFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbAthleteFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbAthleteFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbAthleteFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbAthleteFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbAthleteFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbAthleteField setField(DbAthleteField field, String colName, DbType dbtype) {
    return DbAthleteField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbAthleteField _id;
  DbAthleteField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbAthleteField _state;
  DbAthleteField get state {
    return _state = setField(_state, 'state', DbType.text);
  }

  DbAthleteField _firstName;
  DbAthleteField get firstName {
    return _firstName = setField(_firstName, 'firstName', DbType.text);
  }

  DbAthleteField _lastName;
  DbAthleteField get lastName {
    return _lastName = setField(_lastName, 'lastName', DbType.text);
  }

  DbAthleteField _stravaUsername;
  DbAthleteField get stravaUsername {
    return _stravaUsername =
        setField(_stravaUsername, 'stravaUsername', DbType.text);
  }

  DbAthleteField _photoPath;
  DbAthleteField get photoPath {
    return _photoPath = setField(_photoPath, 'photoPath', DbType.text);
  }

  DbAthleteField _stravaId;
  DbAthleteField get stravaId {
    return _stravaId = setField(_stravaId, 'stravaId', DbType.integer);
  }

  DbAthleteField _geoState;
  DbAthleteField get geoState {
    return _geoState = setField(_geoState, 'geoState', DbType.text);
  }

  DbAthleteField _downloadInterval;
  DbAthleteField get downloadInterval {
    return _downloadInterval =
        setField(_downloadInterval, 'downloadInterval', DbType.integer);
  }

  DbAthleteField _recordAggregationCount;
  DbAthleteField get recordAggregationCount {
    return _recordAggregationCount = setField(
        _recordAggregationCount, 'recordAggregationCount', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbAthlete._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbAthlete> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbAthlete._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbAthlete.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbAthlete.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from athletes ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbAthlete.updateBatch(qparams, values);
  }

  /// This method always returns DbAthleteObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbAthlete>
  Future<DbAthlete> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbAthlete.toList(qparams);
    final data = await objFuture;
    DbAthlete obj;
    if (data.isNotEmpty) {
      obj = DbAthlete.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivities')) {
          obj.plDbActivities =
              obj.plDbActivities ?? await obj.getDbActivities().toList();
        }
        if (preloadFields == null || preloadFields.contains('plDbWeights')) {
          obj.plDbWeights =
              obj.plDbWeights ?? await obj.getDbWeights().toList();
        }
        if (preloadFields == null ||
            preloadFields.contains('plDbHeartRateZoneSchemas')) {
          obj.plDbHeartRateZoneSchemas = obj.plDbHeartRateZoneSchemas ??
              await obj.getDbHeartRateZoneSchemas().toList();
        }
        if (preloadFields == null ||
            preloadFields.contains('plDbPowerZoneSchemas')) {
          obj.plDbPowerZoneSchemas = obj.plDbPowerZoneSchemas ??
              await obj.getDbPowerZoneSchemas().toList();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbathleteCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbathletesFuture = await _obj._mnDbAthlete.toList(qparams);
    final int count = dbathletesFuture[0]['CNT'] as int;
    if (dbathleteCount != null) {
      dbathleteCount(count);
    }
    return count;
  }

  /// This method always returns List<DbAthlete>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbAthlete>
  Future<List<DbAthlete>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbAthlete> dbathletesData =
        await DbAthlete.fromMapList(data, preload: preload);
    return dbathletesData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbAthlete.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbAthlete>>
  Future<List<DropdownMenuItem<DbAthlete>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbAthlete>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dbathletesFuture = _obj._mnDbAthlete.toList(qparams);

    final data = await dbathletesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbAthlete>> items = []..add(DropdownMenuItem(
        value: DbAthlete(),
        child: Text('Select DbAthlete'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbAthlete.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dbathletesFuture = _obj._mnDbAthlete.toList(qparams);

    final data = await dbathletesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbAthlete'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbAthlete.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbAthlete.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbAthlete.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbAthlete.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbAthleteFilterBuilder

// region DbAthleteFields
class DbAthleteFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fState;
  static TableField get state {
    return _fState =
        _fState ?? SqlSyntax.setField(_fState, 'state', DbType.text);
  }

  static TableField _fFirstName;
  static TableField get firstName {
    return _fFirstName = _fFirstName ??
        SqlSyntax.setField(_fFirstName, 'firstName', DbType.text);
  }

  static TableField _fLastName;
  static TableField get lastName {
    return _fLastName =
        _fLastName ?? SqlSyntax.setField(_fLastName, 'lastName', DbType.text);
  }

  static TableField _fStravaUsername;
  static TableField get stravaUsername {
    return _fStravaUsername = _fStravaUsername ??
        SqlSyntax.setField(_fStravaUsername, 'stravaUsername', DbType.text);
  }

  static TableField _fPhotoPath;
  static TableField get photoPath {
    return _fPhotoPath = _fPhotoPath ??
        SqlSyntax.setField(_fPhotoPath, 'photoPath', DbType.text);
  }

  static TableField _fStravaId;
  static TableField get stravaId {
    return _fStravaId = _fStravaId ??
        SqlSyntax.setField(_fStravaId, 'stravaId', DbType.integer);
  }

  static TableField _fGeoState;
  static TableField get geoState {
    return _fGeoState =
        _fGeoState ?? SqlSyntax.setField(_fGeoState, 'geoState', DbType.text);
  }

  static TableField _fDownloadInterval;
  static TableField get downloadInterval {
    return _fDownloadInterval = _fDownloadInterval ??
        SqlSyntax.setField(
            _fDownloadInterval, 'downloadInterval', DbType.integer);
  }

  static TableField _fRecordAggregationCount;
  static TableField get recordAggregationCount {
    return _fRecordAggregationCount = _fRecordAggregationCount ??
        SqlSyntax.setField(
            _fRecordAggregationCount, 'recordAggregationCount', DbType.integer);
  }
}
// endregion DbAthleteFields

//region DbAthleteManager
class DbAthleteManager extends SqfEntityProvider {
  DbAthleteManager()
      : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'athletes';
  static String _colId = 'id';
}

//endregion DbAthleteManager
// region DbActivity
class DbActivity {
  DbActivity(
      {this.id,
      this.state,
      this.path,
      this.stravaId,
      this.name,
      this.movingTime,
      this.type,
      this.distance,
      this.serialNumber,
      this.timeCreated,
      this.sportName,
      this.sport,
      this.subSport,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.event,
      this.eventType,
      this.eventGroup,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.maxRunningCadence,
      this.trigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalTrainingEffect,
      this.necLat,
      this.necLong,
      this.swcLat,
      this.swcLong,
      this.firstLapIndex,
      this.numLaps,
      this.numSessions,
      this.localTimestamp,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrideRatio,
      this.sdevStrideRatio,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.athletesId}) {
    _setDefaultValues();
  }
  DbActivity.withFields(
      this.state,
      this.path,
      this.stravaId,
      this.name,
      this.movingTime,
      this.type,
      this.distance,
      this.serialNumber,
      this.timeCreated,
      this.sportName,
      this.sport,
      this.subSport,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.event,
      this.eventType,
      this.eventGroup,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.maxRunningCadence,
      this.trigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalTrainingEffect,
      this.necLat,
      this.necLong,
      this.swcLat,
      this.swcLong,
      this.firstLapIndex,
      this.numLaps,
      this.numSessions,
      this.localTimestamp,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrideRatio,
      this.sdevStrideRatio,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.athletesId) {
    _setDefaultValues();
  }
  DbActivity.withId(
      this.id,
      this.state,
      this.path,
      this.stravaId,
      this.name,
      this.movingTime,
      this.type,
      this.distance,
      this.serialNumber,
      this.timeCreated,
      this.sportName,
      this.sport,
      this.subSport,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.event,
      this.eventType,
      this.eventGroup,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.maxRunningCadence,
      this.trigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalTrainingEffect,
      this.necLat,
      this.necLong,
      this.swcLat,
      this.swcLong,
      this.firstLapIndex,
      this.numLaps,
      this.numSessions,
      this.localTimestamp,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgPowerRatio,
      this.sdevPowerRatio,
      this.avgStrideRatio,
      this.sdevStrideRatio,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.athletesId) {
    _setDefaultValues();
  }
  DbActivity.fromMap(Map<String, dynamic> o) {
    _setDefaultValues();
    id = o['id'] as int;
    if (o['state'] != null) state = o['state'] as String;
    if (o['path'] != null) path = o['path'] as String;
    if (o['stravaId'] != null) stravaId = o['stravaId'] as int;
    if (o['name'] != null) name = o['name'] as String;
    if (o['movingTime'] != null) movingTime = o['movingTime'] as int;
    if (o['type'] != null) type = o['type'] as String;
    if (o['distance'] != null) distance = o['distance'] as int;
    if (o['serialNumber'] != null) serialNumber = o['serialNumber'] as int;
    if (o['timeCreated'] != null)
      timeCreated = int.tryParse(o['timeCreated'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(o['timeCreated'] as int)
          : DateTime.tryParse(o['timeCreated'].toString());
    if (o['sportName'] != null) sportName = o['sportName'] as String;
    if (o['sport'] != null) sport = o['sport'] as String;
    if (o['subSport'] != null) subSport = o['subSport'] as String;
    if (o['timeStamp'] != null)
      timeStamp = int.tryParse(o['timeStamp'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(o['timeStamp'] as int)
          : DateTime.tryParse(o['timeStamp'].toString());
    if (o['startTime'] != null)
      startTime = int.tryParse(o['startTime'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(o['startTime'] as int)
          : DateTime.tryParse(o['startTime'].toString());
    if (o['startPositionLat'] != null)
      startPositionLat = double.tryParse(o['startPositionLat'].toString());
    if (o['startPositionLong'] != null)
      startPositionLong = double.tryParse(o['startPositionLong'].toString());
    if (o['event'] != null) event = o['event'] as String;
    if (o['eventType'] != null) eventType = o['eventType'] as String;
    if (o['eventGroup'] != null) eventGroup = o['eventGroup'] as int;
    if (o['totalDistance'] != null) totalDistance = o['totalDistance'] as int;
    if (o['totalStrides'] != null) totalStrides = o['totalStrides'] as int;
    if (o['totalCalories'] != null) totalCalories = o['totalCalories'] as int;
    if (o['avgSpeed'] != null)
      avgSpeed = double.tryParse(o['avgSpeed'].toString());
    if (o['maxSpeed'] != null)
      maxSpeed = double.tryParse(o['maxSpeed'].toString());
    if (o['totalAscent'] != null) totalAscent = o['totalAscent'] as int;
    if (o['totalDescent'] != null) totalDescent = o['totalDescent'] as int;
    if (o['maxRunningCadence'] != null)
      maxRunningCadence = o['maxRunningCadence'] as int;
    if (o['trigger'] != null) trigger = o['trigger'] as String;
    if (o['avgTemperature'] != null)
      avgTemperature = o['avgTemperature'] as int;
    if (o['maxTemperature'] != null)
      maxTemperature = o['maxTemperature'] as int;
    if (o['avgFractionalCadence'] != null)
      avgFractionalCadence =
          double.tryParse(o['avgFractionalCadence'].toString());
    if (o['maxFractionalCadence'] != null)
      maxFractionalCadence =
          double.tryParse(o['maxFractionalCadence'].toString());
    if (o['totalFractionalCycles'] != null)
      totalFractionalCycles =
          double.tryParse(o['totalFractionalCycles'].toString());
    if (o['avgStanceTimePercent'] != null)
      avgStanceTimePercent =
          double.tryParse(o['avgStanceTimePercent'].toString());
    if (o['avgStanceTime'] != null)
      avgStanceTime = double.tryParse(o['avgStanceTime'].toString());
    if (o['avgHeartRate'] != null) avgHeartRate = o['avgHeartRate'] as int;
    if (o['maxHeartRate'] != null) maxHeartRate = o['maxHeartRate'] as int;
    if (o['avgRunningCadence'] != null)
      avgRunningCadence = double.tryParse(o['avgRunningCadence'].toString());
    if (o['avgVerticalOscillation'] != null)
      avgVerticalOscillation =
          double.tryParse(o['avgVerticalOscillation'].toString());
    if (o['totalElapsedTime'] != null)
      totalElapsedTime = o['totalElapsedTime'] as int;
    if (o['totalTimerTime'] != null)
      totalTimerTime = o['totalTimerTime'] as int;
    if (o['totalTrainingEffect'] != null)
      totalTrainingEffect = o['totalTrainingEffect'] as int;
    if (o['necLat'] != null) necLat = double.tryParse(o['necLat'].toString());
    if (o['necLong'] != null)
      necLong = double.tryParse(o['necLong'].toString());
    if (o['swcLat'] != null) swcLat = double.tryParse(o['swcLat'].toString());
    if (o['swcLong'] != null)
      swcLong = double.tryParse(o['swcLong'].toString());
    if (o['firstLapIndex'] != null) firstLapIndex = o['firstLapIndex'] as int;
    if (o['numLaps'] != null) numLaps = o['numLaps'] as int;
    if (o['numSessions'] != null) numSessions = o['numSessions'] as int;
    if (o['localTimestamp'] != null)
      localTimestamp = int.tryParse(o['localTimestamp'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(o['localTimestamp'] as int)
          : DateTime.tryParse(o['localTimestamp'].toString());
    if (o['avgPower'] != null)
      avgPower = double.tryParse(o['avgPower'].toString());
    if (o['minPower'] != null) minPower = o['minPower'] as int;
    if (o['maxPower'] != null) maxPower = o['maxPower'] as int;
    if (o['sdevPower'] != null)
      sdevPower = double.tryParse(o['sdevPower'].toString());
    if (o['avgGroundTime'] != null)
      avgGroundTime = double.tryParse(o['avgGroundTime'].toString());
    if (o['sdevGroundTime'] != null)
      sdevGroundTime = double.tryParse(o['sdevGroundTime'].toString());
    if (o['avgLegSpringStiffness'] != null)
      avgLegSpringStiffness =
          double.tryParse(o['avgLegSpringStiffness'].toString());
    if (o['sdevLegSpringStiffness'] != null)
      sdevLegSpringStiffness =
          double.tryParse(o['sdevLegSpringStiffness'].toString());
    if (o['avgFormPower'] != null)
      avgFormPower = double.tryParse(o['avgFormPower'].toString());
    if (o['sdevFormPower'] != null)
      sdevFormPower = double.tryParse(o['sdevFormPower'].toString());
    if (o['avgPowerRatio'] != null)
      avgPowerRatio = double.tryParse(o['avgPowerRatio'].toString());
    if (o['sdevPowerRatio'] != null)
      sdevPowerRatio = double.tryParse(o['sdevPowerRatio'].toString());
    if (o['avgStrideRatio'] != null)
      avgStrideRatio = double.tryParse(o['avgStrideRatio'].toString());
    if (o['sdevStrideRatio'] != null)
      sdevStrideRatio = double.tryParse(o['sdevStrideRatio'].toString());
    if (o['avgStrydCadence'] != null)
      avgStrydCadence = double.tryParse(o['avgStrydCadence'].toString());
    if (o['sdevStrydCadence'] != null)
      sdevStrydCadence = double.tryParse(o['sdevStrydCadence'].toString());
    if (o['sdevVerticalOscillation'] != null)
      sdevVerticalOscillation =
          double.tryParse(o['sdevVerticalOscillation'].toString());
    athletesId = o['athletesId'] as int;

    // RELATIONSHIPS FromMAP
    plDbAthlete = o['DbAthlete'] != null
        ? DbAthlete.fromMap(o['DbAthlete'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbActivity)
  int id;
  String state;
  String path;
  int stravaId;
  String name;
  int movingTime;
  String type;
  int distance;
  int serialNumber;
  DateTime timeCreated;
  String sportName;
  String sport;
  String subSport;
  DateTime timeStamp;
  DateTime startTime;
  double startPositionLat;
  double startPositionLong;
  String event;
  String eventType;
  int eventGroup;
  int totalDistance;
  int totalStrides;
  int totalCalories;
  double avgSpeed;
  double maxSpeed;
  int totalAscent;
  int totalDescent;
  int maxRunningCadence;
  String trigger;
  int avgTemperature;
  int maxTemperature;
  double avgFractionalCadence;
  double maxFractionalCadence;
  double totalFractionalCycles;
  double avgStanceTimePercent;
  double avgStanceTime;
  int avgHeartRate;
  int maxHeartRate;
  double avgRunningCadence;
  double avgVerticalOscillation;
  int totalElapsedTime;
  int totalTimerTime;
  int totalTrainingEffect;
  double necLat;
  double necLong;
  double swcLat;
  double swcLong;
  int firstLapIndex;
  int numLaps;
  int numSessions;
  DateTime localTimestamp;
  double avgPower;
  int minPower;
  int maxPower;
  double sdevPower;
  double avgGroundTime;
  double sdevGroundTime;
  double avgLegSpringStiffness;
  double sdevLegSpringStiffness;
  double avgFormPower;
  double sdevFormPower;
  double avgPowerRatio;
  double sdevPowerRatio;
  double avgStrideRatio;
  double sdevStrideRatio;
  double avgStrydCadence;
  double sdevStrydCadence;
  double sdevVerticalOscillation;
  int athletesId;

  BoolResult saveResult;
  // end FIELDS (DbActivity)

// RELATIONSHIPS (DbActivity)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbAthlete plDbAthlete;

  /// get DbAthlete By AthletesId
  Future<DbAthlete> getDbAthlete() async {
    final _obj = await DbAthlete().getById(athletesId);
    return _obj;
  }
  // END RELATIONSHIPS (DbActivity)

// COLLECTIONS & VIRTUALS (DbActivity)
  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbEvent> plDbEvents;

  /// get DbEvent(s) filtered by activitiesId=id
  DbEventFilterBuilder getDbEvents(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbEvent()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .activitiesId
        .equals(id)
        .and;
  }

  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbLap> plDbLaps;

  /// get DbLap(s) filtered by activitiesId=id
  DbLapFilterBuilder getDbLaps(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLap()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .activitiesId
        .equals(id)
        .and;
  }
// END COLLECTIONS & VIRTUALS (DbActivity)

  static const bool _softDeleteActivated = false;
  DbActivityManager __mnDbActivity;

  DbActivityManager get _mnDbActivity {
    return __mnDbActivity = __mnDbActivity ?? DbActivityManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (path != null) {
      map['path'] = path;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (movingTime != null) {
      map['movingTime'] = movingTime;
    }

    if (type != null) {
      map['type'] = type;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (serialNumber != null) {
      map['serialNumber'] = serialNumber;
    }

    if (timeCreated != null) {
      map['timeCreated'] = forJson
          ? timeCreated.toUtc().toString()
          : forQuery ? timeCreated.millisecondsSinceEpoch : timeCreated;
    }

    if (sportName != null) {
      map['sportName'] = sportName;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toUtc().toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (trigger != null) {
      map['trigger'] = trigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalTrainingEffect != null) {
      map['totalTrainingEffect'] = totalTrainingEffect;
    }

    if (necLat != null) {
      map['necLat'] = necLat;
    }

    if (necLong != null) {
      map['necLong'] = necLong;
    }

    if (swcLat != null) {
      map['swcLat'] = swcLat;
    }

    if (swcLong != null) {
      map['swcLong'] = swcLong;
    }

    if (firstLapIndex != null) {
      map['firstLapIndex'] = firstLapIndex;
    }

    if (numLaps != null) {
      map['numLaps'] = numLaps;
    }

    if (numSessions != null) {
      map['numSessions'] = numSessions;
    }

    if (localTimestamp != null) {
      map['localTimestamp'] = forJson
          ? localTimestamp.toUtc().toString()
          : forQuery ? localTimestamp.millisecondsSinceEpoch : localTimestamp;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgPowerRatio != null) {
      map['avgPowerRatio'] = avgPowerRatio;
    }

    if (sdevPowerRatio != null) {
      map['sdevPowerRatio'] = sdevPowerRatio;
    }

    if (avgStrideRatio != null) {
      map['avgStrideRatio'] = avgStrideRatio;
    }

    if (sdevStrideRatio != null) {
      map['sdevStrideRatio'] = sdevStrideRatio;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (athletesId != null) {
      map['athletesId'] = athletesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (state != null) {
      map['state'] = state;
    }

    if (path != null) {
      map['path'] = path;
    }

    if (stravaId != null) {
      map['stravaId'] = stravaId;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (movingTime != null) {
      map['movingTime'] = movingTime;
    }

    if (type != null) {
      map['type'] = type;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (serialNumber != null) {
      map['serialNumber'] = serialNumber;
    }

    if (timeCreated != null) {
      map['timeCreated'] = forJson
          ? timeCreated.toUtc().toString()
          : forQuery ? timeCreated.millisecondsSinceEpoch : timeCreated;
    }

    if (sportName != null) {
      map['sportName'] = sportName;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toUtc().toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (trigger != null) {
      map['trigger'] = trigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalTrainingEffect != null) {
      map['totalTrainingEffect'] = totalTrainingEffect;
    }

    if (necLat != null) {
      map['necLat'] = necLat;
    }

    if (necLong != null) {
      map['necLong'] = necLong;
    }

    if (swcLat != null) {
      map['swcLat'] = swcLat;
    }

    if (swcLong != null) {
      map['swcLong'] = swcLong;
    }

    if (firstLapIndex != null) {
      map['firstLapIndex'] = firstLapIndex;
    }

    if (numLaps != null) {
      map['numLaps'] = numLaps;
    }

    if (numSessions != null) {
      map['numSessions'] = numSessions;
    }

    if (localTimestamp != null) {
      map['localTimestamp'] = forJson
          ? localTimestamp.toUtc().toString()
          : forQuery ? localTimestamp.millisecondsSinceEpoch : localTimestamp;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgPowerRatio != null) {
      map['avgPowerRatio'] = avgPowerRatio;
    }

    if (sdevPowerRatio != null) {
      map['sdevPowerRatio'] = sdevPowerRatio;
    }

    if (avgStrideRatio != null) {
      map['avgStrideRatio'] = avgStrideRatio;
    }

    if (sdevStrideRatio != null) {
      map['sdevStrideRatio'] = sdevStrideRatio;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (athletesId != null) {
      map['athletesId'] = athletesId;
    }

// COLLECTIONS (DbActivity)
    if (!forQuery) {
      map['DbEvents'] = await getDbEvents().toMapList();
    }
    if (!forQuery) {
      map['DbLaps'] = await getDbLaps().toMapList();
    }
// END COLLECTIONS (DbActivity)

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      state,
      path,
      stravaId,
      name,
      movingTime,
      type,
      distance,
      serialNumber,
      timeCreated != null ? timeCreated.millisecondsSinceEpoch : null,
      sportName,
      sport,
      subSport,
      timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
      startTime != null ? startTime.millisecondsSinceEpoch : null,
      startPositionLat,
      startPositionLong,
      event,
      eventType,
      eventGroup,
      totalDistance,
      totalStrides,
      totalCalories,
      avgSpeed,
      maxSpeed,
      totalAscent,
      totalDescent,
      maxRunningCadence,
      trigger,
      avgTemperature,
      maxTemperature,
      avgFractionalCadence,
      maxFractionalCadence,
      totalFractionalCycles,
      avgStanceTimePercent,
      avgStanceTime,
      avgHeartRate,
      maxHeartRate,
      avgRunningCadence,
      avgVerticalOscillation,
      totalElapsedTime,
      totalTimerTime,
      totalTrainingEffect,
      necLat,
      necLong,
      swcLat,
      swcLong,
      firstLapIndex,
      numLaps,
      numSessions,
      localTimestamp != null ? localTimestamp.millisecondsSinceEpoch : null,
      avgPower,
      minPower,
      maxPower,
      sdevPower,
      avgGroundTime,
      sdevGroundTime,
      avgLegSpringStiffness,
      sdevLegSpringStiffness,
      avgFormPower,
      sdevFormPower,
      avgPowerRatio,
      sdevPowerRatio,
      avgStrideRatio,
      sdevStrideRatio,
      avgStrydCadence,
      sdevStrydCadence,
      sdevVerticalOscillation,
      athletesId
    ];
  }

  static Future<List<DbActivity>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbActivity.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbActivity>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbActivity>[];
    try {
      objList = list
          .map((dbactivity) =>
              DbActivity.fromMap(dbactivity as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbActivity.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbActivity>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbActivity.fromMapList(data);
    } 
    */

  static Future<List<DbActivity>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbActivity> objList = <DbActivity>[];
    for (final map in data) {
      final obj = DbActivity.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbEvents')) {
          obj.plDbEvents = obj.plDbEvents ?? await obj.getDbEvents().toList();
        }
        if (preloadFields == null || preloadFields.contains('plDbLaps')) {
          obj.plDbLaps = obj.plDbLaps ?? await obj.getDbLaps().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbAthlete')) {
          obj.plDbAthlete = obj.plDbAthlete ?? await obj.getDbAthlete();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbActivity by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbActivity if exist, otherwise returns null
  Future<DbActivity> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbActivity obj;
    final data = await _mnDbActivity.getById(id);
    if (data.length != 0) {
      obj = DbActivity.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbActivity) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbActivity.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbActivity. Returns a new Primary Key value of DbActivity

  /// <returns>Returns a new Primary Key value of DbActivity
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbActivity> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(List<DbActivity> dbactivities) async {
    final results = _mnDbActivity.saveAll(
        'INSERT OR REPLACE INTO activities (id,  state, path, stravaId, name, movingTime, type, distance, serialNumber, timeCreated, sportName, sport, subSport, timeStamp, startTime, startPositionLat, startPositionLong, event, eventType, eventGroup, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, maxRunningCadence, trigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgStanceTimePercent, avgStanceTime, avgHeartRate, maxHeartRate, avgRunningCadence, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalTrainingEffect, necLat, necLong, swcLat, swcLong, firstLapIndex, numLaps, numSessions, localTimestamp, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgPowerRatio, sdevPowerRatio, avgStrideRatio, sdevStrideRatio, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, athletesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbactivities);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbActivity.rawInsert(
              'INSERT OR REPLACE INTO activities (id,  state, path, stravaId, name, movingTime, type, distance, serialNumber, timeCreated, sportName, sport, subSport, timeStamp, startTime, startPositionLat, startPositionLong, event, eventType, eventGroup, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, maxRunningCadence, trigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgStanceTimePercent, avgStanceTime, avgHeartRate, maxHeartRate, avgRunningCadence, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalTrainingEffect, necLat, necLong, swcLat, swcLong, firstLapIndex, numLaps, numSessions, localTimestamp, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgPowerRatio, sdevPowerRatio, avgStrideRatio, sdevStrideRatio, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, athletesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                state,
                path,
                stravaId,
                name,
                movingTime,
                type,
                distance,
                serialNumber,
                timeCreated != null ? timeCreated.millisecondsSinceEpoch : null,
                sportName,
                sport,
                subSport,
                timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
                startTime != null ? startTime.millisecondsSinceEpoch : null,
                startPositionLat,
                startPositionLong,
                event,
                eventType,
                eventGroup,
                totalDistance,
                totalStrides,
                totalCalories,
                avgSpeed,
                maxSpeed,
                totalAscent,
                totalDescent,
                maxRunningCadence,
                trigger,
                avgTemperature,
                maxTemperature,
                avgFractionalCadence,
                maxFractionalCadence,
                totalFractionalCycles,
                avgStanceTimePercent,
                avgStanceTime,
                avgHeartRate,
                maxHeartRate,
                avgRunningCadence,
                avgVerticalOscillation,
                totalElapsedTime,
                totalTimerTime,
                totalTrainingEffect,
                necLat,
                necLong,
                swcLat,
                swcLong,
                firstLapIndex,
                numLaps,
                numSessions,
                localTimestamp != null
                    ? localTimestamp.millisecondsSinceEpoch
                    : null,
                avgPower,
                minPower,
                maxPower,
                sdevPower,
                avgGroundTime,
                sdevGroundTime,
                avgLegSpringStiffness,
                sdevLegSpringStiffness,
                avgFormPower,
                sdevFormPower,
                avgPowerRatio,
                sdevPowerRatio,
                avgStrideRatio,
                sdevStrideRatio,
                avgStrydCadence,
                sdevStrydCadence,
                sdevVerticalOscillation,
                athletesId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbActivity id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbActivity id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbActivity Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbActivity>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(List<DbActivity> dbactivities) async {
    final results = await _mnDbActivity.rawInsertAll(
        'INSERT OR REPLACE INTO activities (id,  state, path, stravaId, name, movingTime, type, distance, serialNumber, timeCreated, sportName, sport, subSport, timeStamp, startTime, startPositionLat, startPositionLong, event, eventType, eventGroup, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, maxRunningCadence, trigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgStanceTimePercent, avgStanceTime, avgHeartRate, maxHeartRate, avgRunningCadence, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalTrainingEffect, necLat, necLong, swcLat, swcLong, firstLapIndex, numLaps, numSessions, localTimestamp, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgPowerRatio, sdevPowerRatio, avgStrideRatio, sdevStrideRatio, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, athletesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbactivities);
    return results;
  }

  /// Deletes DbActivity

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbActivity invoked (id=$id)');
    var result = BoolResult();
    {
      result =
          await DbEvent().select().activitiesId.equals(id).delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    {
      result =
          await DbLap().select().activitiesId.equals(id).delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbActivity
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbActivity.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbActivityFilterBuilder _Select;
  DbActivityFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbActivityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbActivityFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbActivityFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    state = state ?? 'new';
    athletesId = athletesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbactivity

// region DbActivityField
class DbActivityField extends SearchCriteria {
  DbActivityField(this.dbactivityFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbActivityFilterBuilder dbactivityFB;

  DbActivityField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbActivityFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param, SqlSyntax.EQuals,
            dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.NotEQuals, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder isNull() {
    dbactivityFB._addedBlocks = setCriteria(
        0,
        dbactivityFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbactivityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbactivityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks);
      _waitingNot = '';
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
    }
    return dbactivityFB;
  }

  DbActivityFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbactivityFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbactivityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks);
      _waitingNot = '';
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
    }
    return dbactivityFB;
  }

  DbActivityFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbactivityFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbactivityFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks);
      _waitingNot = '';
      dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
          dbactivityFB._addedBlocks.retVal;
    }
    return dbactivityFB;
  }

  DbActivityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbactivityFB._addedBlocks = setCriteria(
          pFirst,
          dbactivityFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbactivityFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbactivityFB._addedBlocks = setCriteria(pFirst, dbactivityFB.parameters,
            param, SqlSyntax.LessThan, dbactivityFB._addedBlocks);
      } else {
        dbactivityFB._addedBlocks = setCriteria(pFirst, dbactivityFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbactivityFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbactivityFB._addedBlocks = setCriteria(pLast, dbactivityFB.parameters,
            param, SqlSyntax.GreaterThan, dbactivityFB._addedBlocks);
      } else {
        dbactivityFB._addedBlocks = setCriteria(pLast, dbactivityFB.parameters,
            param, SqlSyntax.LessThanOrEquals, dbactivityFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThan, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThan, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThan, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbactivityFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbactivityFB._addedBlocks)
        : setCriteria(pValue, dbactivityFB.parameters, param,
            SqlSyntax.GreaterThan, dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }

  DbActivityFilterBuilder inValues(dynamic pValue) {
    dbactivityFB._addedBlocks = setCriteria(
        pValue,
        dbactivityFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbactivityFB._addedBlocks);
    _waitingNot = '';
    dbactivityFB._addedBlocks.needEndBlock[dbactivityFB._blockIndex] =
        dbactivityFB._addedBlocks.retVal;
    return dbactivityFB;
  }
}
// endregion DbActivityField

// region DbActivityFilterBuilder
class DbActivityFilterBuilder extends SearchCriteria {
  DbActivityFilterBuilder(DbActivity obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbActivity _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbActivityFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbActivityFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbActivityFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbActivityFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbActivityFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbActivityFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbActivityFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbActivityFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbActivityFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbActivityFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbActivityField setField(
      DbActivityField field, String colName, DbType dbtype) {
    return DbActivityField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbActivityField _id;
  DbActivityField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbActivityField _state;
  DbActivityField get state {
    return _state = setField(_state, 'state', DbType.text);
  }

  DbActivityField _path;
  DbActivityField get path {
    return _path = setField(_path, 'path', DbType.text);
  }

  DbActivityField _stravaId;
  DbActivityField get stravaId {
    return _stravaId = setField(_stravaId, 'stravaId', DbType.integer);
  }

  DbActivityField _name;
  DbActivityField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbActivityField _movingTime;
  DbActivityField get movingTime {
    return _movingTime = setField(_movingTime, 'movingTime', DbType.integer);
  }

  DbActivityField _type;
  DbActivityField get type {
    return _type = setField(_type, 'type', DbType.text);
  }

  DbActivityField _distance;
  DbActivityField get distance {
    return _distance = setField(_distance, 'distance', DbType.integer);
  }

  DbActivityField _serialNumber;
  DbActivityField get serialNumber {
    return _serialNumber =
        setField(_serialNumber, 'serialNumber', DbType.integer);
  }

  DbActivityField _timeCreated;
  DbActivityField get timeCreated {
    return _timeCreated =
        setField(_timeCreated, 'timeCreated', DbType.datetime);
  }

  DbActivityField _sportName;
  DbActivityField get sportName {
    return _sportName = setField(_sportName, 'sportName', DbType.text);
  }

  DbActivityField _sport;
  DbActivityField get sport {
    return _sport = setField(_sport, 'sport', DbType.text);
  }

  DbActivityField _subSport;
  DbActivityField get subSport {
    return _subSport = setField(_subSport, 'subSport', DbType.text);
  }

  DbActivityField _timeStamp;
  DbActivityField get timeStamp {
    return _timeStamp = setField(_timeStamp, 'timeStamp', DbType.datetime);
  }

  DbActivityField _startTime;
  DbActivityField get startTime {
    return _startTime = setField(_startTime, 'startTime', DbType.datetime);
  }

  DbActivityField _startPositionLat;
  DbActivityField get startPositionLat {
    return _startPositionLat =
        setField(_startPositionLat, 'startPositionLat', DbType.real);
  }

  DbActivityField _startPositionLong;
  DbActivityField get startPositionLong {
    return _startPositionLong =
        setField(_startPositionLong, 'startPositionLong', DbType.real);
  }

  DbActivityField _event;
  DbActivityField get event {
    return _event = setField(_event, 'event', DbType.text);
  }

  DbActivityField _eventType;
  DbActivityField get eventType {
    return _eventType = setField(_eventType, 'eventType', DbType.text);
  }

  DbActivityField _eventGroup;
  DbActivityField get eventGroup {
    return _eventGroup = setField(_eventGroup, 'eventGroup', DbType.integer);
  }

  DbActivityField _totalDistance;
  DbActivityField get totalDistance {
    return _totalDistance =
        setField(_totalDistance, 'totalDistance', DbType.integer);
  }

  DbActivityField _totalStrides;
  DbActivityField get totalStrides {
    return _totalStrides =
        setField(_totalStrides, 'totalStrides', DbType.integer);
  }

  DbActivityField _totalCalories;
  DbActivityField get totalCalories {
    return _totalCalories =
        setField(_totalCalories, 'totalCalories', DbType.integer);
  }

  DbActivityField _avgSpeed;
  DbActivityField get avgSpeed {
    return _avgSpeed = setField(_avgSpeed, 'avgSpeed', DbType.real);
  }

  DbActivityField _maxSpeed;
  DbActivityField get maxSpeed {
    return _maxSpeed = setField(_maxSpeed, 'maxSpeed', DbType.real);
  }

  DbActivityField _totalAscent;
  DbActivityField get totalAscent {
    return _totalAscent = setField(_totalAscent, 'totalAscent', DbType.integer);
  }

  DbActivityField _totalDescent;
  DbActivityField get totalDescent {
    return _totalDescent =
        setField(_totalDescent, 'totalDescent', DbType.integer);
  }

  DbActivityField _maxRunningCadence;
  DbActivityField get maxRunningCadence {
    return _maxRunningCadence =
        setField(_maxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  DbActivityField _trigger;
  DbActivityField get trigger {
    return _trigger = setField(_trigger, 'trigger', DbType.text);
  }

  DbActivityField _avgTemperature;
  DbActivityField get avgTemperature {
    return _avgTemperature =
        setField(_avgTemperature, 'avgTemperature', DbType.integer);
  }

  DbActivityField _maxTemperature;
  DbActivityField get maxTemperature {
    return _maxTemperature =
        setField(_maxTemperature, 'maxTemperature', DbType.integer);
  }

  DbActivityField _avgFractionalCadence;
  DbActivityField get avgFractionalCadence {
    return _avgFractionalCadence =
        setField(_avgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  DbActivityField _maxFractionalCadence;
  DbActivityField get maxFractionalCadence {
    return _maxFractionalCadence =
        setField(_maxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  DbActivityField _totalFractionalCycles;
  DbActivityField get totalFractionalCycles {
    return _totalFractionalCycles =
        setField(_totalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  DbActivityField _avgStanceTimePercent;
  DbActivityField get avgStanceTimePercent {
    return _avgStanceTimePercent =
        setField(_avgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  DbActivityField _avgStanceTime;
  DbActivityField get avgStanceTime {
    return _avgStanceTime =
        setField(_avgStanceTime, 'avgStanceTime', DbType.real);
  }

  DbActivityField _avgHeartRate;
  DbActivityField get avgHeartRate {
    return _avgHeartRate =
        setField(_avgHeartRate, 'avgHeartRate', DbType.integer);
  }

  DbActivityField _maxHeartRate;
  DbActivityField get maxHeartRate {
    return _maxHeartRate =
        setField(_maxHeartRate, 'maxHeartRate', DbType.integer);
  }

  DbActivityField _avgRunningCadence;
  DbActivityField get avgRunningCadence {
    return _avgRunningCadence =
        setField(_avgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  DbActivityField _avgVerticalOscillation;
  DbActivityField get avgVerticalOscillation {
    return _avgVerticalOscillation = setField(
        _avgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  DbActivityField _totalElapsedTime;
  DbActivityField get totalElapsedTime {
    return _totalElapsedTime =
        setField(_totalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  DbActivityField _totalTimerTime;
  DbActivityField get totalTimerTime {
    return _totalTimerTime =
        setField(_totalTimerTime, 'totalTimerTime', DbType.integer);
  }

  DbActivityField _totalTrainingEffect;
  DbActivityField get totalTrainingEffect {
    return _totalTrainingEffect =
        setField(_totalTrainingEffect, 'totalTrainingEffect', DbType.integer);
  }

  DbActivityField _necLat;
  DbActivityField get necLat {
    return _necLat = setField(_necLat, 'necLat', DbType.real);
  }

  DbActivityField _necLong;
  DbActivityField get necLong {
    return _necLong = setField(_necLong, 'necLong', DbType.real);
  }

  DbActivityField _swcLat;
  DbActivityField get swcLat {
    return _swcLat = setField(_swcLat, 'swcLat', DbType.real);
  }

  DbActivityField _swcLong;
  DbActivityField get swcLong {
    return _swcLong = setField(_swcLong, 'swcLong', DbType.real);
  }

  DbActivityField _firstLapIndex;
  DbActivityField get firstLapIndex {
    return _firstLapIndex =
        setField(_firstLapIndex, 'firstLapIndex', DbType.integer);
  }

  DbActivityField _numLaps;
  DbActivityField get numLaps {
    return _numLaps = setField(_numLaps, 'numLaps', DbType.integer);
  }

  DbActivityField _numSessions;
  DbActivityField get numSessions {
    return _numSessions = setField(_numSessions, 'numSessions', DbType.integer);
  }

  DbActivityField _localTimestamp;
  DbActivityField get localTimestamp {
    return _localTimestamp =
        setField(_localTimestamp, 'localTimestamp', DbType.datetime);
  }

  DbActivityField _avgPower;
  DbActivityField get avgPower {
    return _avgPower = setField(_avgPower, 'avgPower', DbType.real);
  }

  DbActivityField _minPower;
  DbActivityField get minPower {
    return _minPower = setField(_minPower, 'minPower', DbType.integer);
  }

  DbActivityField _maxPower;
  DbActivityField get maxPower {
    return _maxPower = setField(_maxPower, 'maxPower', DbType.integer);
  }

  DbActivityField _sdevPower;
  DbActivityField get sdevPower {
    return _sdevPower = setField(_sdevPower, 'sdevPower', DbType.real);
  }

  DbActivityField _avgGroundTime;
  DbActivityField get avgGroundTime {
    return _avgGroundTime =
        setField(_avgGroundTime, 'avgGroundTime', DbType.real);
  }

  DbActivityField _sdevGroundTime;
  DbActivityField get sdevGroundTime {
    return _sdevGroundTime =
        setField(_sdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  DbActivityField _avgLegSpringStiffness;
  DbActivityField get avgLegSpringStiffness {
    return _avgLegSpringStiffness =
        setField(_avgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  DbActivityField _sdevLegSpringStiffness;
  DbActivityField get sdevLegSpringStiffness {
    return _sdevLegSpringStiffness = setField(
        _sdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  DbActivityField _avgFormPower;
  DbActivityField get avgFormPower {
    return _avgFormPower = setField(_avgFormPower, 'avgFormPower', DbType.real);
  }

  DbActivityField _sdevFormPower;
  DbActivityField get sdevFormPower {
    return _sdevFormPower =
        setField(_sdevFormPower, 'sdevFormPower', DbType.real);
  }

  DbActivityField _avgPowerRatio;
  DbActivityField get avgPowerRatio {
    return _avgPowerRatio =
        setField(_avgPowerRatio, 'avgPowerRatio', DbType.real);
  }

  DbActivityField _sdevPowerRatio;
  DbActivityField get sdevPowerRatio {
    return _sdevPowerRatio =
        setField(_sdevPowerRatio, 'sdevPowerRatio', DbType.real);
  }

  DbActivityField _avgStrideRatio;
  DbActivityField get avgStrideRatio {
    return _avgStrideRatio =
        setField(_avgStrideRatio, 'avgStrideRatio', DbType.real);
  }

  DbActivityField _sdevStrideRatio;
  DbActivityField get sdevStrideRatio {
    return _sdevStrideRatio =
        setField(_sdevStrideRatio, 'sdevStrideRatio', DbType.real);
  }

  DbActivityField _avgStrydCadence;
  DbActivityField get avgStrydCadence {
    return _avgStrydCadence =
        setField(_avgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  DbActivityField _sdevStrydCadence;
  DbActivityField get sdevStrydCadence {
    return _sdevStrydCadence =
        setField(_sdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  DbActivityField _sdevVerticalOscillation;
  DbActivityField get sdevVerticalOscillation {
    return _sdevVerticalOscillation = setField(
        _sdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  DbActivityField _athletesId;
  DbActivityField get athletesId {
    return _athletesId = setField(_athletesId, 'athletesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbActivity._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbActivity> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbActivity._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbActivity.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbActivity.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from activities ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbActivity.updateBatch(qparams, values);
  }

  /// This method always returns DbActivityObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbActivity>
  Future<DbActivity> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbActivity.toList(qparams);
    final data = await objFuture;
    DbActivity obj;
    if (data.isNotEmpty) {
      obj = DbActivity.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbEvents')) {
          obj.plDbEvents = obj.plDbEvents ?? await obj.getDbEvents().toList();
        }
        if (preloadFields == null || preloadFields.contains('plDbLaps')) {
          obj.plDbLaps = obj.plDbLaps ?? await obj.getDbLaps().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbAthlete')) {
          obj.plDbAthlete = obj.plDbAthlete ?? await obj.getDbAthlete();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbactivityCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbactivitiesFuture = await _obj._mnDbActivity.toList(qparams);
    final int count = dbactivitiesFuture[0]['CNT'] as int;
    if (dbactivityCount != null) {
      dbactivityCount(count);
    }
    return count;
  }

  /// This method always returns List<DbActivity>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbActivity>
  Future<List<DbActivity>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbActivity> dbactivitiesData =
        await DbActivity.fromMapList(data, preload: preload);
    return dbactivitiesData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbActivity.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbActivity>>
  Future<List<DropdownMenuItem<DbActivity>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbActivity>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dbactivitiesFuture = _obj._mnDbActivity.toList(qparams);

    final data = await dbactivitiesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbActivity>> items = []..add(DropdownMenuItem(
        value: DbActivity(),
        child: Text('Select DbActivity'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbActivity.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dbactivitiesFuture = _obj._mnDbActivity.toList(qparams);

    final data = await dbactivitiesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbActivity'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbActivity.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbActivity.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbActivity.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbActivity.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbActivityFilterBuilder

// region DbActivityFields
class DbActivityFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fState;
  static TableField get state {
    return _fState =
        _fState ?? SqlSyntax.setField(_fState, 'state', DbType.text);
  }

  static TableField _fPath;
  static TableField get path {
    return _fPath = _fPath ?? SqlSyntax.setField(_fPath, 'path', DbType.text);
  }

  static TableField _fStravaId;
  static TableField get stravaId {
    return _fStravaId = _fStravaId ??
        SqlSyntax.setField(_fStravaId, 'stravaId', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fMovingTime;
  static TableField get movingTime {
    return _fMovingTime = _fMovingTime ??
        SqlSyntax.setField(_fMovingTime, 'movingTime', DbType.integer);
  }

  static TableField _fType;
  static TableField get type {
    return _fType = _fType ?? SqlSyntax.setField(_fType, 'type', DbType.text);
  }

  static TableField _fDistance;
  static TableField get distance {
    return _fDistance = _fDistance ??
        SqlSyntax.setField(_fDistance, 'distance', DbType.integer);
  }

  static TableField _fSerialNumber;
  static TableField get serialNumber {
    return _fSerialNumber = _fSerialNumber ??
        SqlSyntax.setField(_fSerialNumber, 'serialNumber', DbType.integer);
  }

  static TableField _fTimeCreated;
  static TableField get timeCreated {
    return _fTimeCreated = _fTimeCreated ??
        SqlSyntax.setField(_fTimeCreated, 'timeCreated', DbType.datetime);
  }

  static TableField _fSportName;
  static TableField get sportName {
    return _fSportName = _fSportName ??
        SqlSyntax.setField(_fSportName, 'sportName', DbType.text);
  }

  static TableField _fSport;
  static TableField get sport {
    return _fSport =
        _fSport ?? SqlSyntax.setField(_fSport, 'sport', DbType.text);
  }

  static TableField _fSubSport;
  static TableField get subSport {
    return _fSubSport =
        _fSubSport ?? SqlSyntax.setField(_fSubSport, 'subSport', DbType.text);
  }

  static TableField _fTimeStamp;
  static TableField get timeStamp {
    return _fTimeStamp = _fTimeStamp ??
        SqlSyntax.setField(_fTimeStamp, 'timeStamp', DbType.datetime);
  }

  static TableField _fStartTime;
  static TableField get startTime {
    return _fStartTime = _fStartTime ??
        SqlSyntax.setField(_fStartTime, 'startTime', DbType.datetime);
  }

  static TableField _fStartPositionLat;
  static TableField get startPositionLat {
    return _fStartPositionLat = _fStartPositionLat ??
        SqlSyntax.setField(_fStartPositionLat, 'startPositionLat', DbType.real);
  }

  static TableField _fStartPositionLong;
  static TableField get startPositionLong {
    return _fStartPositionLong = _fStartPositionLong ??
        SqlSyntax.setField(
            _fStartPositionLong, 'startPositionLong', DbType.real);
  }

  static TableField _fEvent;
  static TableField get event {
    return _fEvent =
        _fEvent ?? SqlSyntax.setField(_fEvent, 'event', DbType.text);
  }

  static TableField _fEventType;
  static TableField get eventType {
    return _fEventType = _fEventType ??
        SqlSyntax.setField(_fEventType, 'eventType', DbType.text);
  }

  static TableField _fEventGroup;
  static TableField get eventGroup {
    return _fEventGroup = _fEventGroup ??
        SqlSyntax.setField(_fEventGroup, 'eventGroup', DbType.integer);
  }

  static TableField _fTotalDistance;
  static TableField get totalDistance {
    return _fTotalDistance = _fTotalDistance ??
        SqlSyntax.setField(_fTotalDistance, 'totalDistance', DbType.integer);
  }

  static TableField _fTotalStrides;
  static TableField get totalStrides {
    return _fTotalStrides = _fTotalStrides ??
        SqlSyntax.setField(_fTotalStrides, 'totalStrides', DbType.integer);
  }

  static TableField _fTotalCalories;
  static TableField get totalCalories {
    return _fTotalCalories = _fTotalCalories ??
        SqlSyntax.setField(_fTotalCalories, 'totalCalories', DbType.integer);
  }

  static TableField _fAvgSpeed;
  static TableField get avgSpeed {
    return _fAvgSpeed =
        _fAvgSpeed ?? SqlSyntax.setField(_fAvgSpeed, 'avgSpeed', DbType.real);
  }

  static TableField _fMaxSpeed;
  static TableField get maxSpeed {
    return _fMaxSpeed =
        _fMaxSpeed ?? SqlSyntax.setField(_fMaxSpeed, 'maxSpeed', DbType.real);
  }

  static TableField _fTotalAscent;
  static TableField get totalAscent {
    return _fTotalAscent = _fTotalAscent ??
        SqlSyntax.setField(_fTotalAscent, 'totalAscent', DbType.integer);
  }

  static TableField _fTotalDescent;
  static TableField get totalDescent {
    return _fTotalDescent = _fTotalDescent ??
        SqlSyntax.setField(_fTotalDescent, 'totalDescent', DbType.integer);
  }

  static TableField _fMaxRunningCadence;
  static TableField get maxRunningCadence {
    return _fMaxRunningCadence = _fMaxRunningCadence ??
        SqlSyntax.setField(
            _fMaxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  static TableField _fTrigger;
  static TableField get trigger {
    return _fTrigger =
        _fTrigger ?? SqlSyntax.setField(_fTrigger, 'trigger', DbType.text);
  }

  static TableField _fAvgTemperature;
  static TableField get avgTemperature {
    return _fAvgTemperature = _fAvgTemperature ??
        SqlSyntax.setField(_fAvgTemperature, 'avgTemperature', DbType.integer);
  }

  static TableField _fMaxTemperature;
  static TableField get maxTemperature {
    return _fMaxTemperature = _fMaxTemperature ??
        SqlSyntax.setField(_fMaxTemperature, 'maxTemperature', DbType.integer);
  }

  static TableField _fAvgFractionalCadence;
  static TableField get avgFractionalCadence {
    return _fAvgFractionalCadence = _fAvgFractionalCadence ??
        SqlSyntax.setField(
            _fAvgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  static TableField _fMaxFractionalCadence;
  static TableField get maxFractionalCadence {
    return _fMaxFractionalCadence = _fMaxFractionalCadence ??
        SqlSyntax.setField(
            _fMaxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  static TableField _fTotalFractionalCycles;
  static TableField get totalFractionalCycles {
    return _fTotalFractionalCycles = _fTotalFractionalCycles ??
        SqlSyntax.setField(
            _fTotalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  static TableField _fAvgStanceTimePercent;
  static TableField get avgStanceTimePercent {
    return _fAvgStanceTimePercent = _fAvgStanceTimePercent ??
        SqlSyntax.setField(
            _fAvgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  static TableField _fAvgStanceTime;
  static TableField get avgStanceTime {
    return _fAvgStanceTime = _fAvgStanceTime ??
        SqlSyntax.setField(_fAvgStanceTime, 'avgStanceTime', DbType.real);
  }

  static TableField _fAvgHeartRate;
  static TableField get avgHeartRate {
    return _fAvgHeartRate = _fAvgHeartRate ??
        SqlSyntax.setField(_fAvgHeartRate, 'avgHeartRate', DbType.integer);
  }

  static TableField _fMaxHeartRate;
  static TableField get maxHeartRate {
    return _fMaxHeartRate = _fMaxHeartRate ??
        SqlSyntax.setField(_fMaxHeartRate, 'maxHeartRate', DbType.integer);
  }

  static TableField _fAvgRunningCadence;
  static TableField get avgRunningCadence {
    return _fAvgRunningCadence = _fAvgRunningCadence ??
        SqlSyntax.setField(
            _fAvgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  static TableField _fAvgVerticalOscillation;
  static TableField get avgVerticalOscillation {
    return _fAvgVerticalOscillation = _fAvgVerticalOscillation ??
        SqlSyntax.setField(
            _fAvgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  static TableField _fTotalElapsedTime;
  static TableField get totalElapsedTime {
    return _fTotalElapsedTime = _fTotalElapsedTime ??
        SqlSyntax.setField(
            _fTotalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  static TableField _fTotalTimerTime;
  static TableField get totalTimerTime {
    return _fTotalTimerTime = _fTotalTimerTime ??
        SqlSyntax.setField(_fTotalTimerTime, 'totalTimerTime', DbType.integer);
  }

  static TableField _fTotalTrainingEffect;
  static TableField get totalTrainingEffect {
    return _fTotalTrainingEffect = _fTotalTrainingEffect ??
        SqlSyntax.setField(
            _fTotalTrainingEffect, 'totalTrainingEffect', DbType.integer);
  }

  static TableField _fNecLat;
  static TableField get necLat {
    return _fNecLat =
        _fNecLat ?? SqlSyntax.setField(_fNecLat, 'necLat', DbType.real);
  }

  static TableField _fNecLong;
  static TableField get necLong {
    return _fNecLong =
        _fNecLong ?? SqlSyntax.setField(_fNecLong, 'necLong', DbType.real);
  }

  static TableField _fSwcLat;
  static TableField get swcLat {
    return _fSwcLat =
        _fSwcLat ?? SqlSyntax.setField(_fSwcLat, 'swcLat', DbType.real);
  }

  static TableField _fSwcLong;
  static TableField get swcLong {
    return _fSwcLong =
        _fSwcLong ?? SqlSyntax.setField(_fSwcLong, 'swcLong', DbType.real);
  }

  static TableField _fFirstLapIndex;
  static TableField get firstLapIndex {
    return _fFirstLapIndex = _fFirstLapIndex ??
        SqlSyntax.setField(_fFirstLapIndex, 'firstLapIndex', DbType.integer);
  }

  static TableField _fNumLaps;
  static TableField get numLaps {
    return _fNumLaps =
        _fNumLaps ?? SqlSyntax.setField(_fNumLaps, 'numLaps', DbType.integer);
  }

  static TableField _fNumSessions;
  static TableField get numSessions {
    return _fNumSessions = _fNumSessions ??
        SqlSyntax.setField(_fNumSessions, 'numSessions', DbType.integer);
  }

  static TableField _fLocalTimestamp;
  static TableField get localTimestamp {
    return _fLocalTimestamp = _fLocalTimestamp ??
        SqlSyntax.setField(_fLocalTimestamp, 'localTimestamp', DbType.datetime);
  }

  static TableField _fAvgPower;
  static TableField get avgPower {
    return _fAvgPower =
        _fAvgPower ?? SqlSyntax.setField(_fAvgPower, 'avgPower', DbType.real);
  }

  static TableField _fMinPower;
  static TableField get minPower {
    return _fMinPower = _fMinPower ??
        SqlSyntax.setField(_fMinPower, 'minPower', DbType.integer);
  }

  static TableField _fMaxPower;
  static TableField get maxPower {
    return _fMaxPower = _fMaxPower ??
        SqlSyntax.setField(_fMaxPower, 'maxPower', DbType.integer);
  }

  static TableField _fSdevPower;
  static TableField get sdevPower {
    return _fSdevPower = _fSdevPower ??
        SqlSyntax.setField(_fSdevPower, 'sdevPower', DbType.real);
  }

  static TableField _fAvgGroundTime;
  static TableField get avgGroundTime {
    return _fAvgGroundTime = _fAvgGroundTime ??
        SqlSyntax.setField(_fAvgGroundTime, 'avgGroundTime', DbType.real);
  }

  static TableField _fSdevGroundTime;
  static TableField get sdevGroundTime {
    return _fSdevGroundTime = _fSdevGroundTime ??
        SqlSyntax.setField(_fSdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  static TableField _fAvgLegSpringStiffness;
  static TableField get avgLegSpringStiffness {
    return _fAvgLegSpringStiffness = _fAvgLegSpringStiffness ??
        SqlSyntax.setField(
            _fAvgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  static TableField _fSdevLegSpringStiffness;
  static TableField get sdevLegSpringStiffness {
    return _fSdevLegSpringStiffness = _fSdevLegSpringStiffness ??
        SqlSyntax.setField(
            _fSdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  static TableField _fAvgFormPower;
  static TableField get avgFormPower {
    return _fAvgFormPower = _fAvgFormPower ??
        SqlSyntax.setField(_fAvgFormPower, 'avgFormPower', DbType.real);
  }

  static TableField _fSdevFormPower;
  static TableField get sdevFormPower {
    return _fSdevFormPower = _fSdevFormPower ??
        SqlSyntax.setField(_fSdevFormPower, 'sdevFormPower', DbType.real);
  }

  static TableField _fAvgPowerRatio;
  static TableField get avgPowerRatio {
    return _fAvgPowerRatio = _fAvgPowerRatio ??
        SqlSyntax.setField(_fAvgPowerRatio, 'avgPowerRatio', DbType.real);
  }

  static TableField _fSdevPowerRatio;
  static TableField get sdevPowerRatio {
    return _fSdevPowerRatio = _fSdevPowerRatio ??
        SqlSyntax.setField(_fSdevPowerRatio, 'sdevPowerRatio', DbType.real);
  }

  static TableField _fAvgStrideRatio;
  static TableField get avgStrideRatio {
    return _fAvgStrideRatio = _fAvgStrideRatio ??
        SqlSyntax.setField(_fAvgStrideRatio, 'avgStrideRatio', DbType.real);
  }

  static TableField _fSdevStrideRatio;
  static TableField get sdevStrideRatio {
    return _fSdevStrideRatio = _fSdevStrideRatio ??
        SqlSyntax.setField(_fSdevStrideRatio, 'sdevStrideRatio', DbType.real);
  }

  static TableField _fAvgStrydCadence;
  static TableField get avgStrydCadence {
    return _fAvgStrydCadence = _fAvgStrydCadence ??
        SqlSyntax.setField(_fAvgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  static TableField _fSdevStrydCadence;
  static TableField get sdevStrydCadence {
    return _fSdevStrydCadence = _fSdevStrydCadence ??
        SqlSyntax.setField(_fSdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  static TableField _fSdevVerticalOscillation;
  static TableField get sdevVerticalOscillation {
    return _fSdevVerticalOscillation = _fSdevVerticalOscillation ??
        SqlSyntax.setField(
            _fSdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  static TableField _fAthletesId;
  static TableField get athletesId {
    return _fAthletesId = _fAthletesId ??
        SqlSyntax.setField(_fAthletesId, 'athletesId', DbType.integer);
  }
}
// endregion DbActivityFields

//region DbActivityManager
class DbActivityManager extends SqfEntityProvider {
  DbActivityManager()
      : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'activities';
  static String _colId = 'id';
}

//endregion DbActivityManager
// region DbEvent
class DbEvent {
  DbEvent(
      {this.id,
      this.event,
      this.eventType,
      this.eventGroup,
      this.timerTrigger,
      this.timeStamp,
      this.positionLat,
      this.positionLong,
      this.distance,
      this.altitude,
      this.speed,
      this.heartRate,
      this.cadence,
      this.fractionalCadence,
      this.power,
      this.strydCadence,
      this.groundTime,
      this.verticalOscillation,
      this.formPower,
      this.legSpringStiffness,
      this.data,
      this.activitiesId,
      this.lapsId}) {
    _setDefaultValues();
  }
  DbEvent.withFields(
      this.event,
      this.eventType,
      this.eventGroup,
      this.timerTrigger,
      this.timeStamp,
      this.positionLat,
      this.positionLong,
      this.distance,
      this.altitude,
      this.speed,
      this.heartRate,
      this.cadence,
      this.fractionalCadence,
      this.power,
      this.strydCadence,
      this.groundTime,
      this.verticalOscillation,
      this.formPower,
      this.legSpringStiffness,
      this.data,
      this.activitiesId,
      this.lapsId) {
    _setDefaultValues();
  }
  DbEvent.withId(
      this.id,
      this.event,
      this.eventType,
      this.eventGroup,
      this.timerTrigger,
      this.timeStamp,
      this.positionLat,
      this.positionLong,
      this.distance,
      this.altitude,
      this.speed,
      this.heartRate,
      this.cadence,
      this.fractionalCadence,
      this.power,
      this.strydCadence,
      this.groundTime,
      this.verticalOscillation,
      this.formPower,
      this.legSpringStiffness,
      this.data,
      this.activitiesId,
      this.lapsId) {
    _setDefaultValues();
  }
  DbEvent.fromMap(Map<String, dynamic> o) {
    _setDefaultValues();
    id = o['id'] as int;
    if (o['event'] != null) event = o['event'] as String;
    if (o['eventType'] != null) eventType = o['eventType'] as String;
    if (o['eventGroup'] != null) eventGroup = o['eventGroup'] as int;
    if (o['timerTrigger'] != null) timerTrigger = o['timerTrigger'] as String;
    if (o['timeStamp'] != null)
      timeStamp = int.tryParse(o['timeStamp'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(o['timeStamp'] as int)
          : DateTime.tryParse(o['timeStamp'].toString());
    if (o['positionLat'] != null)
      positionLat = double.tryParse(o['positionLat'].toString());
    if (o['positionLong'] != null)
      positionLong = double.tryParse(o['positionLong'].toString());
    if (o['distance'] != null)
      distance = double.tryParse(o['distance'].toString());
    if (o['altitude'] != null)
      altitude = double.tryParse(o['altitude'].toString());
    if (o['speed'] != null) speed = double.tryParse(o['speed'].toString());
    if (o['heartRate'] != null) heartRate = o['heartRate'] as int;
    if (o['cadence'] != null)
      cadence = double.tryParse(o['cadence'].toString());
    if (o['fractionalCadence'] != null)
      fractionalCadence = double.tryParse(o['fractionalCadence'].toString());
    if (o['power'] != null) power = o['power'] as int;
    if (o['strydCadence'] != null)
      strydCadence = double.tryParse(o['strydCadence'].toString());
    if (o['groundTime'] != null)
      groundTime = double.tryParse(o['groundTime'].toString());
    if (o['verticalOscillation'] != null)
      verticalOscillation =
          double.tryParse(o['verticalOscillation'].toString());
    if (o['formPower'] != null) formPower = o['formPower'] as int;
    if (o['legSpringStiffness'] != null)
      legSpringStiffness = double.tryParse(o['legSpringStiffness'].toString());
    if (o['data'] != null) data = double.tryParse(o['data'].toString());
    activitiesId = o['activitiesId'] as int;

    lapsId = o['lapsId'] as int;

    // RELATIONSHIPS FromMAP
    plDbActivity = o['DbActivity'] != null
        ? DbActivity.fromMap(o['DbActivity'] as Map<String, dynamic>)
        : null;
    plDbLap = o['DbLap'] != null
        ? DbLap.fromMap(o['DbLap'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbEvent)
  int id;
  String event;
  String eventType;
  int eventGroup;
  String timerTrigger;
  DateTime timeStamp;
  double positionLat;
  double positionLong;
  double distance;
  double altitude;
  double speed;
  int heartRate;
  double cadence;
  double fractionalCadence;
  int power;
  double strydCadence;
  double groundTime;
  double verticalOscillation;
  int formPower;
  double legSpringStiffness;
  double data;
  int activitiesId;
  int lapsId;

  BoolResult saveResult;
  // end FIELDS (DbEvent)

// RELATIONSHIPS (DbEvent)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbActivity plDbActivity;

  /// get DbActivity By ActivitiesId
  Future<DbActivity> getDbActivity() async {
    final _obj = await DbActivity().getById(activitiesId);
    return _obj;
  }

  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbLap plDbLap;

  /// get DbLap By LapsId
  Future<DbLap> getDbLap() async {
    final _obj = await DbLap().getById(lapsId);
    return _obj;
  }
  // END RELATIONSHIPS (DbEvent)

  static const bool _softDeleteActivated = false;
  DbEventManager __mnDbEvent;

  DbEventManager get _mnDbEvent {
    return __mnDbEvent = __mnDbEvent ?? DbEventManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (timerTrigger != null) {
      map['timerTrigger'] = timerTrigger;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (positionLat != null) {
      map['positionLat'] = positionLat;
    }

    if (positionLong != null) {
      map['positionLong'] = positionLong;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (altitude != null) {
      map['altitude'] = altitude;
    }

    if (speed != null) {
      map['speed'] = speed;
    }

    if (heartRate != null) {
      map['heartRate'] = heartRate;
    }

    if (cadence != null) {
      map['cadence'] = cadence;
    }

    if (fractionalCadence != null) {
      map['fractionalCadence'] = fractionalCadence;
    }

    if (power != null) {
      map['power'] = power;
    }

    if (strydCadence != null) {
      map['strydCadence'] = strydCadence;
    }

    if (groundTime != null) {
      map['groundTime'] = groundTime;
    }

    if (verticalOscillation != null) {
      map['verticalOscillation'] = verticalOscillation;
    }

    if (formPower != null) {
      map['formPower'] = formPower;
    }

    if (legSpringStiffness != null) {
      map['legSpringStiffness'] = legSpringStiffness;
    }

    if (data != null) {
      map['data'] = data;
    }

    if (activitiesId != null) {
      map['activitiesId'] = activitiesId;
    }

    if (lapsId != null) {
      map['lapsId'] = lapsId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (timerTrigger != null) {
      map['timerTrigger'] = timerTrigger;
    }

    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (positionLat != null) {
      map['positionLat'] = positionLat;
    }

    if (positionLong != null) {
      map['positionLong'] = positionLong;
    }

    if (distance != null) {
      map['distance'] = distance;
    }

    if (altitude != null) {
      map['altitude'] = altitude;
    }

    if (speed != null) {
      map['speed'] = speed;
    }

    if (heartRate != null) {
      map['heartRate'] = heartRate;
    }

    if (cadence != null) {
      map['cadence'] = cadence;
    }

    if (fractionalCadence != null) {
      map['fractionalCadence'] = fractionalCadence;
    }

    if (power != null) {
      map['power'] = power;
    }

    if (strydCadence != null) {
      map['strydCadence'] = strydCadence;
    }

    if (groundTime != null) {
      map['groundTime'] = groundTime;
    }

    if (verticalOscillation != null) {
      map['verticalOscillation'] = verticalOscillation;
    }

    if (formPower != null) {
      map['formPower'] = formPower;
    }

    if (legSpringStiffness != null) {
      map['legSpringStiffness'] = legSpringStiffness;
    }

    if (data != null) {
      map['data'] = data;
    }

    if (activitiesId != null) {
      map['activitiesId'] = activitiesId;
    }

    if (lapsId != null) {
      map['lapsId'] = lapsId;
    }

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      event,
      eventType,
      eventGroup,
      timerTrigger,
      timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
      positionLat,
      positionLong,
      distance,
      altitude,
      speed,
      heartRate,
      cadence,
      fractionalCadence,
      power,
      strydCadence,
      groundTime,
      verticalOscillation,
      formPower,
      legSpringStiffness,
      data,
      activitiesId,
      lapsId
    ];
  }

  static Future<List<DbEvent>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbEvent.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbEvent>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbEvent>[];
    try {
      objList = list
          .map((dbevent) => DbEvent.fromMap(dbevent as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR DbEvent.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbEvent>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbEvent.fromMapList(data);
    } 
    */

  static Future<List<DbEvent>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbEvent> objList = <DbEvent>[];
    for (final map in data) {
      final obj = DbEvent.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivity')) {
          obj.plDbActivity = obj.plDbActivity ?? await obj.getDbActivity();
        }
        if (preloadFields == null || preloadFields.contains('plDbLap')) {
          obj.plDbLap = obj.plDbLap ?? await obj.getDbLap();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbEvent by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbEvent if exist, otherwise returns null
  Future<DbEvent> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbEvent obj;
    final data = await _mnDbEvent.getById(id);
    if (data.length != 0) {
      obj = DbEvent.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbEvent) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbEvent.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbEvent. Returns a new Primary Key value of DbEvent

  /// <returns>Returns a new Primary Key value of DbEvent
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbEvent> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(List<DbEvent> dbevents) async {
    final results = _mnDbEvent.saveAll(
        'INSERT OR REPLACE INTO events (id,  event, eventType, eventGroup, timerTrigger, timeStamp, positionLat, positionLong, distance, altitude, speed, heartRate, cadence, fractionalCadence, power, strydCadence, groundTime, verticalOscillation, formPower, legSpringStiffness, data, activitiesId, lapsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbevents);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbEvent.rawInsert(
              'INSERT OR REPLACE INTO events (id,  event, eventType, eventGroup, timerTrigger, timeStamp, positionLat, positionLong, distance, altitude, speed, heartRate, cadence, fractionalCadence, power, strydCadence, groundTime, verticalOscillation, formPower, legSpringStiffness, data, activitiesId, lapsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                event,
                eventType,
                eventGroup,
                timerTrigger,
                timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
                positionLat,
                positionLong,
                distance,
                altitude,
                speed,
                heartRate,
                cadence,
                fractionalCadence,
                power,
                strydCadence,
                groundTime,
                verticalOscillation,
                formPower,
                legSpringStiffness,
                data,
                activitiesId,
                lapsId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbEvent id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbEvent id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbEvent Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbEvent>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(List<DbEvent> dbevents) async {
    final results = await _mnDbEvent.rawInsertAll(
        'INSERT OR REPLACE INTO events (id,  event, eventType, eventGroup, timerTrigger, timeStamp, positionLat, positionLong, distance, altitude, speed, heartRate, cadence, fractionalCadence, power, strydCadence, groundTime, verticalOscillation, formPower, legSpringStiffness, data, activitiesId, lapsId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dbevents);
    return results;
  }

  /// Deletes DbEvent

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbEvent invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbEvent
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbEvent.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbEventFilterBuilder _Select;
  DbEventFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbEventFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbEventFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbEventFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    activitiesId = activitiesId ?? 0;
    lapsId = lapsId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbevent

// region DbEventField
class DbEventField extends SearchCriteria {
  DbEventField(this.dbeventFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbEventFilterBuilder dbeventFB;

  DbEventField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbEventFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.EQuals,
            dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.NotEQuals,
            dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder isNull() {
    dbeventFB._addedBlocks = setCriteria(
        0,
        dbeventFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbeventFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbeventFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks);
      _waitingNot = '';
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
    }
    return dbeventFB;
  }

  DbEventFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbeventFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbeventFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks);
      _waitingNot = '';
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
    }
    return dbeventFB;
  }

  DbEventFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbeventFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbeventFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks);
      _waitingNot = '';
      dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
          dbeventFB._addedBlocks.retVal;
    }
    return dbeventFB;
  }

  DbEventFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbeventFB._addedBlocks = setCriteria(
          pFirst,
          dbeventFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbeventFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbeventFB._addedBlocks = setCriteria(pFirst, dbeventFB.parameters,
            param, SqlSyntax.LessThan, dbeventFB._addedBlocks);
      } else {
        dbeventFB._addedBlocks = setCriteria(pFirst, dbeventFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbeventFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbeventFB._addedBlocks = setCriteria(pLast, dbeventFB.parameters, param,
            SqlSyntax.GreaterThan, dbeventFB._addedBlocks);
      } else {
        dbeventFB._addedBlocks = setCriteria(pLast, dbeventFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbeventFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThan, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.LessThan,
            dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param, SqlSyntax.LessThan,
            dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbeventFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbeventFB._addedBlocks)
        : setCriteria(pValue, dbeventFB.parameters, param,
            SqlSyntax.GreaterThan, dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }

  DbEventFilterBuilder inValues(dynamic pValue) {
    dbeventFB._addedBlocks = setCriteria(
        pValue,
        dbeventFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbeventFB._addedBlocks);
    _waitingNot = '';
    dbeventFB._addedBlocks.needEndBlock[dbeventFB._blockIndex] =
        dbeventFB._addedBlocks.retVal;
    return dbeventFB;
  }
}
// endregion DbEventField

// region DbEventFilterBuilder
class DbEventFilterBuilder extends SearchCriteria {
  DbEventFilterBuilder(DbEvent obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbEvent _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbEventFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbEventFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbEventFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbEventFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbEventFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbEventFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbEventFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbEventFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbEventFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbEventFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbEventField setField(DbEventField field, String colName, DbType dbtype) {
    return DbEventField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbEventField _id;
  DbEventField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbEventField _event;
  DbEventField get event {
    return _event = setField(_event, 'event', DbType.text);
  }

  DbEventField _eventType;
  DbEventField get eventType {
    return _eventType = setField(_eventType, 'eventType', DbType.text);
  }

  DbEventField _eventGroup;
  DbEventField get eventGroup {
    return _eventGroup = setField(_eventGroup, 'eventGroup', DbType.integer);
  }

  DbEventField _timerTrigger;
  DbEventField get timerTrigger {
    return _timerTrigger = setField(_timerTrigger, 'timerTrigger', DbType.text);
  }

  DbEventField _timeStamp;
  DbEventField get timeStamp {
    return _timeStamp = setField(_timeStamp, 'timeStamp', DbType.datetime);
  }

  DbEventField _positionLat;
  DbEventField get positionLat {
    return _positionLat = setField(_positionLat, 'positionLat', DbType.real);
  }

  DbEventField _positionLong;
  DbEventField get positionLong {
    return _positionLong = setField(_positionLong, 'positionLong', DbType.real);
  }

  DbEventField _distance;
  DbEventField get distance {
    return _distance = setField(_distance, 'distance', DbType.real);
  }

  DbEventField _altitude;
  DbEventField get altitude {
    return _altitude = setField(_altitude, 'altitude', DbType.real);
  }

  DbEventField _speed;
  DbEventField get speed {
    return _speed = setField(_speed, 'speed', DbType.real);
  }

  DbEventField _heartRate;
  DbEventField get heartRate {
    return _heartRate = setField(_heartRate, 'heartRate', DbType.integer);
  }

  DbEventField _cadence;
  DbEventField get cadence {
    return _cadence = setField(_cadence, 'cadence', DbType.real);
  }

  DbEventField _fractionalCadence;
  DbEventField get fractionalCadence {
    return _fractionalCadence =
        setField(_fractionalCadence, 'fractionalCadence', DbType.real);
  }

  DbEventField _power;
  DbEventField get power {
    return _power = setField(_power, 'power', DbType.integer);
  }

  DbEventField _strydCadence;
  DbEventField get strydCadence {
    return _strydCadence = setField(_strydCadence, 'strydCadence', DbType.real);
  }

  DbEventField _groundTime;
  DbEventField get groundTime {
    return _groundTime = setField(_groundTime, 'groundTime', DbType.real);
  }

  DbEventField _verticalOscillation;
  DbEventField get verticalOscillation {
    return _verticalOscillation =
        setField(_verticalOscillation, 'verticalOscillation', DbType.real);
  }

  DbEventField _formPower;
  DbEventField get formPower {
    return _formPower = setField(_formPower, 'formPower', DbType.integer);
  }

  DbEventField _legSpringStiffness;
  DbEventField get legSpringStiffness {
    return _legSpringStiffness =
        setField(_legSpringStiffness, 'legSpringStiffness', DbType.real);
  }

  DbEventField _data;
  DbEventField get data {
    return _data = setField(_data, 'data', DbType.real);
  }

  DbEventField _activitiesId;
  DbEventField get activitiesId {
    return _activitiesId =
        setField(_activitiesId, 'activitiesId', DbType.integer);
  }

  DbEventField _lapsId;
  DbEventField get lapsId {
    return _lapsId = setField(_lapsId, 'lapsId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbEvent._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbEvent> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbEvent._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbEvent.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbEvent.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from events ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbEvent.updateBatch(qparams, values);
  }

  /// This method always returns DbEventObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbEvent>
  Future<DbEvent> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbEvent.toList(qparams);
    final data = await objFuture;
    DbEvent obj;
    if (data.isNotEmpty) {
      obj = DbEvent.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivity')) {
          obj.plDbActivity = obj.plDbActivity ?? await obj.getDbActivity();
        }
        if (preloadFields == null || preloadFields.contains('plDbLap')) {
          obj.plDbLap = obj.plDbLap ?? await obj.getDbLap();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbeventCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbeventsFuture = await _obj._mnDbEvent.toList(qparams);
    final int count = dbeventsFuture[0]['CNT'] as int;
    if (dbeventCount != null) {
      dbeventCount(count);
    }
    return count;
  }

  /// This method always returns List<DbEvent>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbEvent>
  Future<List<DbEvent>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbEvent> dbeventsData =
        await DbEvent.fromMapList(data, preload: preload);
    return dbeventsData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbEvent.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbEvent>>
  Future<List<DropdownMenuItem<DbEvent>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbEvent>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dbeventsFuture = _obj._mnDbEvent.toList(qparams);

    final data = await dbeventsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbEvent>> items = []..add(DropdownMenuItem(
        value: DbEvent(),
        child: Text('Select DbEvent'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbEvent.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dbeventsFuture = _obj._mnDbEvent.toList(qparams);

    final data = await dbeventsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbEvent'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbEvent.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbEvent.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbEvent.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbEvent.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbEventFilterBuilder

// region DbEventFields
class DbEventFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fEvent;
  static TableField get event {
    return _fEvent =
        _fEvent ?? SqlSyntax.setField(_fEvent, 'event', DbType.text);
  }

  static TableField _fEventType;
  static TableField get eventType {
    return _fEventType = _fEventType ??
        SqlSyntax.setField(_fEventType, 'eventType', DbType.text);
  }

  static TableField _fEventGroup;
  static TableField get eventGroup {
    return _fEventGroup = _fEventGroup ??
        SqlSyntax.setField(_fEventGroup, 'eventGroup', DbType.integer);
  }

  static TableField _fTimerTrigger;
  static TableField get timerTrigger {
    return _fTimerTrigger = _fTimerTrigger ??
        SqlSyntax.setField(_fTimerTrigger, 'timerTrigger', DbType.text);
  }

  static TableField _fTimeStamp;
  static TableField get timeStamp {
    return _fTimeStamp = _fTimeStamp ??
        SqlSyntax.setField(_fTimeStamp, 'timeStamp', DbType.datetime);
  }

  static TableField _fPositionLat;
  static TableField get positionLat {
    return _fPositionLat = _fPositionLat ??
        SqlSyntax.setField(_fPositionLat, 'positionLat', DbType.real);
  }

  static TableField _fPositionLong;
  static TableField get positionLong {
    return _fPositionLong = _fPositionLong ??
        SqlSyntax.setField(_fPositionLong, 'positionLong', DbType.real);
  }

  static TableField _fDistance;
  static TableField get distance {
    return _fDistance =
        _fDistance ?? SqlSyntax.setField(_fDistance, 'distance', DbType.real);
  }

  static TableField _fAltitude;
  static TableField get altitude {
    return _fAltitude =
        _fAltitude ?? SqlSyntax.setField(_fAltitude, 'altitude', DbType.real);
  }

  static TableField _fSpeed;
  static TableField get speed {
    return _fSpeed =
        _fSpeed ?? SqlSyntax.setField(_fSpeed, 'speed', DbType.real);
  }

  static TableField _fHeartRate;
  static TableField get heartRate {
    return _fHeartRate = _fHeartRate ??
        SqlSyntax.setField(_fHeartRate, 'heartRate', DbType.integer);
  }

  static TableField _fCadence;
  static TableField get cadence {
    return _fCadence =
        _fCadence ?? SqlSyntax.setField(_fCadence, 'cadence', DbType.real);
  }

  static TableField _fFractionalCadence;
  static TableField get fractionalCadence {
    return _fFractionalCadence = _fFractionalCadence ??
        SqlSyntax.setField(
            _fFractionalCadence, 'fractionalCadence', DbType.real);
  }

  static TableField _fPower;
  static TableField get power {
    return _fPower =
        _fPower ?? SqlSyntax.setField(_fPower, 'power', DbType.integer);
  }

  static TableField _fStrydCadence;
  static TableField get strydCadence {
    return _fStrydCadence = _fStrydCadence ??
        SqlSyntax.setField(_fStrydCadence, 'strydCadence', DbType.real);
  }

  static TableField _fGroundTime;
  static TableField get groundTime {
    return _fGroundTime = _fGroundTime ??
        SqlSyntax.setField(_fGroundTime, 'groundTime', DbType.real);
  }

  static TableField _fVerticalOscillation;
  static TableField get verticalOscillation {
    return _fVerticalOscillation = _fVerticalOscillation ??
        SqlSyntax.setField(
            _fVerticalOscillation, 'verticalOscillation', DbType.real);
  }

  static TableField _fFormPower;
  static TableField get formPower {
    return _fFormPower = _fFormPower ??
        SqlSyntax.setField(_fFormPower, 'formPower', DbType.integer);
  }

  static TableField _fLegSpringStiffness;
  static TableField get legSpringStiffness {
    return _fLegSpringStiffness = _fLegSpringStiffness ??
        SqlSyntax.setField(
            _fLegSpringStiffness, 'legSpringStiffness', DbType.real);
  }

  static TableField _fData;
  static TableField get data {
    return _fData = _fData ?? SqlSyntax.setField(_fData, 'data', DbType.real);
  }

  static TableField _fActivitiesId;
  static TableField get activitiesId {
    return _fActivitiesId = _fActivitiesId ??
        SqlSyntax.setField(_fActivitiesId, 'activitiesId', DbType.integer);
  }

  static TableField _fLapsId;
  static TableField get lapsId {
    return _fLapsId =
        _fLapsId ?? SqlSyntax.setField(_fLapsId, 'lapsId', DbType.integer);
  }
}
// endregion DbEventFields

//region DbEventManager
class DbEventManager extends SqfEntityProvider {
  DbEventManager() : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'events';
  static String _colId = 'id';
}

//endregion DbEventManager
// region DbLap
class DbLap {
  DbLap(
      {this.id,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.endPositionLat,
      this.endPositionLong,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.event,
      this.eventType,
      this.eventGroup,
      this.sport,
      this.subSport,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.maxRunningCadence,
      this.intensity,
      this.lapTrigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.activitiesId}) {
    _setDefaultValues();
  }
  DbLap.withFields(
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.endPositionLat,
      this.endPositionLong,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.event,
      this.eventType,
      this.eventGroup,
      this.sport,
      this.subSport,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.maxRunningCadence,
      this.intensity,
      this.lapTrigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.activitiesId) {
    _setDefaultValues();
  }
  DbLap.withId(
      this.id,
      this.timeStamp,
      this.startTime,
      this.startPositionLat,
      this.startPositionLong,
      this.endPositionLat,
      this.endPositionLong,
      this.avgHeartRate,
      this.maxHeartRate,
      this.avgRunningCadence,
      this.event,
      this.eventType,
      this.eventGroup,
      this.sport,
      this.subSport,
      this.avgVerticalOscillation,
      this.totalElapsedTime,
      this.totalTimerTime,
      this.totalDistance,
      this.totalStrides,
      this.totalCalories,
      this.avgSpeed,
      this.maxSpeed,
      this.totalAscent,
      this.totalDescent,
      this.avgStanceTimePercent,
      this.avgStanceTime,
      this.maxRunningCadence,
      this.intensity,
      this.lapTrigger,
      this.avgTemperature,
      this.maxTemperature,
      this.avgFractionalCadence,
      this.maxFractionalCadence,
      this.totalFractionalCycles,
      this.avgPower,
      this.minPower,
      this.maxPower,
      this.sdevPower,
      this.avgGroundTime,
      this.sdevGroundTime,
      this.avgLegSpringStiffness,
      this.sdevLegSpringStiffness,
      this.avgFormPower,
      this.sdevFormPower,
      this.avgStrydCadence,
      this.sdevStrydCadence,
      this.sdevVerticalOscillation,
      this.activitiesId) {
    _setDefaultValues();
  }
  DbLap.fromMap(Map<String, dynamic> o) {
    _setDefaultValues();
    id = o['id'] as int;
    if (o['timeStamp'] != null)
      timeStamp = int.tryParse(o['timeStamp'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(o['timeStamp'] as int)
          : DateTime.tryParse(o['timeStamp'].toString());
    if (o['startTime'] != null)
      startTime = int.tryParse(o['startTime'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(o['startTime'] as int)
          : DateTime.tryParse(o['startTime'].toString());
    if (o['startPositionLat'] != null)
      startPositionLat = double.tryParse(o['startPositionLat'].toString());
    if (o['startPositionLong'] != null)
      startPositionLong = double.tryParse(o['startPositionLong'].toString());
    if (o['endPositionLat'] != null)
      endPositionLat = double.tryParse(o['endPositionLat'].toString());
    if (o['endPositionLong'] != null)
      endPositionLong = double.tryParse(o['endPositionLong'].toString());
    if (o['avgHeartRate'] != null) avgHeartRate = o['avgHeartRate'] as int;
    if (o['maxHeartRate'] != null) maxHeartRate = o['maxHeartRate'] as int;
    if (o['avgRunningCadence'] != null)
      avgRunningCadence = double.tryParse(o['avgRunningCadence'].toString());
    if (o['event'] != null) event = o['event'] as String;
    if (o['eventType'] != null) eventType = o['eventType'] as String;
    if (o['eventGroup'] != null) eventGroup = o['eventGroup'] as int;
    if (o['sport'] != null) sport = o['sport'] as String;
    if (o['subSport'] != null) subSport = o['subSport'] as String;
    if (o['avgVerticalOscillation'] != null)
      avgVerticalOscillation =
          double.tryParse(o['avgVerticalOscillation'].toString());
    if (o['totalElapsedTime'] != null)
      totalElapsedTime = o['totalElapsedTime'] as int;
    if (o['totalTimerTime'] != null)
      totalTimerTime = o['totalTimerTime'] as int;
    if (o['totalDistance'] != null) totalDistance = o['totalDistance'] as int;
    if (o['totalStrides'] != null) totalStrides = o['totalStrides'] as int;
    if (o['totalCalories'] != null) totalCalories = o['totalCalories'] as int;
    if (o['avgSpeed'] != null)
      avgSpeed = double.tryParse(o['avgSpeed'].toString());
    if (o['maxSpeed'] != null)
      maxSpeed = double.tryParse(o['maxSpeed'].toString());
    if (o['totalAscent'] != null) totalAscent = o['totalAscent'] as int;
    if (o['totalDescent'] != null) totalDescent = o['totalDescent'] as int;
    if (o['avgStanceTimePercent'] != null)
      avgStanceTimePercent =
          double.tryParse(o['avgStanceTimePercent'].toString());
    if (o['avgStanceTime'] != null)
      avgStanceTime = double.tryParse(o['avgStanceTime'].toString());
    if (o['maxRunningCadence'] != null)
      maxRunningCadence = o['maxRunningCadence'] as int;
    if (o['intensity'] != null) intensity = o['intensity'] as int;
    if (o['lapTrigger'] != null) lapTrigger = o['lapTrigger'] as String;
    if (o['avgTemperature'] != null)
      avgTemperature = o['avgTemperature'] as int;
    if (o['maxTemperature'] != null)
      maxTemperature = o['maxTemperature'] as int;
    if (o['avgFractionalCadence'] != null)
      avgFractionalCadence =
          double.tryParse(o['avgFractionalCadence'].toString());
    if (o['maxFractionalCadence'] != null)
      maxFractionalCadence =
          double.tryParse(o['maxFractionalCadence'].toString());
    if (o['totalFractionalCycles'] != null)
      totalFractionalCycles =
          double.tryParse(o['totalFractionalCycles'].toString());
    if (o['avgPower'] != null)
      avgPower = double.tryParse(o['avgPower'].toString());
    if (o['minPower'] != null) minPower = o['minPower'] as int;
    if (o['maxPower'] != null) maxPower = o['maxPower'] as int;
    if (o['sdevPower'] != null)
      sdevPower = double.tryParse(o['sdevPower'].toString());
    if (o['avgGroundTime'] != null)
      avgGroundTime = double.tryParse(o['avgGroundTime'].toString());
    if (o['sdevGroundTime'] != null)
      sdevGroundTime = double.tryParse(o['sdevGroundTime'].toString());
    if (o['avgLegSpringStiffness'] != null)
      avgLegSpringStiffness =
          double.tryParse(o['avgLegSpringStiffness'].toString());
    if (o['sdevLegSpringStiffness'] != null)
      sdevLegSpringStiffness =
          double.tryParse(o['sdevLegSpringStiffness'].toString());
    if (o['avgFormPower'] != null)
      avgFormPower = double.tryParse(o['avgFormPower'].toString());
    if (o['sdevFormPower'] != null)
      sdevFormPower = double.tryParse(o['sdevFormPower'].toString());
    if (o['avgStrydCadence'] != null)
      avgStrydCadence = double.tryParse(o['avgStrydCadence'].toString());
    if (o['sdevStrydCadence'] != null)
      sdevStrydCadence = double.tryParse(o['sdevStrydCadence'].toString());
    if (o['sdevVerticalOscillation'] != null)
      sdevVerticalOscillation =
          double.tryParse(o['sdevVerticalOscillation'].toString());
    activitiesId = o['activitiesId'] as int;

    // RELATIONSHIPS FromMAP
    plDbActivity = o['DbActivity'] != null
        ? DbActivity.fromMap(o['DbActivity'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbLap)
  int id;
  DateTime timeStamp;
  DateTime startTime;
  double startPositionLat;
  double startPositionLong;
  double endPositionLat;
  double endPositionLong;
  int avgHeartRate;
  int maxHeartRate;
  double avgRunningCadence;
  String event;
  String eventType;
  int eventGroup;
  String sport;
  String subSport;
  double avgVerticalOscillation;
  int totalElapsedTime;
  int totalTimerTime;
  int totalDistance;
  int totalStrides;
  int totalCalories;
  double avgSpeed;
  double maxSpeed;
  int totalAscent;
  int totalDescent;
  double avgStanceTimePercent;
  double avgStanceTime;
  int maxRunningCadence;
  int intensity;
  String lapTrigger;
  int avgTemperature;
  int maxTemperature;
  double avgFractionalCadence;
  double maxFractionalCadence;
  double totalFractionalCycles;
  double avgPower;
  int minPower;
  int maxPower;
  double sdevPower;
  double avgGroundTime;
  double sdevGroundTime;
  double avgLegSpringStiffness;
  double sdevLegSpringStiffness;
  double avgFormPower;
  double sdevFormPower;
  double avgStrydCadence;
  double sdevStrydCadence;
  double sdevVerticalOscillation;
  int activitiesId;

  BoolResult saveResult;
  // end FIELDS (DbLap)

// RELATIONSHIPS (DbLap)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbActivity plDbActivity;

  /// get DbActivity By ActivitiesId
  Future<DbActivity> getDbActivity() async {
    final _obj = await DbActivity().getById(activitiesId);
    return _obj;
  }
  // END RELATIONSHIPS (DbLap)

// COLLECTIONS & VIRTUALS (DbLap)
  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbEvent> plDbEvents;

  /// get DbEvent(s) filtered by lapsId=id
  DbEventFilterBuilder getDbEvents(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbEvent()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .lapsId
        .equals(id)
        .and;
  }
// END COLLECTIONS & VIRTUALS (DbLap)

  static const bool _softDeleteActivated = false;
  DbLapManager __mnDbLap;

  DbLapManager get _mnDbLap {
    return __mnDbLap = __mnDbLap ?? DbLapManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toUtc().toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (endPositionLat != null) {
      map['endPositionLat'] = endPositionLat;
    }

    if (endPositionLong != null) {
      map['endPositionLong'] = endPositionLong;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (intensity != null) {
      map['intensity'] = intensity;
    }

    if (lapTrigger != null) {
      map['lapTrigger'] = lapTrigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (activitiesId != null) {
      map['activitiesId'] = activitiesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (timeStamp != null) {
      map['timeStamp'] = forJson
          ? timeStamp.toUtc().toString()
          : forQuery ? timeStamp.millisecondsSinceEpoch : timeStamp;
    }

    if (startTime != null) {
      map['startTime'] = forJson
          ? startTime.toUtc().toString()
          : forQuery ? startTime.millisecondsSinceEpoch : startTime;
    }

    if (startPositionLat != null) {
      map['startPositionLat'] = startPositionLat;
    }

    if (startPositionLong != null) {
      map['startPositionLong'] = startPositionLong;
    }

    if (endPositionLat != null) {
      map['endPositionLat'] = endPositionLat;
    }

    if (endPositionLong != null) {
      map['endPositionLong'] = endPositionLong;
    }

    if (avgHeartRate != null) {
      map['avgHeartRate'] = avgHeartRate;
    }

    if (maxHeartRate != null) {
      map['maxHeartRate'] = maxHeartRate;
    }

    if (avgRunningCadence != null) {
      map['avgRunningCadence'] = avgRunningCadence;
    }

    if (event != null) {
      map['event'] = event;
    }

    if (eventType != null) {
      map['eventType'] = eventType;
    }

    if (eventGroup != null) {
      map['eventGroup'] = eventGroup;
    }

    if (sport != null) {
      map['sport'] = sport;
    }

    if (subSport != null) {
      map['subSport'] = subSport;
    }

    if (avgVerticalOscillation != null) {
      map['avgVerticalOscillation'] = avgVerticalOscillation;
    }

    if (totalElapsedTime != null) {
      map['totalElapsedTime'] = totalElapsedTime;
    }

    if (totalTimerTime != null) {
      map['totalTimerTime'] = totalTimerTime;
    }

    if (totalDistance != null) {
      map['totalDistance'] = totalDistance;
    }

    if (totalStrides != null) {
      map['totalStrides'] = totalStrides;
    }

    if (totalCalories != null) {
      map['totalCalories'] = totalCalories;
    }

    if (avgSpeed != null) {
      map['avgSpeed'] = avgSpeed;
    }

    if (maxSpeed != null) {
      map['maxSpeed'] = maxSpeed;
    }

    if (totalAscent != null) {
      map['totalAscent'] = totalAscent;
    }

    if (totalDescent != null) {
      map['totalDescent'] = totalDescent;
    }

    if (avgStanceTimePercent != null) {
      map['avgStanceTimePercent'] = avgStanceTimePercent;
    }

    if (avgStanceTime != null) {
      map['avgStanceTime'] = avgStanceTime;
    }

    if (maxRunningCadence != null) {
      map['maxRunningCadence'] = maxRunningCadence;
    }

    if (intensity != null) {
      map['intensity'] = intensity;
    }

    if (lapTrigger != null) {
      map['lapTrigger'] = lapTrigger;
    }

    if (avgTemperature != null) {
      map['avgTemperature'] = avgTemperature;
    }

    if (maxTemperature != null) {
      map['maxTemperature'] = maxTemperature;
    }

    if (avgFractionalCadence != null) {
      map['avgFractionalCadence'] = avgFractionalCadence;
    }

    if (maxFractionalCadence != null) {
      map['maxFractionalCadence'] = maxFractionalCadence;
    }

    if (totalFractionalCycles != null) {
      map['totalFractionalCycles'] = totalFractionalCycles;
    }

    if (avgPower != null) {
      map['avgPower'] = avgPower;
    }

    if (minPower != null) {
      map['minPower'] = minPower;
    }

    if (maxPower != null) {
      map['maxPower'] = maxPower;
    }

    if (sdevPower != null) {
      map['sdevPower'] = sdevPower;
    }

    if (avgGroundTime != null) {
      map['avgGroundTime'] = avgGroundTime;
    }

    if (sdevGroundTime != null) {
      map['sdevGroundTime'] = sdevGroundTime;
    }

    if (avgLegSpringStiffness != null) {
      map['avgLegSpringStiffness'] = avgLegSpringStiffness;
    }

    if (sdevLegSpringStiffness != null) {
      map['sdevLegSpringStiffness'] = sdevLegSpringStiffness;
    }

    if (avgFormPower != null) {
      map['avgFormPower'] = avgFormPower;
    }

    if (sdevFormPower != null) {
      map['sdevFormPower'] = sdevFormPower;
    }

    if (avgStrydCadence != null) {
      map['avgStrydCadence'] = avgStrydCadence;
    }

    if (sdevStrydCadence != null) {
      map['sdevStrydCadence'] = sdevStrydCadence;
    }

    if (sdevVerticalOscillation != null) {
      map['sdevVerticalOscillation'] = sdevVerticalOscillation;
    }

    if (activitiesId != null) {
      map['activitiesId'] = activitiesId;
    }

// COLLECTIONS (DbLap)
    if (!forQuery) {
      map['DbEvents'] = await getDbEvents().toMapList();
    }
// END COLLECTIONS (DbLap)

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
      startTime != null ? startTime.millisecondsSinceEpoch : null,
      startPositionLat,
      startPositionLong,
      endPositionLat,
      endPositionLong,
      avgHeartRate,
      maxHeartRate,
      avgRunningCadence,
      event,
      eventType,
      eventGroup,
      sport,
      subSport,
      avgVerticalOscillation,
      totalElapsedTime,
      totalTimerTime,
      totalDistance,
      totalStrides,
      totalCalories,
      avgSpeed,
      maxSpeed,
      totalAscent,
      totalDescent,
      avgStanceTimePercent,
      avgStanceTime,
      maxRunningCadence,
      intensity,
      lapTrigger,
      avgTemperature,
      maxTemperature,
      avgFractionalCadence,
      maxFractionalCadence,
      totalFractionalCycles,
      avgPower,
      minPower,
      maxPower,
      sdevPower,
      avgGroundTime,
      sdevGroundTime,
      avgLegSpringStiffness,
      sdevLegSpringStiffness,
      avgFormPower,
      sdevFormPower,
      avgStrydCadence,
      sdevStrydCadence,
      sdevVerticalOscillation,
      activitiesId
    ];
  }

  static Future<List<DbLap>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print('SQFENTITY ERROR DbLap.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbLap>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbLap>[];
    try {
      objList = list
          .map((dblap) => DbLap.fromMap(dblap as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR DbLap.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbLap>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbLap.fromMapList(data);
    } 
    */

  static Future<List<DbLap>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbLap> objList = <DbLap>[];
    for (final map in data) {
      final obj = DbLap.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbEvents')) {
          obj.plDbEvents = obj.plDbEvents ?? await obj.getDbEvents().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivity')) {
          obj.plDbActivity = obj.plDbActivity ?? await obj.getDbActivity();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbLap by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbLap if exist, otherwise returns null
  Future<DbLap> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbLap obj;
    final data = await _mnDbLap.getById(id);
    if (data.length != 0) {
      obj = DbLap.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbLap) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbLap.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbLap. Returns a new Primary Key value of DbLap

  /// <returns>Returns a new Primary Key value of DbLap
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbLap> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(List<DbLap> dblaps) async {
    final results = _mnDbLap.saveAll(
        'INSERT OR REPLACE INTO laps (id,  timeStamp, startTime, startPositionLat, startPositionLong, endPositionLat, endPositionLong, avgHeartRate, maxHeartRate, avgRunningCadence, event, eventType, eventGroup, sport, subSport, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, avgStanceTimePercent, avgStanceTime, maxRunningCadence, intensity, lapTrigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dblaps);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbLap.rawInsert(
              'INSERT OR REPLACE INTO laps (id,  timeStamp, startTime, startPositionLat, startPositionLong, endPositionLat, endPositionLong, avgHeartRate, maxHeartRate, avgRunningCadence, event, eventType, eventGroup, sport, subSport, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, avgStanceTimePercent, avgStanceTime, maxRunningCadence, intensity, lapTrigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
              [
                id,
                timeStamp != null ? timeStamp.millisecondsSinceEpoch : null,
                startTime != null ? startTime.millisecondsSinceEpoch : null,
                startPositionLat,
                startPositionLong,
                endPositionLat,
                endPositionLong,
                avgHeartRate,
                maxHeartRate,
                avgRunningCadence,
                event,
                eventType,
                eventGroup,
                sport,
                subSport,
                avgVerticalOscillation,
                totalElapsedTime,
                totalTimerTime,
                totalDistance,
                totalStrides,
                totalCalories,
                avgSpeed,
                maxSpeed,
                totalAscent,
                totalDescent,
                avgStanceTimePercent,
                avgStanceTime,
                maxRunningCadence,
                intensity,
                lapTrigger,
                avgTemperature,
                maxTemperature,
                avgFractionalCadence,
                maxFractionalCadence,
                totalFractionalCycles,
                avgPower,
                minPower,
                maxPower,
                sdevPower,
                avgGroundTime,
                sdevGroundTime,
                avgLegSpringStiffness,
                sdevLegSpringStiffness,
                avgFormPower,
                sdevFormPower,
                avgStrydCadence,
                sdevStrydCadence,
                sdevVerticalOscillation,
                activitiesId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true, successMessage: 'DbLap id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbLap id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbLap Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbLap>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(List<DbLap> dblaps) async {
    final results = await _mnDbLap.rawInsertAll(
        'INSERT OR REPLACE INTO laps (id,  timeStamp, startTime, startPositionLat, startPositionLong, endPositionLat, endPositionLong, avgHeartRate, maxHeartRate, avgRunningCadence, event, eventType, eventGroup, sport, subSport, avgVerticalOscillation, totalElapsedTime, totalTimerTime, totalDistance, totalStrides, totalCalories, avgSpeed, maxSpeed, totalAscent, totalDescent, avgStanceTimePercent, avgStanceTime, maxRunningCadence, intensity, lapTrigger, avgTemperature, maxTemperature, avgFractionalCadence, maxFractionalCadence, totalFractionalCycles, avgPower, minPower, maxPower, sdevPower, avgGroundTime, sdevGroundTime, avgLegSpringStiffness, sdevLegSpringStiffness, avgFormPower, sdevFormPower, avgStrydCadence, sdevStrydCadence, sdevVerticalOscillation, activitiesId)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        dblaps);
    return results;
  }

  /// Deletes DbLap

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbLap invoked (id=$id)');
    var result = BoolResult();
    {
      result = await DbEvent().select().lapsId.equals(id).delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbLap
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbLap.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbLapFilterBuilder _Select;
  DbLapFilterBuilder select({List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLapFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbLapFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbLapFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    activitiesId = activitiesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dblap

// region DbLapField
class DbLapField extends SearchCriteria {
  DbLapField(this.dblapFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbLapFilterBuilder dblapFB;

  DbLapField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbLapFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.EQuals,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.NotEQuals,
            dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.EQualsOrNull,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder isNull() {
    dblapFB._addedBlocks = setCriteria(
        0,
        dblapFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dblapFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dblapFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks);
      _waitingNot = '';
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
    }
    return dblapFB;
  }

  DbLapFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dblapFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dblapFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks);
      _waitingNot = '';
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
    }
    return dblapFB;
  }

  DbLapFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dblapFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dblapFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks);
      _waitingNot = '';
      dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
          dblapFB._addedBlocks.retVal;
    }
    return dblapFB;
  }

  DbLapFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dblapFB._addedBlocks = setCriteria(
          pFirst,
          dblapFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dblapFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dblapFB._addedBlocks = setCriteria(pFirst, dblapFB.parameters, param,
            SqlSyntax.LessThan, dblapFB._addedBlocks);
      } else {
        dblapFB._addedBlocks = setCriteria(pFirst, dblapFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblapFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dblapFB._addedBlocks = setCriteria(pLast, dblapFB.parameters, param,
            SqlSyntax.GreaterThan, dblapFB._addedBlocks);
      } else {
        dblapFB._addedBlocks = setCriteria(pLast, dblapFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblapFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.GreaterThan,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.LessThan,
            dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.LessThan,
            dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dblapFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dblapFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dblapFB._addedBlocks)
        : setCriteria(pValue, dblapFB.parameters, param, SqlSyntax.GreaterThan,
            dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }

  DbLapFilterBuilder inValues(dynamic pValue) {
    dblapFB._addedBlocks = setCriteria(
        pValue,
        dblapFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dblapFB._addedBlocks);
    _waitingNot = '';
    dblapFB._addedBlocks.needEndBlock[dblapFB._blockIndex] =
        dblapFB._addedBlocks.retVal;
    return dblapFB;
  }
}
// endregion DbLapField

// region DbLapFilterBuilder
class DbLapFilterBuilder extends SearchCriteria {
  DbLapFilterBuilder(DbLap obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbLap _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbLapFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbLapFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbLapFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbLapFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbLapFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbLapFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbLapFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbLapFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbLapFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbLapFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbLapField setField(DbLapField field, String colName, DbType dbtype) {
    return DbLapField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbLapField _id;
  DbLapField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbLapField _timeStamp;
  DbLapField get timeStamp {
    return _timeStamp = setField(_timeStamp, 'timeStamp', DbType.datetime);
  }

  DbLapField _startTime;
  DbLapField get startTime {
    return _startTime = setField(_startTime, 'startTime', DbType.datetime);
  }

  DbLapField _startPositionLat;
  DbLapField get startPositionLat {
    return _startPositionLat =
        setField(_startPositionLat, 'startPositionLat', DbType.real);
  }

  DbLapField _startPositionLong;
  DbLapField get startPositionLong {
    return _startPositionLong =
        setField(_startPositionLong, 'startPositionLong', DbType.real);
  }

  DbLapField _endPositionLat;
  DbLapField get endPositionLat {
    return _endPositionLat =
        setField(_endPositionLat, 'endPositionLat', DbType.real);
  }

  DbLapField _endPositionLong;
  DbLapField get endPositionLong {
    return _endPositionLong =
        setField(_endPositionLong, 'endPositionLong', DbType.real);
  }

  DbLapField _avgHeartRate;
  DbLapField get avgHeartRate {
    return _avgHeartRate =
        setField(_avgHeartRate, 'avgHeartRate', DbType.integer);
  }

  DbLapField _maxHeartRate;
  DbLapField get maxHeartRate {
    return _maxHeartRate =
        setField(_maxHeartRate, 'maxHeartRate', DbType.integer);
  }

  DbLapField _avgRunningCadence;
  DbLapField get avgRunningCadence {
    return _avgRunningCadence =
        setField(_avgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  DbLapField _event;
  DbLapField get event {
    return _event = setField(_event, 'event', DbType.text);
  }

  DbLapField _eventType;
  DbLapField get eventType {
    return _eventType = setField(_eventType, 'eventType', DbType.text);
  }

  DbLapField _eventGroup;
  DbLapField get eventGroup {
    return _eventGroup = setField(_eventGroup, 'eventGroup', DbType.integer);
  }

  DbLapField _sport;
  DbLapField get sport {
    return _sport = setField(_sport, 'sport', DbType.text);
  }

  DbLapField _subSport;
  DbLapField get subSport {
    return _subSport = setField(_subSport, 'subSport', DbType.text);
  }

  DbLapField _avgVerticalOscillation;
  DbLapField get avgVerticalOscillation {
    return _avgVerticalOscillation = setField(
        _avgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  DbLapField _totalElapsedTime;
  DbLapField get totalElapsedTime {
    return _totalElapsedTime =
        setField(_totalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  DbLapField _totalTimerTime;
  DbLapField get totalTimerTime {
    return _totalTimerTime =
        setField(_totalTimerTime, 'totalTimerTime', DbType.integer);
  }

  DbLapField _totalDistance;
  DbLapField get totalDistance {
    return _totalDistance =
        setField(_totalDistance, 'totalDistance', DbType.integer);
  }

  DbLapField _totalStrides;
  DbLapField get totalStrides {
    return _totalStrides =
        setField(_totalStrides, 'totalStrides', DbType.integer);
  }

  DbLapField _totalCalories;
  DbLapField get totalCalories {
    return _totalCalories =
        setField(_totalCalories, 'totalCalories', DbType.integer);
  }

  DbLapField _avgSpeed;
  DbLapField get avgSpeed {
    return _avgSpeed = setField(_avgSpeed, 'avgSpeed', DbType.real);
  }

  DbLapField _maxSpeed;
  DbLapField get maxSpeed {
    return _maxSpeed = setField(_maxSpeed, 'maxSpeed', DbType.real);
  }

  DbLapField _totalAscent;
  DbLapField get totalAscent {
    return _totalAscent = setField(_totalAscent, 'totalAscent', DbType.integer);
  }

  DbLapField _totalDescent;
  DbLapField get totalDescent {
    return _totalDescent =
        setField(_totalDescent, 'totalDescent', DbType.integer);
  }

  DbLapField _avgStanceTimePercent;
  DbLapField get avgStanceTimePercent {
    return _avgStanceTimePercent =
        setField(_avgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  DbLapField _avgStanceTime;
  DbLapField get avgStanceTime {
    return _avgStanceTime =
        setField(_avgStanceTime, 'avgStanceTime', DbType.real);
  }

  DbLapField _maxRunningCadence;
  DbLapField get maxRunningCadence {
    return _maxRunningCadence =
        setField(_maxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  DbLapField _intensity;
  DbLapField get intensity {
    return _intensity = setField(_intensity, 'intensity', DbType.integer);
  }

  DbLapField _lapTrigger;
  DbLapField get lapTrigger {
    return _lapTrigger = setField(_lapTrigger, 'lapTrigger', DbType.text);
  }

  DbLapField _avgTemperature;
  DbLapField get avgTemperature {
    return _avgTemperature =
        setField(_avgTemperature, 'avgTemperature', DbType.integer);
  }

  DbLapField _maxTemperature;
  DbLapField get maxTemperature {
    return _maxTemperature =
        setField(_maxTemperature, 'maxTemperature', DbType.integer);
  }

  DbLapField _avgFractionalCadence;
  DbLapField get avgFractionalCadence {
    return _avgFractionalCadence =
        setField(_avgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  DbLapField _maxFractionalCadence;
  DbLapField get maxFractionalCadence {
    return _maxFractionalCadence =
        setField(_maxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  DbLapField _totalFractionalCycles;
  DbLapField get totalFractionalCycles {
    return _totalFractionalCycles =
        setField(_totalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  DbLapField _avgPower;
  DbLapField get avgPower {
    return _avgPower = setField(_avgPower, 'avgPower', DbType.real);
  }

  DbLapField _minPower;
  DbLapField get minPower {
    return _minPower = setField(_minPower, 'minPower', DbType.integer);
  }

  DbLapField _maxPower;
  DbLapField get maxPower {
    return _maxPower = setField(_maxPower, 'maxPower', DbType.integer);
  }

  DbLapField _sdevPower;
  DbLapField get sdevPower {
    return _sdevPower = setField(_sdevPower, 'sdevPower', DbType.real);
  }

  DbLapField _avgGroundTime;
  DbLapField get avgGroundTime {
    return _avgGroundTime =
        setField(_avgGroundTime, 'avgGroundTime', DbType.real);
  }

  DbLapField _sdevGroundTime;
  DbLapField get sdevGroundTime {
    return _sdevGroundTime =
        setField(_sdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  DbLapField _avgLegSpringStiffness;
  DbLapField get avgLegSpringStiffness {
    return _avgLegSpringStiffness =
        setField(_avgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  DbLapField _sdevLegSpringStiffness;
  DbLapField get sdevLegSpringStiffness {
    return _sdevLegSpringStiffness = setField(
        _sdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  DbLapField _avgFormPower;
  DbLapField get avgFormPower {
    return _avgFormPower = setField(_avgFormPower, 'avgFormPower', DbType.real);
  }

  DbLapField _sdevFormPower;
  DbLapField get sdevFormPower {
    return _sdevFormPower =
        setField(_sdevFormPower, 'sdevFormPower', DbType.real);
  }

  DbLapField _avgStrydCadence;
  DbLapField get avgStrydCadence {
    return _avgStrydCadence =
        setField(_avgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  DbLapField _sdevStrydCadence;
  DbLapField get sdevStrydCadence {
    return _sdevStrydCadence =
        setField(_sdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  DbLapField _sdevVerticalOscillation;
  DbLapField get sdevVerticalOscillation {
    return _sdevVerticalOscillation = setField(
        _sdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  DbLapField _activitiesId;
  DbLapField get activitiesId {
    return _activitiesId =
        setField(_activitiesId, 'activitiesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbLap._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbLap> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbLap._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbLap.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbLap.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from laps ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbLap.updateBatch(qparams, values);
  }

  /// This method always returns DbLapObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbLap>
  Future<DbLap> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbLap.toList(qparams);
    final data = await objFuture;
    DbLap obj;
    if (data.isNotEmpty) {
      obj = DbLap.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbEvents')) {
          obj.plDbEvents = obj.plDbEvents ?? await obj.getDbEvents().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbActivity')) {
          obj.plDbActivity = obj.plDbActivity ?? await obj.getDbActivity();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dblapCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dblapsFuture = await _obj._mnDbLap.toList(qparams);
    final int count = dblapsFuture[0]['CNT'] as int;
    if (dblapCount != null) {
      dblapCount(count);
    }
    return count;
  }

  /// This method always returns List<DbLap>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbLap>
  Future<List<DbLap>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbLap> dblapsData =
        await DbLap.fromMapList(data, preload: preload);
    return dblapsData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbLap.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbLap>>
  Future<List<DropdownMenuItem<DbLap>>> toDropDownMenu(String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbLap>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dblapsFuture = _obj._mnDbLap.toList(qparams);

    final data = await dblapsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbLap>> items = []..add(DropdownMenuItem(
        value: DbLap(),
        child: Text('Select DbLap'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbLap.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dblapsFuture = _obj._mnDbLap.toList(qparams);

    final data = await dblapsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbLap'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbLap.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbLap.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbLap.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbLap.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbLapFilterBuilder

// region DbLapFields
class DbLapFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fTimeStamp;
  static TableField get timeStamp {
    return _fTimeStamp = _fTimeStamp ??
        SqlSyntax.setField(_fTimeStamp, 'timeStamp', DbType.datetime);
  }

  static TableField _fStartTime;
  static TableField get startTime {
    return _fStartTime = _fStartTime ??
        SqlSyntax.setField(_fStartTime, 'startTime', DbType.datetime);
  }

  static TableField _fStartPositionLat;
  static TableField get startPositionLat {
    return _fStartPositionLat = _fStartPositionLat ??
        SqlSyntax.setField(_fStartPositionLat, 'startPositionLat', DbType.real);
  }

  static TableField _fStartPositionLong;
  static TableField get startPositionLong {
    return _fStartPositionLong = _fStartPositionLong ??
        SqlSyntax.setField(
            _fStartPositionLong, 'startPositionLong', DbType.real);
  }

  static TableField _fEndPositionLat;
  static TableField get endPositionLat {
    return _fEndPositionLat = _fEndPositionLat ??
        SqlSyntax.setField(_fEndPositionLat, 'endPositionLat', DbType.real);
  }

  static TableField _fEndPositionLong;
  static TableField get endPositionLong {
    return _fEndPositionLong = _fEndPositionLong ??
        SqlSyntax.setField(_fEndPositionLong, 'endPositionLong', DbType.real);
  }

  static TableField _fAvgHeartRate;
  static TableField get avgHeartRate {
    return _fAvgHeartRate = _fAvgHeartRate ??
        SqlSyntax.setField(_fAvgHeartRate, 'avgHeartRate', DbType.integer);
  }

  static TableField _fMaxHeartRate;
  static TableField get maxHeartRate {
    return _fMaxHeartRate = _fMaxHeartRate ??
        SqlSyntax.setField(_fMaxHeartRate, 'maxHeartRate', DbType.integer);
  }

  static TableField _fAvgRunningCadence;
  static TableField get avgRunningCadence {
    return _fAvgRunningCadence = _fAvgRunningCadence ??
        SqlSyntax.setField(
            _fAvgRunningCadence, 'avgRunningCadence', DbType.real);
  }

  static TableField _fEvent;
  static TableField get event {
    return _fEvent =
        _fEvent ?? SqlSyntax.setField(_fEvent, 'event', DbType.text);
  }

  static TableField _fEventType;
  static TableField get eventType {
    return _fEventType = _fEventType ??
        SqlSyntax.setField(_fEventType, 'eventType', DbType.text);
  }

  static TableField _fEventGroup;
  static TableField get eventGroup {
    return _fEventGroup = _fEventGroup ??
        SqlSyntax.setField(_fEventGroup, 'eventGroup', DbType.integer);
  }

  static TableField _fSport;
  static TableField get sport {
    return _fSport =
        _fSport ?? SqlSyntax.setField(_fSport, 'sport', DbType.text);
  }

  static TableField _fSubSport;
  static TableField get subSport {
    return _fSubSport =
        _fSubSport ?? SqlSyntax.setField(_fSubSport, 'subSport', DbType.text);
  }

  static TableField _fAvgVerticalOscillation;
  static TableField get avgVerticalOscillation {
    return _fAvgVerticalOscillation = _fAvgVerticalOscillation ??
        SqlSyntax.setField(
            _fAvgVerticalOscillation, 'avgVerticalOscillation', DbType.real);
  }

  static TableField _fTotalElapsedTime;
  static TableField get totalElapsedTime {
    return _fTotalElapsedTime = _fTotalElapsedTime ??
        SqlSyntax.setField(
            _fTotalElapsedTime, 'totalElapsedTime', DbType.integer);
  }

  static TableField _fTotalTimerTime;
  static TableField get totalTimerTime {
    return _fTotalTimerTime = _fTotalTimerTime ??
        SqlSyntax.setField(_fTotalTimerTime, 'totalTimerTime', DbType.integer);
  }

  static TableField _fTotalDistance;
  static TableField get totalDistance {
    return _fTotalDistance = _fTotalDistance ??
        SqlSyntax.setField(_fTotalDistance, 'totalDistance', DbType.integer);
  }

  static TableField _fTotalStrides;
  static TableField get totalStrides {
    return _fTotalStrides = _fTotalStrides ??
        SqlSyntax.setField(_fTotalStrides, 'totalStrides', DbType.integer);
  }

  static TableField _fTotalCalories;
  static TableField get totalCalories {
    return _fTotalCalories = _fTotalCalories ??
        SqlSyntax.setField(_fTotalCalories, 'totalCalories', DbType.integer);
  }

  static TableField _fAvgSpeed;
  static TableField get avgSpeed {
    return _fAvgSpeed =
        _fAvgSpeed ?? SqlSyntax.setField(_fAvgSpeed, 'avgSpeed', DbType.real);
  }

  static TableField _fMaxSpeed;
  static TableField get maxSpeed {
    return _fMaxSpeed =
        _fMaxSpeed ?? SqlSyntax.setField(_fMaxSpeed, 'maxSpeed', DbType.real);
  }

  static TableField _fTotalAscent;
  static TableField get totalAscent {
    return _fTotalAscent = _fTotalAscent ??
        SqlSyntax.setField(_fTotalAscent, 'totalAscent', DbType.integer);
  }

  static TableField _fTotalDescent;
  static TableField get totalDescent {
    return _fTotalDescent = _fTotalDescent ??
        SqlSyntax.setField(_fTotalDescent, 'totalDescent', DbType.integer);
  }

  static TableField _fAvgStanceTimePercent;
  static TableField get avgStanceTimePercent {
    return _fAvgStanceTimePercent = _fAvgStanceTimePercent ??
        SqlSyntax.setField(
            _fAvgStanceTimePercent, 'avgStanceTimePercent', DbType.real);
  }

  static TableField _fAvgStanceTime;
  static TableField get avgStanceTime {
    return _fAvgStanceTime = _fAvgStanceTime ??
        SqlSyntax.setField(_fAvgStanceTime, 'avgStanceTime', DbType.real);
  }

  static TableField _fMaxRunningCadence;
  static TableField get maxRunningCadence {
    return _fMaxRunningCadence = _fMaxRunningCadence ??
        SqlSyntax.setField(
            _fMaxRunningCadence, 'maxRunningCadence', DbType.integer);
  }

  static TableField _fIntensity;
  static TableField get intensity {
    return _fIntensity = _fIntensity ??
        SqlSyntax.setField(_fIntensity, 'intensity', DbType.integer);
  }

  static TableField _fLapTrigger;
  static TableField get lapTrigger {
    return _fLapTrigger = _fLapTrigger ??
        SqlSyntax.setField(_fLapTrigger, 'lapTrigger', DbType.text);
  }

  static TableField _fAvgTemperature;
  static TableField get avgTemperature {
    return _fAvgTemperature = _fAvgTemperature ??
        SqlSyntax.setField(_fAvgTemperature, 'avgTemperature', DbType.integer);
  }

  static TableField _fMaxTemperature;
  static TableField get maxTemperature {
    return _fMaxTemperature = _fMaxTemperature ??
        SqlSyntax.setField(_fMaxTemperature, 'maxTemperature', DbType.integer);
  }

  static TableField _fAvgFractionalCadence;
  static TableField get avgFractionalCadence {
    return _fAvgFractionalCadence = _fAvgFractionalCadence ??
        SqlSyntax.setField(
            _fAvgFractionalCadence, 'avgFractionalCadence', DbType.real);
  }

  static TableField _fMaxFractionalCadence;
  static TableField get maxFractionalCadence {
    return _fMaxFractionalCadence = _fMaxFractionalCadence ??
        SqlSyntax.setField(
            _fMaxFractionalCadence, 'maxFractionalCadence', DbType.real);
  }

  static TableField _fTotalFractionalCycles;
  static TableField get totalFractionalCycles {
    return _fTotalFractionalCycles = _fTotalFractionalCycles ??
        SqlSyntax.setField(
            _fTotalFractionalCycles, 'totalFractionalCycles', DbType.real);
  }

  static TableField _fAvgPower;
  static TableField get avgPower {
    return _fAvgPower =
        _fAvgPower ?? SqlSyntax.setField(_fAvgPower, 'avgPower', DbType.real);
  }

  static TableField _fMinPower;
  static TableField get minPower {
    return _fMinPower = _fMinPower ??
        SqlSyntax.setField(_fMinPower, 'minPower', DbType.integer);
  }

  static TableField _fMaxPower;
  static TableField get maxPower {
    return _fMaxPower = _fMaxPower ??
        SqlSyntax.setField(_fMaxPower, 'maxPower', DbType.integer);
  }

  static TableField _fSdevPower;
  static TableField get sdevPower {
    return _fSdevPower = _fSdevPower ??
        SqlSyntax.setField(_fSdevPower, 'sdevPower', DbType.real);
  }

  static TableField _fAvgGroundTime;
  static TableField get avgGroundTime {
    return _fAvgGroundTime = _fAvgGroundTime ??
        SqlSyntax.setField(_fAvgGroundTime, 'avgGroundTime', DbType.real);
  }

  static TableField _fSdevGroundTime;
  static TableField get sdevGroundTime {
    return _fSdevGroundTime = _fSdevGroundTime ??
        SqlSyntax.setField(_fSdevGroundTime, 'sdevGroundTime', DbType.real);
  }

  static TableField _fAvgLegSpringStiffness;
  static TableField get avgLegSpringStiffness {
    return _fAvgLegSpringStiffness = _fAvgLegSpringStiffness ??
        SqlSyntax.setField(
            _fAvgLegSpringStiffness, 'avgLegSpringStiffness', DbType.real);
  }

  static TableField _fSdevLegSpringStiffness;
  static TableField get sdevLegSpringStiffness {
    return _fSdevLegSpringStiffness = _fSdevLegSpringStiffness ??
        SqlSyntax.setField(
            _fSdevLegSpringStiffness, 'sdevLegSpringStiffness', DbType.real);
  }

  static TableField _fAvgFormPower;
  static TableField get avgFormPower {
    return _fAvgFormPower = _fAvgFormPower ??
        SqlSyntax.setField(_fAvgFormPower, 'avgFormPower', DbType.real);
  }

  static TableField _fSdevFormPower;
  static TableField get sdevFormPower {
    return _fSdevFormPower = _fSdevFormPower ??
        SqlSyntax.setField(_fSdevFormPower, 'sdevFormPower', DbType.real);
  }

  static TableField _fAvgStrydCadence;
  static TableField get avgStrydCadence {
    return _fAvgStrydCadence = _fAvgStrydCadence ??
        SqlSyntax.setField(_fAvgStrydCadence, 'avgStrydCadence', DbType.real);
  }

  static TableField _fSdevStrydCadence;
  static TableField get sdevStrydCadence {
    return _fSdevStrydCadence = _fSdevStrydCadence ??
        SqlSyntax.setField(_fSdevStrydCadence, 'sdevStrydCadence', DbType.real);
  }

  static TableField _fSdevVerticalOscillation;
  static TableField get sdevVerticalOscillation {
    return _fSdevVerticalOscillation = _fSdevVerticalOscillation ??
        SqlSyntax.setField(
            _fSdevVerticalOscillation, 'sdevVerticalOscillation', DbType.real);
  }

  static TableField _fActivitiesId;
  static TableField get activitiesId {
    return _fActivitiesId = _fActivitiesId ??
        SqlSyntax.setField(_fActivitiesId, 'activitiesId', DbType.integer);
  }
}
// endregion DbLapFields

//region DbLapManager
class DbLapManager extends SqfEntityProvider {
  DbLapManager() : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'laps';
  static String _colId = 'id';
}

//endregion DbLapManager
// region DbWeight
class DbWeight {
  DbWeight({this.id, this.date, this.value, this.athletesId}) {
    _setDefaultValues();
  }
  DbWeight.withFields(this.date, this.value, this.athletesId) {
    _setDefaultValues();
  }
  DbWeight.withId(this.id, this.date, this.value, this.athletesId) {
    _setDefaultValues();
  }
  DbWeight.fromMap(Map<String, dynamic> o) {
    _setDefaultValues();
    id = o['id'] as int;
    if (o['date'] != null)
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(o['date'] as int)
          : DateTime.tryParse(o['date'].toString());
    if (o['value'] != null) value = double.tryParse(o['value'].toString());
    athletesId = o['athletesId'] as int;

    // RELATIONSHIPS FromMAP
    plDbAthlete = o['DbAthlete'] != null
        ? DbAthlete.fromMap(o['DbAthlete'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbWeight)
  int id;
  DateTime date;
  double value;
  int athletesId;

  BoolResult saveResult;
  // end FIELDS (DbWeight)

// RELATIONSHIPS (DbWeight)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbAthlete plDbAthlete;

  /// get DbAthlete By AthletesId
  Future<DbAthlete> getDbAthlete() async {
    final _obj = await DbAthlete().getById(athletesId);
    return _obj;
  }
  // END RELATIONSHIPS (DbWeight)

  static const bool _softDeleteActivated = false;
  DbWeightManager __mnDbWeight;

  DbWeightManager get _mnDbWeight {
    return __mnDbWeight = __mnDbWeight ?? DbWeightManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (value != null) {
      map['value'] = value;
    }

    if (athletesId != null) {
      map['athletesId'] = athletesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (value != null) {
      map['value'] = value;
    }

    if (athletesId != null) {
      map['athletesId'] = athletesId;
    }

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      date != null ? date.millisecondsSinceEpoch : null,
      value,
      athletesId
    ];
  }

  static Future<List<DbWeight>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbWeight.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbWeight>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbWeight>[];
    try {
      objList = list
          .map((dbweight) => DbWeight.fromMap(dbweight as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print('SQFENTITY ERROR DbWeight.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbWeight>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbWeight.fromMapList(data);
    } 
    */

  static Future<List<DbWeight>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbWeight> objList = <DbWeight>[];
    for (final map in data) {
      final obj = DbWeight.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbAthlete')) {
          obj.plDbAthlete = obj.plDbAthlete ?? await obj.getDbAthlete();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbWeight by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbWeight if exist, otherwise returns null
  Future<DbWeight> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbWeight obj;
    final data = await _mnDbWeight.getById(id);
    if (data.length != 0) {
      obj = DbWeight.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbWeight) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbWeight.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbWeight. Returns a new Primary Key value of DbWeight

  /// <returns>Returns a new Primary Key value of DbWeight
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbWeight> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(List<DbWeight> dbweights) async {
    final results = _mnDbWeight.saveAll(
        'INSERT OR REPLACE INTO weights (id,  date, value, athletesId)  VALUES (?,?,?,?)',
        dbweights);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbWeight.rawInsert(
              'INSERT OR REPLACE INTO weights (id,  date, value, athletesId)  VALUES (?,?,?,?)',
              [
                id,
                date != null ? date.millisecondsSinceEpoch : null,
                value,
                athletesId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbWeight id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbWeight id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbWeight Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbWeight>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(List<DbWeight> dbweights) async {
    final results = await _mnDbWeight.rawInsertAll(
        'INSERT OR REPLACE INTO weights (id,  date, value, athletesId)  VALUES (?,?,?,?)',
        dbweights);
    return results;
  }

  /// Deletes DbWeight

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbWeight invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbWeight
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbWeight.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbWeightFilterBuilder _Select;
  DbWeightFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbWeightFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbWeightFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbWeightFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    athletesId = athletesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbweight

// region DbWeightField
class DbWeightField extends SearchCriteria {
  DbWeightField(this.dbweightFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbWeightFilterBuilder dbweightFB;

  DbWeightField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbWeightFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param, SqlSyntax.EQuals,
            dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param, SqlSyntax.NotEQuals,
            dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder isNull() {
    dbweightFB._addedBlocks = setCriteria(
        0,
        dbweightFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbweightFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbweightFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbweightFB._addedBlocks);
      _waitingNot = '';
      dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
          dbweightFB._addedBlocks.retVal;
    }
    return dbweightFB;
  }

  DbWeightFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbweightFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbweightFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbweightFB._addedBlocks);
      _waitingNot = '';
      dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
          dbweightFB._addedBlocks.retVal;
      dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
          dbweightFB._addedBlocks.retVal;
    }
    return dbweightFB;
  }

  DbWeightFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbweightFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbweightFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbweightFB._addedBlocks);
      _waitingNot = '';
      dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
          dbweightFB._addedBlocks.retVal;
    }
    return dbweightFB;
  }

  DbWeightFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbweightFB._addedBlocks = setCriteria(
          pFirst,
          dbweightFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbweightFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbweightFB._addedBlocks = setCriteria(pFirst, dbweightFB.parameters,
            param, SqlSyntax.LessThan, dbweightFB._addedBlocks);
      } else {
        dbweightFB._addedBlocks = setCriteria(pFirst, dbweightFB.parameters,
            param, SqlSyntax.GreaterThanOrEquals, dbweightFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbweightFB._addedBlocks = setCriteria(pLast, dbweightFB.parameters,
            param, SqlSyntax.GreaterThan, dbweightFB._addedBlocks);
      } else {
        dbweightFB._addedBlocks = setCriteria(pLast, dbweightFB.parameters,
            param, SqlSyntax.LessThanOrEquals, dbweightFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.GreaterThan, dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param, SqlSyntax.LessThan,
            dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param, SqlSyntax.LessThan,
            dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbweightFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbweightFB._addedBlocks)
        : setCriteria(pValue, dbweightFB.parameters, param,
            SqlSyntax.GreaterThan, dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }

  DbWeightFilterBuilder inValues(dynamic pValue) {
    dbweightFB._addedBlocks = setCriteria(
        pValue,
        dbweightFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbweightFB._addedBlocks);
    _waitingNot = '';
    dbweightFB._addedBlocks.needEndBlock[dbweightFB._blockIndex] =
        dbweightFB._addedBlocks.retVal;
    return dbweightFB;
  }
}
// endregion DbWeightField

// region DbWeightFilterBuilder
class DbWeightFilterBuilder extends SearchCriteria {
  DbWeightFilterBuilder(DbWeight obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbWeight _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbWeightFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbWeightFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbWeightFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbWeightFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbWeightFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbWeightFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbWeightFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbWeightFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbWeightFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbWeightFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbWeightField setField(DbWeightField field, String colName, DbType dbtype) {
    return DbWeightField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbWeightField _id;
  DbWeightField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbWeightField _date;
  DbWeightField get date {
    return _date = setField(_date, 'date', DbType.date);
  }

  DbWeightField _value;
  DbWeightField get value {
    return _value = setField(_value, 'value', DbType.real);
  }

  DbWeightField _athletesId;
  DbWeightField get athletesId {
    return _athletesId = setField(_athletesId, 'athletesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbWeight._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbWeight> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbWeight._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbWeight.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbWeight.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from weights ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbWeight.updateBatch(qparams, values);
  }

  /// This method always returns DbWeightObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbWeight>
  Future<DbWeight> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbWeight.toList(qparams);
    final data = await objFuture;
    DbWeight obj;
    if (data.isNotEmpty) {
      obj = DbWeight.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbAthlete')) {
          obj.plDbAthlete = obj.plDbAthlete ?? await obj.getDbAthlete();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbweightCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbweightsFuture = await _obj._mnDbWeight.toList(qparams);
    final int count = dbweightsFuture[0]['CNT'] as int;
    if (dbweightCount != null) {
      dbweightCount(count);
    }
    return count;
  }

  /// This method always returns List<DbWeight>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbWeight>
  Future<List<DbWeight>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbWeight> dbweightsData =
        await DbWeight.fromMapList(data, preload: preload);
    return dbweightsData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbWeight.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbWeight>>
  Future<List<DropdownMenuItem<DbWeight>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbWeight>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dbweightsFuture = _obj._mnDbWeight.toList(qparams);

    final data = await dbweightsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbWeight>> items = []..add(DropdownMenuItem(
        value: DbWeight(),
        child: Text('Select DbWeight'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbWeight.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dbweightsFuture = _obj._mnDbWeight.toList(qparams);

    final data = await dbweightsFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbWeight'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbWeight.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbWeight.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbWeight.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbWeight.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbWeightFilterBuilder

// region DbWeightFields
class DbWeightFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fDate;
  static TableField get date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.date);
  }

  static TableField _fValue;
  static TableField get value {
    return _fValue =
        _fValue ?? SqlSyntax.setField(_fValue, 'value', DbType.real);
  }

  static TableField _fAthletesId;
  static TableField get athletesId {
    return _fAthletesId = _fAthletesId ??
        SqlSyntax.setField(_fAthletesId, 'athletesId', DbType.integer);
  }
}
// endregion DbWeightFields

//region DbWeightManager
class DbWeightManager extends SqfEntityProvider {
  DbWeightManager()
      : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'weights';
  static String _colId = 'id';
}

//endregion DbWeightManager
// region DbHeartRateZoneSchema
class DbHeartRateZoneSchema {
  DbHeartRateZoneSchema(
      {this.id, this.date, this.name, this.base, this.athletesId}) {
    _setDefaultValues();
  }
  DbHeartRateZoneSchema.withFields(
      this.date, this.name, this.base, this.athletesId) {
    _setDefaultValues();
  }
  DbHeartRateZoneSchema.withId(
      this.id, this.date, this.name, this.base, this.athletesId) {
    _setDefaultValues();
  }
  DbHeartRateZoneSchema.fromMap(Map<String, dynamic> o) {
    _setDefaultValues();
    id = o['id'] as int;
    if (o['date'] != null)
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(o['date'] as int)
          : DateTime.tryParse(o['date'].toString());
    if (o['name'] != null) name = o['name'] as String;
    if (o['base'] != null) base = o['base'] as int;
    athletesId = o['athletesId'] as int;

    // RELATIONSHIPS FromMAP
    plDbAthlete = o['DbAthlete'] != null
        ? DbAthlete.fromMap(o['DbAthlete'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbHeartRateZoneSchema)
  int id;
  DateTime date;
  String name;
  int base;
  int athletesId;

  BoolResult saveResult;
  // end FIELDS (DbHeartRateZoneSchema)

// RELATIONSHIPS (DbHeartRateZoneSchema)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbAthlete plDbAthlete;

  /// get DbAthlete By AthletesId
  Future<DbAthlete> getDbAthlete() async {
    final _obj = await DbAthlete().getById(athletesId);
    return _obj;
  }
  // END RELATIONSHIPS (DbHeartRateZoneSchema)

// COLLECTIONS & VIRTUALS (DbHeartRateZoneSchema)
  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbHeartRateZone> plDbHeartRateZones;

  /// get DbHeartRateZone(s) filtered by heartRateZoneSchemataId=id
  DbHeartRateZoneFilterBuilder getDbHeartRateZones(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbHeartRateZone()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .heartRateZoneSchemataId
        .equals(id)
        .and;
  }
// END COLLECTIONS & VIRTUALS (DbHeartRateZoneSchema)

  static const bool _softDeleteActivated = false;
  DbHeartRateZoneSchemaManager __mnDbHeartRateZoneSchema;

  DbHeartRateZoneSchemaManager get _mnDbHeartRateZoneSchema {
    return __mnDbHeartRateZoneSchema =
        __mnDbHeartRateZoneSchema ?? DbHeartRateZoneSchemaManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (base != null) {
      map['base'] = base;
    }

    if (athletesId != null) {
      map['athletesId'] = athletesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (base != null) {
      map['base'] = base;
    }

    if (athletesId != null) {
      map['athletesId'] = athletesId;
    }

// COLLECTIONS (DbHeartRateZoneSchema)
    if (!forQuery) {
      map['DbHeartRateZones'] = await getDbHeartRateZones().toMapList();
    }
// END COLLECTIONS (DbHeartRateZoneSchema)

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      date != null ? date.millisecondsSinceEpoch : null,
      name,
      base,
      athletesId
    ];
  }

  static Future<List<DbHeartRateZoneSchema>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbHeartRateZoneSchema.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbHeartRateZoneSchema>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbHeartRateZoneSchema>[];
    try {
      objList = list
          .map((dbheartratezoneschema) => DbHeartRateZoneSchema.fromMap(
              dbheartratezoneschema as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbHeartRateZoneSchema.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbHeartRateZoneSchema>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbHeartRateZoneSchema.fromMapList(data);
    } 
    */

  static Future<List<DbHeartRateZoneSchema>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbHeartRateZoneSchema> objList = <DbHeartRateZoneSchema>[];
    for (final map in data) {
      final obj = DbHeartRateZoneSchema.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null ||
            preloadFields.contains('plDbHeartRateZones')) {
          obj.plDbHeartRateZones = obj.plDbHeartRateZones ??
              await obj.getDbHeartRateZones().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbAthlete')) {
          obj.plDbAthlete = obj.plDbAthlete ?? await obj.getDbAthlete();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbHeartRateZoneSchema by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbHeartRateZoneSchema if exist, otherwise returns null
  Future<DbHeartRateZoneSchema> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbHeartRateZoneSchema obj;
    final data = await _mnDbHeartRateZoneSchema.getById(id);
    if (data.length != 0) {
      obj = DbHeartRateZoneSchema.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbHeartRateZoneSchema) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbHeartRateZoneSchema.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbHeartRateZoneSchema. Returns a new Primary Key value of DbHeartRateZoneSchema

  /// <returns>Returns a new Primary Key value of DbHeartRateZoneSchema
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbHeartRateZoneSchema> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(
      List<DbHeartRateZoneSchema> dbheartratezoneschemas) async {
    final results = _mnDbHeartRateZoneSchema.saveAll(
        'INSERT OR REPLACE INTO heartRateZoneSchemata (id,  date, name, base, athletesId)  VALUES (?,?,?,?,?)',
        dbheartratezoneschemas);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbHeartRateZoneSchema.rawInsert(
              'INSERT OR REPLACE INTO heartRateZoneSchemata (id,  date, name, base, athletesId)  VALUES (?,?,?,?,?)',
              [
                id,
                date != null ? date.millisecondsSinceEpoch : null,
                name,
                base,
                athletesId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbHeartRateZoneSchema id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DbHeartRateZoneSchema id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'DbHeartRateZoneSchema Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbHeartRateZoneSchema>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(
      List<DbHeartRateZoneSchema> dbheartratezoneschemas) async {
    final results = await _mnDbHeartRateZoneSchema.rawInsertAll(
        'INSERT OR REPLACE INTO heartRateZoneSchemata (id,  date, name, base, athletesId)  VALUES (?,?,?,?,?)',
        dbheartratezoneschemas);
    return results;
  }

  /// Deletes DbHeartRateZoneSchema

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbHeartRateZoneSchema invoked (id=$id)');
    var result = BoolResult();
    {
      result = await DbHeartRateZone()
          .select()
          .heartRateZoneSchemataId
          .equals(id)
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbHeartRateZoneSchema
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbHeartRateZoneSchema.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbHeartRateZoneSchemaFilterBuilder _Select;
  DbHeartRateZoneSchemaFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbHeartRateZoneSchemaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbHeartRateZoneSchemaFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbHeartRateZoneSchemaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    athletesId = athletesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbheartratezoneschema

// region DbHeartRateZoneSchemaField
class DbHeartRateZoneSchemaField extends SearchCriteria {
  DbHeartRateZoneSchemaField(this.dbheartratezoneschemaFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbHeartRateZoneSchemaFilterBuilder dbheartratezoneschemaFB;

  DbHeartRateZoneSchemaField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbHeartRateZoneSchemaFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.EQuals, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.NotEQuals, dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder isNull() {
    dbheartratezoneschemaFB._addedBlocks = setCriteria(
        0,
        dbheartratezoneschemaFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneschemaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbheartratezoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneschemaFB
              ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
          dbheartratezoneschemaFB._addedBlocks.retVal;
    }
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneschemaFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbheartratezoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneschemaFB
              ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
          dbheartratezoneschemaFB._addedBlocks.retVal;
      dbheartratezoneschemaFB
              ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
          dbheartratezoneschemaFB._addedBlocks.retVal;
    }
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneschemaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbheartratezoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneschemaFB
              ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
          dbheartratezoneschemaFB._addedBlocks.retVal;
    }
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbheartratezoneschemaFB._addedBlocks = setCriteria(
          pFirst,
          dbheartratezoneschemaFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneschemaFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbheartratezoneschemaFB._addedBlocks = setCriteria(
            pFirst,
            dbheartratezoneschemaFB.parameters,
            param,
            SqlSyntax.LessThan,
            dbheartratezoneschemaFB._addedBlocks);
      } else {
        dbheartratezoneschemaFB._addedBlocks = setCriteria(
            pFirst,
            dbheartratezoneschemaFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbheartratezoneschemaFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbheartratezoneschemaFB._addedBlocks = setCriteria(
            pLast,
            dbheartratezoneschemaFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            dbheartratezoneschemaFB._addedBlocks);
      } else {
        dbheartratezoneschemaFB._addedBlocks = setCriteria(
            pLast,
            dbheartratezoneschemaFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            dbheartratezoneschemaFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.GreaterThan, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.LessThan, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(
            pValue,
            dbheartratezoneschemaFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.LessThan, dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbheartratezoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbheartratezoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneschemaFB.parameters, param,
            SqlSyntax.GreaterThan, dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }

  DbHeartRateZoneSchemaFilterBuilder inValues(dynamic pValue) {
    dbheartratezoneschemaFB._addedBlocks = setCriteria(
        pValue,
        dbheartratezoneschemaFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbheartratezoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneschemaFB
            ._addedBlocks.needEndBlock[dbheartratezoneschemaFB._blockIndex] =
        dbheartratezoneschemaFB._addedBlocks.retVal;
    return dbheartratezoneschemaFB;
  }
}
// endregion DbHeartRateZoneSchemaField

// region DbHeartRateZoneSchemaFilterBuilder
class DbHeartRateZoneSchemaFilterBuilder extends SearchCriteria {
  DbHeartRateZoneSchemaFilterBuilder(DbHeartRateZoneSchema obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbHeartRateZoneSchema _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbHeartRateZoneSchemaFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbHeartRateZoneSchemaFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbHeartRateZoneSchemaFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbHeartRateZoneSchemaFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbHeartRateZoneSchemaFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbHeartRateZoneSchemaFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbHeartRateZoneSchemaFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbHeartRateZoneSchemaFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbHeartRateZoneSchemaFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbHeartRateZoneSchemaFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbHeartRateZoneSchemaField setField(
      DbHeartRateZoneSchemaField field, String colName, DbType dbtype) {
    return DbHeartRateZoneSchemaField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbHeartRateZoneSchemaField _id;
  DbHeartRateZoneSchemaField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbHeartRateZoneSchemaField _date;
  DbHeartRateZoneSchemaField get date {
    return _date = setField(_date, 'date', DbType.date);
  }

  DbHeartRateZoneSchemaField _name;
  DbHeartRateZoneSchemaField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbHeartRateZoneSchemaField _base;
  DbHeartRateZoneSchemaField get base {
    return _base = setField(_base, 'base', DbType.integer);
  }

  DbHeartRateZoneSchemaField _athletesId;
  DbHeartRateZoneSchemaField get athletesId {
    return _athletesId = setField(_athletesId, 'athletesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbHeartRateZoneSchema._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbHeartRateZoneSchema> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbHeartRateZoneSchema._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbHeartRateZoneSchema
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbHeartRateZoneSchema.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from heartRateZoneSchemata ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbHeartRateZoneSchema.updateBatch(qparams, values);
  }

  /// This method always returns DbHeartRateZoneSchemaObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbHeartRateZoneSchema>
  Future<DbHeartRateZoneSchema> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbHeartRateZoneSchema.toList(qparams);
    final data = await objFuture;
    DbHeartRateZoneSchema obj;
    if (data.isNotEmpty) {
      obj = DbHeartRateZoneSchema.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null ||
            preloadFields.contains('plDbHeartRateZones')) {
          obj.plDbHeartRateZones = obj.plDbHeartRateZones ??
              await obj.getDbHeartRateZones().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbAthlete')) {
          obj.plDbAthlete = obj.plDbAthlete ?? await obj.getDbAthlete();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) dbheartratezoneschemaCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbheartratezoneschemasFuture =
        await _obj._mnDbHeartRateZoneSchema.toList(qparams);
    final int count = dbheartratezoneschemasFuture[0]['CNT'] as int;
    if (dbheartratezoneschemaCount != null) {
      dbheartratezoneschemaCount(count);
    }
    return count;
  }

  /// This method always returns List<DbHeartRateZoneSchema>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbHeartRateZoneSchema>
  Future<List<DbHeartRateZoneSchema>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbHeartRateZoneSchema> dbheartratezoneschemasData =
        await DbHeartRateZoneSchema.fromMapList(data, preload: preload);
    return dbheartratezoneschemasData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbHeartRateZoneSchema.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbHeartRateZoneSchema>>
  Future<List<DropdownMenuItem<DbHeartRateZoneSchema>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbHeartRateZoneSchema>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dbheartratezoneschemasFuture =
        _obj._mnDbHeartRateZoneSchema.toList(qparams);

    final data = await dbheartratezoneschemasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbHeartRateZoneSchema>> items = []
      ..add(DropdownMenuItem(
        value: DbHeartRateZoneSchema(),
        child: Text('Select DbHeartRateZoneSchema'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbHeartRateZoneSchema.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dbheartratezoneschemasFuture =
        _obj._mnDbHeartRateZoneSchema.toList(qparams);

    final data = await dbheartratezoneschemasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbHeartRateZoneSchema'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbHeartRateZoneSchema.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbHeartRateZoneSchema.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbHeartRateZoneSchema.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbHeartRateZoneSchema.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbHeartRateZoneSchemaFilterBuilder

// region DbHeartRateZoneSchemaFields
class DbHeartRateZoneSchemaFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fDate;
  static TableField get date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.date);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fBase;
  static TableField get base {
    return _fBase =
        _fBase ?? SqlSyntax.setField(_fBase, 'base', DbType.integer);
  }

  static TableField _fAthletesId;
  static TableField get athletesId {
    return _fAthletesId = _fAthletesId ??
        SqlSyntax.setField(_fAthletesId, 'athletesId', DbType.integer);
  }
}
// endregion DbHeartRateZoneSchemaFields

//region DbHeartRateZoneSchemaManager
class DbHeartRateZoneSchemaManager extends SqfEntityProvider {
  DbHeartRateZoneSchemaManager()
      : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'heartRateZoneSchemata';
  static String _colId = 'id';
}

//endregion DbHeartRateZoneSchemaManager
// region DbHeartRateZone
class DbHeartRateZone {
  DbHeartRateZone(
      {this.id,
      this.name,
      this.lowerPercentage,
      this.upperPercentage,
      this.lowerLimit,
      this.upperLimit,
      this.color,
      this.heartRateZoneSchemataId}) {
    _setDefaultValues();
  }
  DbHeartRateZone.withFields(
      this.name,
      this.lowerPercentage,
      this.upperPercentage,
      this.lowerLimit,
      this.upperLimit,
      this.color,
      this.heartRateZoneSchemataId) {
    _setDefaultValues();
  }
  DbHeartRateZone.withId(
      this.id,
      this.name,
      this.lowerPercentage,
      this.upperPercentage,
      this.lowerLimit,
      this.upperLimit,
      this.color,
      this.heartRateZoneSchemataId) {
    _setDefaultValues();
  }
  DbHeartRateZone.fromMap(Map<String, dynamic> o) {
    _setDefaultValues();
    id = o['id'] as int;
    if (o['name'] != null) name = o['name'] as String;
    if (o['lowerPercentage'] != null)
      lowerPercentage = o['lowerPercentage'] as int;
    if (o['upperPercentage'] != null)
      upperPercentage = o['upperPercentage'] as int;
    if (o['lowerLimit'] != null) lowerLimit = o['lowerLimit'] as int;
    if (o['upperLimit'] != null) upperLimit = o['upperLimit'] as int;
    if (o['color'] != null) color = o['color'] as int;
    heartRateZoneSchemataId = o['heartRateZoneSchemataId'] as int;

    // RELATIONSHIPS FromMAP
    plDbHeartRateZoneSchema = o['DbHeartRateZoneSchema'] != null
        ? DbHeartRateZoneSchema.fromMap(
            o['DbHeartRateZoneSchema'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbHeartRateZone)
  int id;
  String name;
  int lowerPercentage;
  int upperPercentage;
  int lowerLimit;
  int upperLimit;
  int color;
  int heartRateZoneSchemataId;

  BoolResult saveResult;
  // end FIELDS (DbHeartRateZone)

// RELATIONSHIPS (DbHeartRateZone)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbHeartRateZoneSchema plDbHeartRateZoneSchema;

  /// get DbHeartRateZoneSchema By HeartRateZoneSchemataId
  Future<DbHeartRateZoneSchema> getDbHeartRateZoneSchema() async {
    final _obj = await DbHeartRateZoneSchema().getById(heartRateZoneSchemataId);
    return _obj;
  }
  // END RELATIONSHIPS (DbHeartRateZone)

  static const bool _softDeleteActivated = false;
  DbHeartRateZoneManager __mnDbHeartRateZone;

  DbHeartRateZoneManager get _mnDbHeartRateZone {
    return __mnDbHeartRateZone =
        __mnDbHeartRateZone ?? DbHeartRateZoneManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (lowerPercentage != null) {
      map['lowerPercentage'] = lowerPercentage;
    }

    if (upperPercentage != null) {
      map['upperPercentage'] = upperPercentage;
    }

    if (lowerLimit != null) {
      map['lowerLimit'] = lowerLimit;
    }

    if (upperLimit != null) {
      map['upperLimit'] = upperLimit;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (heartRateZoneSchemataId != null) {
      map['heartRateZoneSchemataId'] = heartRateZoneSchemataId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (lowerPercentage != null) {
      map['lowerPercentage'] = lowerPercentage;
    }

    if (upperPercentage != null) {
      map['upperPercentage'] = upperPercentage;
    }

    if (lowerLimit != null) {
      map['lowerLimit'] = lowerLimit;
    }

    if (upperLimit != null) {
      map['upperLimit'] = upperLimit;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (heartRateZoneSchemataId != null) {
      map['heartRateZoneSchemataId'] = heartRateZoneSchemataId;
    }

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      name,
      lowerPercentage,
      upperPercentage,
      lowerLimit,
      upperLimit,
      color,
      heartRateZoneSchemataId
    ];
  }

  static Future<List<DbHeartRateZone>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbHeartRateZone.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbHeartRateZone>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbHeartRateZone>[];
    try {
      objList = list
          .map((dbheartratezone) =>
              DbHeartRateZone.fromMap(dbheartratezone as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbHeartRateZone.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbHeartRateZone>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbHeartRateZone.fromMapList(data);
    } 
    */

  static Future<List<DbHeartRateZone>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbHeartRateZone> objList = <DbHeartRateZone>[];
    for (final map in data) {
      final obj = DbHeartRateZone.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null ||
            preloadFields.contains('plDbHeartRateZoneSchema')) {
          obj.plDbHeartRateZoneSchema = obj.plDbHeartRateZoneSchema ??
              await obj.getDbHeartRateZoneSchema();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbHeartRateZone by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbHeartRateZone if exist, otherwise returns null
  Future<DbHeartRateZone> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbHeartRateZone obj;
    final data = await _mnDbHeartRateZone.getById(id);
    if (data.length != 0) {
      obj = DbHeartRateZone.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbHeartRateZone) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbHeartRateZone.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbHeartRateZone. Returns a new Primary Key value of DbHeartRateZone

  /// <returns>Returns a new Primary Key value of DbHeartRateZone
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbHeartRateZone> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(
      List<DbHeartRateZone> dbheartratezones) async {
    final results = _mnDbHeartRateZone.saveAll(
        'INSERT OR REPLACE INTO heartRateZone (id,  name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, heartRateZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',
        dbheartratezones);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbHeartRateZone.rawInsert(
              'INSERT OR REPLACE INTO heartRateZone (id,  name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, heartRateZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',
              [
                id,
                name,
                lowerPercentage,
                upperPercentage,
                lowerLimit,
                upperLimit,
                color,
                heartRateZoneSchemataId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbHeartRateZone id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DbHeartRateZone id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbHeartRateZone Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbHeartRateZone>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(
      List<DbHeartRateZone> dbheartratezones) async {
    final results = await _mnDbHeartRateZone.rawInsertAll(
        'INSERT OR REPLACE INTO heartRateZone (id,  name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, heartRateZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',
        dbheartratezones);
    return results;
  }

  /// Deletes DbHeartRateZone

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbHeartRateZone invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbHeartRateZone
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbHeartRateZone.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbHeartRateZoneFilterBuilder _Select;
  DbHeartRateZoneFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbHeartRateZoneFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbHeartRateZoneFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbHeartRateZoneFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    heartRateZoneSchemataId = heartRateZoneSchemataId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbheartratezone

// region DbHeartRateZoneField
class DbHeartRateZoneField extends SearchCriteria {
  DbHeartRateZoneField(this.dbheartratezoneFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbHeartRateZoneFilterBuilder dbheartratezoneFB;

  DbHeartRateZoneField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbHeartRateZoneFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.EQuals, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.NotEQuals, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder isNull() {
    dbheartratezoneFB._addedBlocks = setCriteria(
        0,
        dbheartratezoneFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbheartratezoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneFB
              ._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
          dbheartratezoneFB._addedBlocks.retVal;
    }
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbheartratezoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneFB
              ._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
          dbheartratezoneFB._addedBlocks.retVal;
      dbheartratezoneFB
              ._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
          dbheartratezoneFB._addedBlocks.retVal;
    }
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbheartratezoneFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbheartratezoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneFB._addedBlocks);
      _waitingNot = '';
      dbheartratezoneFB
              ._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
          dbheartratezoneFB._addedBlocks.retVal;
    }
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbheartratezoneFB._addedBlocks = setCriteria(
          pFirst,
          dbheartratezoneFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbheartratezoneFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbheartratezoneFB._addedBlocks = setCriteria(
            pFirst,
            dbheartratezoneFB.parameters,
            param,
            SqlSyntax.LessThan,
            dbheartratezoneFB._addedBlocks);
      } else {
        dbheartratezoneFB._addedBlocks = setCriteria(
            pFirst,
            dbheartratezoneFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbheartratezoneFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbheartratezoneFB._addedBlocks = setCriteria(
            pLast,
            dbheartratezoneFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            dbheartratezoneFB._addedBlocks);
      } else {
        dbheartratezoneFB._addedBlocks = setCriteria(
            pLast,
            dbheartratezoneFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            dbheartratezoneFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.GreaterThan, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.LessThan, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.LessThan, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbheartratezoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbheartratezoneFB._addedBlocks)
        : setCriteria(pValue, dbheartratezoneFB.parameters, param,
            SqlSyntax.GreaterThan, dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }

  DbHeartRateZoneFilterBuilder inValues(dynamic pValue) {
    dbheartratezoneFB._addedBlocks = setCriteria(
        pValue,
        dbheartratezoneFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbheartratezoneFB._addedBlocks);
    _waitingNot = '';
    dbheartratezoneFB._addedBlocks.needEndBlock[dbheartratezoneFB._blockIndex] =
        dbheartratezoneFB._addedBlocks.retVal;
    return dbheartratezoneFB;
  }
}
// endregion DbHeartRateZoneField

// region DbHeartRateZoneFilterBuilder
class DbHeartRateZoneFilterBuilder extends SearchCriteria {
  DbHeartRateZoneFilterBuilder(DbHeartRateZone obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbHeartRateZone _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbHeartRateZoneFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbHeartRateZoneFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbHeartRateZoneFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbHeartRateZoneFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbHeartRateZoneFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbHeartRateZoneFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbHeartRateZoneFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbHeartRateZoneFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbHeartRateZoneFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbHeartRateZoneFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbHeartRateZoneField setField(
      DbHeartRateZoneField field, String colName, DbType dbtype) {
    return DbHeartRateZoneField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbHeartRateZoneField _id;
  DbHeartRateZoneField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbHeartRateZoneField _name;
  DbHeartRateZoneField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbHeartRateZoneField _lowerPercentage;
  DbHeartRateZoneField get lowerPercentage {
    return _lowerPercentage =
        setField(_lowerPercentage, 'lowerPercentage', DbType.integer);
  }

  DbHeartRateZoneField _upperPercentage;
  DbHeartRateZoneField get upperPercentage {
    return _upperPercentage =
        setField(_upperPercentage, 'upperPercentage', DbType.integer);
  }

  DbHeartRateZoneField _lowerLimit;
  DbHeartRateZoneField get lowerLimit {
    return _lowerLimit = setField(_lowerLimit, 'lowerLimit', DbType.integer);
  }

  DbHeartRateZoneField _upperLimit;
  DbHeartRateZoneField get upperLimit {
    return _upperLimit = setField(_upperLimit, 'upperLimit', DbType.integer);
  }

  DbHeartRateZoneField _color;
  DbHeartRateZoneField get color {
    return _color = setField(_color, 'color', DbType.integer);
  }

  DbHeartRateZoneField _heartRateZoneSchemataId;
  DbHeartRateZoneField get heartRateZoneSchemataId {
    return _heartRateZoneSchemataId = setField(
        _heartRateZoneSchemataId, 'heartRateZoneSchemataId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbHeartRateZone._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbHeartRateZone> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbHeartRateZone._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbHeartRateZone.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbHeartRateZone.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from heartRateZone ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbHeartRateZone.updateBatch(qparams, values);
  }

  /// This method always returns DbHeartRateZoneObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbHeartRateZone>
  Future<DbHeartRateZone> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbHeartRateZone.toList(qparams);
    final data = await objFuture;
    DbHeartRateZone obj;
    if (data.isNotEmpty) {
      obj = DbHeartRateZone.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null ||
            preloadFields.contains('plDbHeartRateZoneSchema')) {
          obj.plDbHeartRateZoneSchema = obj.plDbHeartRateZoneSchema ??
              await obj.getDbHeartRateZoneSchema();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) dbheartratezoneCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbheartratezonesFuture =
        await _obj._mnDbHeartRateZone.toList(qparams);
    final int count = dbheartratezonesFuture[0]['CNT'] as int;
    if (dbheartratezoneCount != null) {
      dbheartratezoneCount(count);
    }
    return count;
  }

  /// This method always returns List<DbHeartRateZone>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbHeartRateZone>
  Future<List<DbHeartRateZone>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbHeartRateZone> dbheartratezonesData =
        await DbHeartRateZone.fromMapList(data, preload: preload);
    return dbheartratezonesData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbHeartRateZone.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbHeartRateZone>>
  Future<List<DropdownMenuItem<DbHeartRateZone>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbHeartRateZone>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dbheartratezonesFuture = _obj._mnDbHeartRateZone.toList(qparams);

    final data = await dbheartratezonesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbHeartRateZone>> items = []
      ..add(DropdownMenuItem(
        value: DbHeartRateZone(),
        child: Text('Select DbHeartRateZone'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbHeartRateZone.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dbheartratezonesFuture = _obj._mnDbHeartRateZone.toList(qparams);

    final data = await dbheartratezonesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbHeartRateZone'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbHeartRateZone.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbHeartRateZone.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbHeartRateZone.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbHeartRateZone.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbHeartRateZoneFilterBuilder

// region DbHeartRateZoneFields
class DbHeartRateZoneFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fLowerPercentage;
  static TableField get lowerPercentage {
    return _fLowerPercentage = _fLowerPercentage ??
        SqlSyntax.setField(
            _fLowerPercentage, 'lowerPercentage', DbType.integer);
  }

  static TableField _fUpperPercentage;
  static TableField get upperPercentage {
    return _fUpperPercentage = _fUpperPercentage ??
        SqlSyntax.setField(
            _fUpperPercentage, 'upperPercentage', DbType.integer);
  }

  static TableField _fLowerLimit;
  static TableField get lowerLimit {
    return _fLowerLimit = _fLowerLimit ??
        SqlSyntax.setField(_fLowerLimit, 'lowerLimit', DbType.integer);
  }

  static TableField _fUpperLimit;
  static TableField get upperLimit {
    return _fUpperLimit = _fUpperLimit ??
        SqlSyntax.setField(_fUpperLimit, 'upperLimit', DbType.integer);
  }

  static TableField _fColor;
  static TableField get color {
    return _fColor =
        _fColor ?? SqlSyntax.setField(_fColor, 'color', DbType.integer);
  }

  static TableField _fHeartRateZoneSchemataId;
  static TableField get heartRateZoneSchemataId {
    return _fHeartRateZoneSchemataId = _fHeartRateZoneSchemataId ??
        SqlSyntax.setField(_fHeartRateZoneSchemataId, 'heartRateZoneSchemataId',
            DbType.integer);
  }
}
// endregion DbHeartRateZoneFields

//region DbHeartRateZoneManager
class DbHeartRateZoneManager extends SqfEntityProvider {
  DbHeartRateZoneManager()
      : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'heartRateZone';
  static String _colId = 'id';
}

//endregion DbHeartRateZoneManager
// region DbPowerZoneSchema
class DbPowerZoneSchema {
  DbPowerZoneSchema(
      {this.id, this.date, this.name, this.base, this.athletesId}) {
    _setDefaultValues();
  }
  DbPowerZoneSchema.withFields(
      this.date, this.name, this.base, this.athletesId) {
    _setDefaultValues();
  }
  DbPowerZoneSchema.withId(
      this.id, this.date, this.name, this.base, this.athletesId) {
    _setDefaultValues();
  }
  DbPowerZoneSchema.fromMap(Map<String, dynamic> o) {
    _setDefaultValues();
    id = o['id'] as int;
    if (o['date'] != null)
      date = int.tryParse(o['date'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(o['date'] as int)
          : DateTime.tryParse(o['date'].toString());
    if (o['name'] != null) name = o['name'] as String;
    if (o['base'] != null) base = o['base'] as int;
    athletesId = o['athletesId'] as int;

    // RELATIONSHIPS FromMAP
    plDbAthlete = o['DbAthlete'] != null
        ? DbAthlete.fromMap(o['DbAthlete'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbPowerZoneSchema)
  int id;
  DateTime date;
  String name;
  int base;
  int athletesId;

  BoolResult saveResult;
  // end FIELDS (DbPowerZoneSchema)

// RELATIONSHIPS (DbPowerZoneSchema)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbAthlete plDbAthlete;

  /// get DbAthlete By AthletesId
  Future<DbAthlete> getDbAthlete() async {
    final _obj = await DbAthlete().getById(athletesId);
    return _obj;
  }
  // END RELATIONSHIPS (DbPowerZoneSchema)

// COLLECTIONS & VIRTUALS (DbPowerZoneSchema)
  /// to load children of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  List<DbPowerZone> plDbPowerZones;

  /// get DbPowerZone(s) filtered by powerZoneSchemataId=id
  DbPowerZoneFilterBuilder getDbPowerZones(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbPowerZone()
        .select(columnsToSelect: columnsToSelect, getIsDeleted: getIsDeleted)
        .powerZoneSchemataId
        .equals(id)
        .and;
  }
// END COLLECTIONS & VIRTUALS (DbPowerZoneSchema)

  static const bool _softDeleteActivated = false;
  DbPowerZoneSchemaManager __mnDbPowerZoneSchema;

  DbPowerZoneSchemaManager get _mnDbPowerZoneSchema {
    return __mnDbPowerZoneSchema =
        __mnDbPowerZoneSchema ?? DbPowerZoneSchemaManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (base != null) {
      map['base'] = base;
    }

    if (athletesId != null) {
      map['athletesId'] = athletesId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (date != null) {
      map['date'] = forJson
          ? '$date.year-$date.month-$date.day'
          : forQuery
              ? DateTime(date.year, date.month, date.day).millisecondsSinceEpoch
              : date;
    }

    if (name != null) {
      map['name'] = name;
    }

    if (base != null) {
      map['base'] = base;
    }

    if (athletesId != null) {
      map['athletesId'] = athletesId;
    }

// COLLECTIONS (DbPowerZoneSchema)
    if (!forQuery) {
      map['DbPowerZones'] = await getDbPowerZones().toMapList();
    }
// END COLLECTIONS (DbPowerZoneSchema)

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      date != null ? date.millisecondsSinceEpoch : null,
      name,
      base,
      athletesId
    ];
  }

  static Future<List<DbPowerZoneSchema>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbPowerZoneSchema.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbPowerZoneSchema>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbPowerZoneSchema>[];
    try {
      objList = list
          .map((dbpowerzoneschema) => DbPowerZoneSchema.fromMap(
              dbpowerzoneschema as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbPowerZoneSchema.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbPowerZoneSchema>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbPowerZoneSchema.fromMapList(data);
    } 
    */

  static Future<List<DbPowerZoneSchema>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbPowerZoneSchema> objList = <DbPowerZoneSchema>[];
    for (final map in data) {
      final obj = DbPowerZoneSchema.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbPowerZones')) {
          obj.plDbPowerZones =
              obj.plDbPowerZones ?? await obj.getDbPowerZones().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbAthlete')) {
          obj.plDbAthlete = obj.plDbAthlete ?? await obj.getDbAthlete();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbPowerZoneSchema by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbPowerZoneSchema if exist, otherwise returns null
  Future<DbPowerZoneSchema> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbPowerZoneSchema obj;
    final data = await _mnDbPowerZoneSchema.getById(id);
    if (data.length != 0) {
      obj = DbPowerZoneSchema.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbPowerZoneSchema) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbPowerZoneSchema.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbPowerZoneSchema. Returns a new Primary Key value of DbPowerZoneSchema

  /// <returns>Returns a new Primary Key value of DbPowerZoneSchema
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbPowerZoneSchema> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(
      List<DbPowerZoneSchema> dbpowerzoneschemas) async {
    final results = _mnDbPowerZoneSchema.saveAll(
        'INSERT OR REPLACE INTO powerZoneSchemata (id,  date, name, base, athletesId)  VALUES (?,?,?,?,?)',
        dbpowerzoneschemas);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbPowerZoneSchema.rawInsert(
              'INSERT OR REPLACE INTO powerZoneSchemata (id,  date, name, base, athletesId)  VALUES (?,?,?,?,?)',
              [
                id,
                date != null ? date.millisecondsSinceEpoch : null,
                name,
                base,
                athletesId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbPowerZoneSchema id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DbPowerZoneSchema id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'DbPowerZoneSchema Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbPowerZoneSchema>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(
      List<DbPowerZoneSchema> dbpowerzoneschemas) async {
    final results = await _mnDbPowerZoneSchema.rawInsertAll(
        'INSERT OR REPLACE INTO powerZoneSchemata (id,  date, name, base, athletesId)  VALUES (?,?,?,?,?)',
        dbpowerzoneschemas);
    return results;
  }

  /// Deletes DbPowerZoneSchema

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbPowerZoneSchema invoked (id=$id)');
    var result = BoolResult();
    {
      result = await DbPowerZone()
          .select()
          .powerZoneSchemataId
          .equals(id)
          .delete(hardDelete);
    }
    if (!result.success) {
      return result;
    }
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbPowerZoneSchema
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbPowerZoneSchema.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbPowerZoneSchemaFilterBuilder _Select;
  DbPowerZoneSchemaFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbPowerZoneSchemaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbPowerZoneSchemaFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbPowerZoneSchemaFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    athletesId = athletesId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbpowerzoneschema

// region DbPowerZoneSchemaField
class DbPowerZoneSchemaField extends SearchCriteria {
  DbPowerZoneSchemaField(this.dbpowerzoneschemaFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbPowerZoneSchemaFilterBuilder dbpowerzoneschemaFB;

  DbPowerZoneSchemaField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbPowerZoneSchemaFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.EQuals, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.NotEQuals, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder isNull() {
    dbpowerzoneschemaFB._addedBlocks = setCriteria(
        0,
        dbpowerzoneschemaFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneschemaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbpowerzoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneschemaFB
              ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
          dbpowerzoneschemaFB._addedBlocks.retVal;
    }
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneschemaFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbpowerzoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneschemaFB
              ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
          dbpowerzoneschemaFB._addedBlocks.retVal;
      dbpowerzoneschemaFB
              ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
          dbpowerzoneschemaFB._addedBlocks.retVal;
    }
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneschemaFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbpowerzoneschemaFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneschemaFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneschemaFB
              ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
          dbpowerzoneschemaFB._addedBlocks.retVal;
    }
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbpowerzoneschemaFB._addedBlocks = setCriteria(
          pFirst,
          dbpowerzoneschemaFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneschemaFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbpowerzoneschemaFB._addedBlocks = setCriteria(
            pFirst,
            dbpowerzoneschemaFB.parameters,
            param,
            SqlSyntax.LessThan,
            dbpowerzoneschemaFB._addedBlocks);
      } else {
        dbpowerzoneschemaFB._addedBlocks = setCriteria(
            pFirst,
            dbpowerzoneschemaFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbpowerzoneschemaFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbpowerzoneschemaFB._addedBlocks = setCriteria(
            pLast,
            dbpowerzoneschemaFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            dbpowerzoneschemaFB._addedBlocks);
      } else {
        dbpowerzoneschemaFB._addedBlocks = setCriteria(
            pLast,
            dbpowerzoneschemaFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            dbpowerzoneschemaFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.GreaterThan, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.LessThan, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.LessThan, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbpowerzoneschemaFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbpowerzoneschemaFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneschemaFB.parameters, param,
            SqlSyntax.GreaterThan, dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }

  DbPowerZoneSchemaFilterBuilder inValues(dynamic pValue) {
    dbpowerzoneschemaFB._addedBlocks = setCriteria(
        pValue,
        dbpowerzoneschemaFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbpowerzoneschemaFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneschemaFB
            ._addedBlocks.needEndBlock[dbpowerzoneschemaFB._blockIndex] =
        dbpowerzoneschemaFB._addedBlocks.retVal;
    return dbpowerzoneschemaFB;
  }
}
// endregion DbPowerZoneSchemaField

// region DbPowerZoneSchemaFilterBuilder
class DbPowerZoneSchemaFilterBuilder extends SearchCriteria {
  DbPowerZoneSchemaFilterBuilder(DbPowerZoneSchema obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbPowerZoneSchema _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbPowerZoneSchemaFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbPowerZoneSchemaFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbPowerZoneSchemaFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbPowerZoneSchemaFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbPowerZoneSchemaFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbPowerZoneSchemaFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbPowerZoneSchemaFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbPowerZoneSchemaFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbPowerZoneSchemaFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbPowerZoneSchemaFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbPowerZoneSchemaField setField(
      DbPowerZoneSchemaField field, String colName, DbType dbtype) {
    return DbPowerZoneSchemaField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbPowerZoneSchemaField _id;
  DbPowerZoneSchemaField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbPowerZoneSchemaField _date;
  DbPowerZoneSchemaField get date {
    return _date = setField(_date, 'date', DbType.date);
  }

  DbPowerZoneSchemaField _name;
  DbPowerZoneSchemaField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbPowerZoneSchemaField _base;
  DbPowerZoneSchemaField get base {
    return _base = setField(_base, 'base', DbType.integer);
  }

  DbPowerZoneSchemaField _athletesId;
  DbPowerZoneSchemaField get athletesId {
    return _athletesId = setField(_athletesId, 'athletesId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbPowerZoneSchema._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbPowerZoneSchema> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbPowerZoneSchema._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbPowerZoneSchema
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbPowerZoneSchema.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from powerZoneSchemata ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbPowerZoneSchema.updateBatch(qparams, values);
  }

  /// This method always returns DbPowerZoneSchemaObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbPowerZoneSchema>
  Future<DbPowerZoneSchema> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbPowerZoneSchema.toList(qparams);
    final data = await objFuture;
    DbPowerZoneSchema obj;
    if (data.isNotEmpty) {
      obj = DbPowerZoneSchema.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbPowerZones')) {
          obj.plDbPowerZones =
              obj.plDbPowerZones ?? await obj.getDbPowerZones().toList();
        }
      } // END RELATIONSHIPS PRELOAD

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null || preloadFields.contains('plDbAthlete')) {
          obj.plDbAthlete = obj.plDbAthlete ?? await obj.getDbAthlete();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount(
      [VoidCallback Function(int c) dbpowerzoneschemaCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbpowerzoneschemasFuture =
        await _obj._mnDbPowerZoneSchema.toList(qparams);
    final int count = dbpowerzoneschemasFuture[0]['CNT'] as int;
    if (dbpowerzoneschemaCount != null) {
      dbpowerzoneschemaCount(count);
    }
    return count;
  }

  /// This method always returns List<DbPowerZoneSchema>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbPowerZoneSchema>
  Future<List<DbPowerZoneSchema>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbPowerZoneSchema> dbpowerzoneschemasData =
        await DbPowerZoneSchema.fromMapList(data, preload: preload);
    return dbpowerzoneschemasData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbPowerZoneSchema.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbPowerZoneSchema>>
  Future<List<DropdownMenuItem<DbPowerZoneSchema>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbPowerZoneSchema>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dbpowerzoneschemasFuture = _obj._mnDbPowerZoneSchema.toList(qparams);

    final data = await dbpowerzoneschemasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbPowerZoneSchema>> items = []
      ..add(DropdownMenuItem(
        value: DbPowerZoneSchema(),
        child: Text('Select DbPowerZoneSchema'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbPowerZoneSchema.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dbpowerzoneschemasFuture = _obj._mnDbPowerZoneSchema.toList(qparams);

    final data = await dbpowerzoneschemasFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbPowerZoneSchema'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbPowerZoneSchema.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbPowerZoneSchema.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbPowerZoneSchema.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbPowerZoneSchema.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbPowerZoneSchemaFilterBuilder

// region DbPowerZoneSchemaFields
class DbPowerZoneSchemaFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fDate;
  static TableField get date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.date);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fBase;
  static TableField get base {
    return _fBase =
        _fBase ?? SqlSyntax.setField(_fBase, 'base', DbType.integer);
  }

  static TableField _fAthletesId;
  static TableField get athletesId {
    return _fAthletesId = _fAthletesId ??
        SqlSyntax.setField(_fAthletesId, 'athletesId', DbType.integer);
  }
}
// endregion DbPowerZoneSchemaFields

//region DbPowerZoneSchemaManager
class DbPowerZoneSchemaManager extends SqfEntityProvider {
  DbPowerZoneSchemaManager()
      : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'powerZoneSchemata';
  static String _colId = 'id';
}

//endregion DbPowerZoneSchemaManager
// region DbPowerZone
class DbPowerZone {
  DbPowerZone(
      {this.id,
      this.name,
      this.lowerPercentage,
      this.upperPercentage,
      this.lowerLimit,
      this.upperLimit,
      this.color,
      this.powerZoneSchemataId}) {
    _setDefaultValues();
  }
  DbPowerZone.withFields(this.name, this.lowerPercentage, this.upperPercentage,
      this.lowerLimit, this.upperLimit, this.color, this.powerZoneSchemataId) {
    _setDefaultValues();
  }
  DbPowerZone.withId(
      this.id,
      this.name,
      this.lowerPercentage,
      this.upperPercentage,
      this.lowerLimit,
      this.upperLimit,
      this.color,
      this.powerZoneSchemataId) {
    _setDefaultValues();
  }
  DbPowerZone.fromMap(Map<String, dynamic> o) {
    _setDefaultValues();
    id = o['id'] as int;
    if (o['name'] != null) name = o['name'] as String;
    if (o['lowerPercentage'] != null)
      lowerPercentage = o['lowerPercentage'] as int;
    if (o['upperPercentage'] != null)
      upperPercentage = o['upperPercentage'] as int;
    if (o['lowerLimit'] != null) lowerLimit = o['lowerLimit'] as int;
    if (o['upperLimit'] != null) upperLimit = o['upperLimit'] as int;
    if (o['color'] != null) color = o['color'] as int;
    powerZoneSchemataId = o['powerZoneSchemataId'] as int;

    // RELATIONSHIPS FromMAP
    plDbPowerZoneSchema = o['DbPowerZoneSchema'] != null
        ? DbPowerZoneSchema.fromMap(
            o['DbPowerZoneSchema'] as Map<String, dynamic>)
        : null;
    // END RELATIONSHIPS FromMAP
  }
  // FIELDS (DbPowerZone)
  int id;
  String name;
  int lowerPercentage;
  int upperPercentage;
  int lowerLimit;
  int upperLimit;
  int color;
  int powerZoneSchemataId;

  BoolResult saveResult;
  // end FIELDS (DbPowerZone)

// RELATIONSHIPS (DbPowerZone)
  /// to load parent of items to this field, use preload parameter ex: toList(preload:true) or toSingle(preload:true)
  DbPowerZoneSchema plDbPowerZoneSchema;

  /// get DbPowerZoneSchema By PowerZoneSchemataId
  Future<DbPowerZoneSchema> getDbPowerZoneSchema() async {
    final _obj = await DbPowerZoneSchema().getById(powerZoneSchemataId);
    return _obj;
  }
  // END RELATIONSHIPS (DbPowerZone)

  static const bool _softDeleteActivated = false;
  DbPowerZoneManager __mnDbPowerZone;

  DbPowerZoneManager get _mnDbPowerZone {
    return __mnDbPowerZone = __mnDbPowerZone ?? DbPowerZoneManager();
  }

  // METHODS
  Map<String, dynamic> toMap({bool forQuery = false, bool forJson = false}) {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (lowerPercentage != null) {
      map['lowerPercentage'] = lowerPercentage;
    }

    if (upperPercentage != null) {
      map['upperPercentage'] = upperPercentage;
    }

    if (lowerLimit != null) {
      map['lowerLimit'] = lowerLimit;
    }

    if (upperLimit != null) {
      map['upperLimit'] = upperLimit;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (powerZoneSchemataId != null) {
      map['powerZoneSchemataId'] = powerZoneSchemataId;
    }

    return map;
  }

  Future<Map<String, dynamic>> toMapWithChilds(
      [bool forQuery = false, bool forJson = false]) async {
    final map = <String, dynamic>{};
    if (id != null) {
      map['id'] = id;
    }
    if (name != null) {
      map['name'] = name;
    }

    if (lowerPercentage != null) {
      map['lowerPercentage'] = lowerPercentage;
    }

    if (upperPercentage != null) {
      map['upperPercentage'] = upperPercentage;
    }

    if (lowerLimit != null) {
      map['lowerLimit'] = lowerLimit;
    }

    if (upperLimit != null) {
      map['upperLimit'] = upperLimit;
    }

    if (color != null) {
      map['color'] = color;
    }

    if (powerZoneSchemataId != null) {
      map['powerZoneSchemataId'] = powerZoneSchemataId;
    }

    return map;
  }

  /// This method always returns Json String
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method always returns Json String
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChilds(false, true));
  }

  List<dynamic> toArgs() {
    return [
      id,
      name,
      lowerPercentage,
      upperPercentage,
      lowerLimit,
      upperLimit,
      color,
      powerZoneSchemataId
    ];
  }

  static Future<List<DbPowerZone>> fromWebUrl(String url) async {
    try {
      final response = await http.get(url);
      return await fromJson(response.body);
    } catch (e) {
      print(
          'SQFENTITY ERROR DbPowerZone.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  static Future<List<DbPowerZone>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DbPowerZone>[];
    try {
      objList = list
          .map((dbpowerzone) =>
              DbPowerZone.fromMap(dbpowerzone as Map<String, dynamic>))
          .toList();
    } catch (e) {
      print(
          'SQFENTITY ERROR DbPowerZone.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  /*
    /// REMOVED AFTER v1.2.1+14 
    static Future<List<DbPowerZone>> fromObjectList(Future<List<dynamic>> o) async {
      final data = await o;
      return await DbPowerZone.fromMapList(data);
    } 
    */

  static Future<List<DbPowerZone>> fromMapList(List<dynamic> data,
      {bool preload = false, List<String> preloadFields}) async {
    final List<DbPowerZone> objList = <DbPowerZone>[];
    for (final map in data) {
      final obj = DbPowerZone.fromMap(map as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null ||
            preloadFields.contains('plDbPowerZoneSchema')) {
          obj.plDbPowerZoneSchema =
              obj.plDbPowerZoneSchema ?? await obj.getDbPowerZoneSchema();
        }
      } // END RELATIONSHIPS PRELOAD

      objList.add(obj);
    }
    return objList;
  }

  /// returns DbPowerZone by ID if exist, otherwise returns null
  /// <param name='id'>Primary Key Value</param>
  /// <returns>returns DbPowerZone if exist, otherwise returns null
  Future<DbPowerZone> getById(int id) async {
    if (id == null) {
      return null;
    }
    DbPowerZone obj;
    final data = await _mnDbPowerZone.getById(id);
    if (data.length != 0) {
      obj = DbPowerZone.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DbPowerZone) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record

  /// <returns>Returns id
  Future<int> save() async {
    if (id == null || id == 0) {
      id = await _mnDbPowerZone.insert(this);
    } else {
      id = await _upsert();
    }

    return id;
  }

  /// saveAs DbPowerZone. Returns a new Primary Key value of DbPowerZone

  /// <returns>Returns a new Primary Key value of DbPowerZone
  Future<int> saveAs() async {
    id = null;

    return save();
  }

  /// saveAll method saves the sent List<DbPowerZone> as a bulk in one transaction
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> saveAll(List<DbPowerZone> dbpowerzones) async {
    final results = _mnDbPowerZone.saveAll(
        'INSERT OR REPLACE INTO powerZone (id,  name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, powerZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',
        dbpowerzones);
    return results;
  }

  /// Updates if the record exists, otherwise adds a new row

  /// <returns>Returns id
  Future<int> _upsert() async {
    try {
      if (await _mnDbPowerZone.rawInsert(
              'INSERT OR REPLACE INTO powerZone (id,  name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, powerZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',
              [
                id,
                name,
                lowerPercentage,
                upperPercentage,
                lowerLimit,
                upperLimit,
                color,
                powerZoneSchemataId
              ]) ==
          1) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DbPowerZone id=$id updated successfuly');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DbPowerZone id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DbPowerZone Save failed. Error: ${e.toString()}');
      return 0;
    }
  }

  /// inserts or replaces the sent List<<DbPowerZone>> as a bulk in one transaction.
  ///
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  ///
  /// Returns a <List<BoolResult>>
  Future<List<BoolResult>> upsertAll(List<DbPowerZone> dbpowerzones) async {
    final results = await _mnDbPowerZone.rawInsertAll(
        'INSERT OR REPLACE INTO powerZone (id,  name, lowerPercentage, upperPercentage, lowerLimit, upperLimit, color, powerZoneSchemataId)  VALUES (?,?,?,?,?,?,?,?)',
        dbpowerzones);
    return results;
  }

  /// Deletes DbPowerZone

  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    print('SQFENTITIY: delete DbPowerZone invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDbPowerZone
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDbPowerZone.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  //private DbPowerZoneFilterBuilder _Select;
  DbPowerZoneFilterBuilder select(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbPowerZoneFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect;
  }

  DbPowerZoneFilterBuilder distinct(
      {List<String> columnsToSelect, bool getIsDeleted}) {
    return DbPowerZoneFilterBuilder(this)
      .._getIsDeleted = getIsDeleted == true
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    powerZoneSchemataId = powerZoneSchemataId ?? 0;
  }
  // END METHODS
  // CUSTOM CODES
  /*
      you must define customCode property of your SqfEntityTable constant for ex:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODES
}
// endregion dbpowerzone

// region DbPowerZoneField
class DbPowerZoneField extends SearchCriteria {
  DbPowerZoneField(this.dbpowerzoneFB) {
    param = DbParameter();
  }
  DbParameter param;
  String _waitingNot = '';
  DbPowerZoneFilterBuilder dbpowerzoneFB;

  DbPowerZoneField get not {
    _waitingNot = ' NOT ';
    return this;
  }

  DbPowerZoneFilterBuilder equals(dynamic pValue) {
    param.expression = '=';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param, SqlSyntax.EQuals,
            dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.NotEQuals, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder equalsOrNull(dynamic pValue) {
    param.expression = '=';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.EQualsOrNull, dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.NotEQualsOrNull, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder isNull() {
    dbpowerzoneFB._addedBlocks = setCriteria(
        0,
        dbpowerzoneFB.parameters,
        param,
        SqlSyntax.IsNULL.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder contains(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneFB._addedBlocks = setCriteria(
          '%${pValue.toString()}%',
          dbpowerzoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
          dbpowerzoneFB._addedBlocks.retVal;
    }
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder startsWith(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneFB._addedBlocks = setCriteria(
          '${pValue.toString()}%',
          dbpowerzoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
          dbpowerzoneFB._addedBlocks.retVal;
      dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
          dbpowerzoneFB._addedBlocks.retVal;
    }
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder endsWith(dynamic pValue) {
    if (pValue != null) {
      dbpowerzoneFB._addedBlocks = setCriteria(
          '%${pValue.toString()}',
          dbpowerzoneFB.parameters,
          param,
          SqlSyntax.Contains.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneFB._addedBlocks);
      _waitingNot = '';
      dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
          dbpowerzoneFB._addedBlocks.retVal;
    }
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder between(dynamic pFirst, dynamic pLast) {
    if (pFirst != null && pLast != null) {
      dbpowerzoneFB._addedBlocks = setCriteria(
          pFirst,
          dbpowerzoneFB.parameters,
          param,
          SqlSyntax.Between.replaceAll(SqlSyntax.notKeyword, _waitingNot),
          dbpowerzoneFB._addedBlocks,
          pLast);
    } else if (pFirst != null) {
      if (_waitingNot != '') {
        dbpowerzoneFB._addedBlocks = setCriteria(
            pFirst,
            dbpowerzoneFB.parameters,
            param,
            SqlSyntax.LessThan,
            dbpowerzoneFB._addedBlocks);
      } else {
        dbpowerzoneFB._addedBlocks = setCriteria(
            pFirst,
            dbpowerzoneFB.parameters,
            param,
            SqlSyntax.GreaterThanOrEquals,
            dbpowerzoneFB._addedBlocks);
      }
    } else if (pLast != null) {
      if (_waitingNot != '') {
        dbpowerzoneFB._addedBlocks = setCriteria(
            pLast,
            dbpowerzoneFB.parameters,
            param,
            SqlSyntax.GreaterThan,
            dbpowerzoneFB._addedBlocks);
      } else {
        dbpowerzoneFB._addedBlocks = setCriteria(
            pLast,
            dbpowerzoneFB.parameters,
            param,
            SqlSyntax.LessThanOrEquals,
            dbpowerzoneFB._addedBlocks);
      }
    }
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder greaterThan(dynamic pValue) {
    param.expression = '>';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.GreaterThan, dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder lessThan(dynamic pValue) {
    param.expression = '<';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.LessThan, dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder greaterThanOrEquals(dynamic pValue) {
    param.expression = '>=';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.GreaterThanOrEquals, dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.LessThan, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder lessThanOrEquals(dynamic pValue) {
    param.expression = '<=';
    dbpowerzoneFB._addedBlocks = _waitingNot == ''
        ? setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.LessThanOrEquals, dbpowerzoneFB._addedBlocks)
        : setCriteria(pValue, dbpowerzoneFB.parameters, param,
            SqlSyntax.GreaterThan, dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }

  DbPowerZoneFilterBuilder inValues(dynamic pValue) {
    dbpowerzoneFB._addedBlocks = setCriteria(
        pValue,
        dbpowerzoneFB.parameters,
        param,
        SqlSyntax.IN.replaceAll(SqlSyntax.notKeyword, _waitingNot),
        dbpowerzoneFB._addedBlocks);
    _waitingNot = '';
    dbpowerzoneFB._addedBlocks.needEndBlock[dbpowerzoneFB._blockIndex] =
        dbpowerzoneFB._addedBlocks.retVal;
    return dbpowerzoneFB;
  }
}
// endregion DbPowerZoneField

// region DbPowerZoneFilterBuilder
class DbPowerZoneFilterBuilder extends SearchCriteria {
  DbPowerZoneFilterBuilder(DbPowerZone obj) {
    whereString = '';
    qparams = QueryParams();
    parameters = <DbParameter>[];
    orderByList = <String>[];
    groupByList = <String>[];
    _addedBlocks = AddedBlocks(<bool>[], <bool>[]);
    _addedBlocks.needEndBlock.add(false);
    _addedBlocks.waitingStartBlock.add(false);
    _pagesize = 0;
    _page = 0;
    _obj = obj;
  }
  AddedBlocks _addedBlocks;
  int _blockIndex = 0;
  List<DbParameter> parameters;
  List<String> orderByList;
  DbPowerZone _obj;
  QueryParams qparams;
  int _pagesize;
  int _page;

  /// put the sql keyword 'AND'
  DbPowerZoneFilterBuilder get and {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' AND ';
    }
    return this;
  }

  /// put the sql keyword 'OR'
  DbPowerZoneFilterBuilder get or {
    if (parameters.isNotEmpty) {
      parameters[parameters.length - 1].wOperator = ' OR ';
    }
    return this;
  }

  /// open parentheses
  DbPowerZoneFilterBuilder get startBlock {
    _addedBlocks.waitingStartBlock.add(true);
    _addedBlocks.needEndBlock.add(false);
    _blockIndex++;
    if (_blockIndex > 1) _addedBlocks.needEndBlock[_blockIndex - 1] = true;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  DbPowerZoneFilterBuilder where(String whereCriteria) {
    if (whereCriteria != null && whereCriteria != '') {
      final DbParameter param = DbParameter();
      _addedBlocks =
          setCriteria(0, parameters, param, '($whereCriteria)', _addedBlocks);
      _addedBlocks.needEndBlock[_blockIndex] = _addedBlocks.retVal;
    }
    return this;
  }

  /// page = page number,
  ///
  /// pagesize = row(s) per page
  DbPowerZoneFilterBuilder page(int page, int pagesize) {
    if (page > 0) _page = page;
    if (pagesize > 0) _pagesize = pagesize;
    return this;
  }

  /// int count = LIMIT
  DbPowerZoneFilterBuilder top(int count) {
    if (count > 0) {
      _pagesize = count;
    }
    return this;
  }

  /// close parentheses
  DbPowerZoneFilterBuilder get endBlock {
    if (_addedBlocks.needEndBlock[_blockIndex]) {
      parameters[parameters.length - 1].whereString += ' ) ';
    }
    _addedBlocks.needEndBlock.removeAt(_blockIndex);
    _addedBlocks.waitingStartBlock.removeAt(_blockIndex);
    _blockIndex--;
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='name, date'
  ///
  /// Example 2: argFields = ['name', 'date']
  DbPowerZoneFilterBuilder orderBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add(argFields);
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbPowerZoneFilterBuilder orderByDesc(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        orderByList.add('$argFields desc ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') orderByList.add(' $s desc ');
        }
      }
    }
    return this;
  }

  /// argFields might be String or List<String>.
  ///
  /// Example 1: argFields='field1, field2'
  ///
  /// Example 2: argFields = ['field1', 'field2']
  DbPowerZoneFilterBuilder groupBy(dynamic argFields) {
    if (argFields != null) {
      if (argFields is String) {
        groupByList.add(' $argFields ');
      } else {
        for (String s in argFields) {
          if (s != null && s != '') groupByList.add(' $s ');
        }
      }
    }
    return this;
  }

  DbPowerZoneField setField(
      DbPowerZoneField field, String colName, DbType dbtype) {
    return DbPowerZoneField(this)
      ..param = DbParameter(
          dbType: dbtype,
          columnName: colName,
          wStartBlock: _addedBlocks.waitingStartBlock[_blockIndex]);
  }

  DbPowerZoneField _id;
  DbPowerZoneField get id {
    return _id = setField(_id, 'id', DbType.integer);
  }

  DbPowerZoneField _name;
  DbPowerZoneField get name {
    return _name = setField(_name, 'name', DbType.text);
  }

  DbPowerZoneField _lowerPercentage;
  DbPowerZoneField get lowerPercentage {
    return _lowerPercentage =
        setField(_lowerPercentage, 'lowerPercentage', DbType.integer);
  }

  DbPowerZoneField _upperPercentage;
  DbPowerZoneField get upperPercentage {
    return _upperPercentage =
        setField(_upperPercentage, 'upperPercentage', DbType.integer);
  }

  DbPowerZoneField _lowerLimit;
  DbPowerZoneField get lowerLimit {
    return _lowerLimit = setField(_lowerLimit, 'lowerLimit', DbType.integer);
  }

  DbPowerZoneField _upperLimit;
  DbPowerZoneField get upperLimit {
    return _upperLimit = setField(_upperLimit, 'upperLimit', DbType.integer);
  }

  DbPowerZoneField _color;
  DbPowerZoneField get color {
    return _color = setField(_color, 'color', DbType.integer);
  }

  DbPowerZoneField _powerZoneSchemataId;
  DbPowerZoneField get powerZoneSchemataId {
    return _powerZoneSchemataId =
        setField(_powerZoneSchemataId, 'powerZoneSchemataId', DbType.integer);
  }

  bool _getIsDeleted;

  void _buildParameters() {
    if (_page > 0 && _pagesize > 0) {
      qparams
        ..limit = _pagesize
        ..offset = (_page - 1) * _pagesize;
    } else {
      qparams
        ..limit = _pagesize
        ..offset = _page;
    }
    for (DbParameter param in parameters) {
      if (param.columnName != null) {
        if (param.value is List) {
          param.value = param.value
              .toString()
              .replaceAll('[', '')
              .replaceAll(']', '')
              .toString();
          whereString += param.whereString
              .replaceAll('{field}', param.columnName)
              .replaceAll('?', param.value.toString());
          param.value = null;
        } else {
          whereString +=
              param.whereString.replaceAll('{field}', param.columnName);
        }
        if (!param.whereString.contains('?')) {
        } else {
          switch (param.dbType) {
            case DbType.bool:
              param.value =
                  param.value == null ? null : param.value == true ? 1 : 0;
              param.value2 =
                  param.value2 == null ? null : param.value2 == true ? 1 : 0;
              break;
            case DbType.date:
            case DbType.datetime:
              param.value = param.value == null
                  ? null
                  : (param.value as DateTime).millisecondsSinceEpoch;
              param.value2 = param.value2 == null
                  ? null
                  : (param.value2 as DateTime).millisecondsSinceEpoch;
              break;
            default:
          }
          if (param.value != null) {
            whereArguments.add(param.value);
          }
          if (param.value2 != null) {
            whereArguments.add(param.value2);
          }
        }
      } else {
        whereString += param.whereString;
      }
    }
    if (DbPowerZone._softDeleteActivated) {
      if (whereString != '') {
        whereString =
            '${!_getIsDeleted ? 'ifnull(isDeleted,0)=0 AND' : ''} ($whereString)';
      } else if (!_getIsDeleted) {
        whereString = 'ifnull(isDeleted,0)=0';
      }
    }

    if (whereString != '') {
      qparams.whereString = whereString;
    }
    qparams
      ..whereArguments = whereArguments
      ..groupBy = groupByList.join(',')
      ..orderBy = orderByList.join(',');
  }

  /// Deletes List<DbPowerZone> bulk by query
  ///
  /// <returns>BoolResult res.success=Deleted, not res.success=Can not deleted
  Future<BoolResult> delete([bool hardDelete = false]) async {
    _buildParameters();
    var r = BoolResult();
    if (DbPowerZone._softDeleteActivated && !hardDelete) {
      r = await _obj._mnDbPowerZone.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _obj._mnDbPowerZone.delete(qparams);
    }
    return r;
  }

  /// using:
  ///
  /// update({'fieldName': Value})
  ///
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  Future<BoolResult> update(Map<String, dynamic> values) {
    _buildParameters();
    if (qparams.limit > 0 || qparams.offset > 0) {
      qparams.whereString =
          'id IN (SELECT id from powerZone ${qparams.whereString.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _obj._mnDbPowerZone.updateBatch(qparams, values);
  }

  /// This method always returns DbPowerZoneObj if exist, otherwise returns null
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbPowerZone>
  Future<DbPowerZone> toSingle(
      {bool preload = false, List<String> preloadFields}) async {
    _pagesize = 1;
    _buildParameters();
    final objFuture = _obj._mnDbPowerZone.toList(qparams);
    final data = await objFuture;
    DbPowerZone obj;
    if (data.isNotEmpty) {
      obj = DbPowerZone.fromMap(data[0] as Map<String, dynamic>);

      // RELATIONSHIPS PRELOAD
      if (preload) {
        if (preloadFields == null ||
            preloadFields.contains('plDbPowerZoneSchema')) {
          obj.plDbPowerZoneSchema =
              obj.plDbPowerZoneSchema ?? await obj.getDbPowerZoneSchema();
        }
      } // END RELATIONSHIPS PRELOAD

    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns int.
  ///
  /// <returns>int
  Future<int> toCount([VoidCallback Function(int c) dbpowerzoneCount]) async {
    _buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dbpowerzonesFuture = await _obj._mnDbPowerZone.toList(qparams);
    final int count = dbpowerzonesFuture[0]['CNT'] as int;
    if (dbpowerzoneCount != null) {
      dbpowerzoneCount(count);
    }
    return count;
  }

  /// This method always returns List<DbPowerZone>.
  ///
  /// Set preload to true if you want to load all fields related to child or parent
  ///
  /// You can send certain field names with preloadFields parameter for preloading. For ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])
  ///
  /// <returns>List<DbPowerZone>
  Future<List<DbPowerZone>> toList(
      {bool preload = false, List<String> preloadFields}) async {
    final data = await toMapList();
    final List<DbPowerZone> dbpowerzonesData =
        await DbPowerZone.fromMapList(data, preload: preload);
    return dbpowerzonesData;
  }

  /// This method always returns Json String
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method always returns Json String.
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChilds(false, true));
    }
    return json.encode(list);
  }

  /// This method always returns List<dynamic>.
  ///
  /// <returns>List<dynamic>
  Future<List<dynamic>> toMapList() async {
    _buildParameters();
    return await _obj._mnDbPowerZone.toList(qparams);
  }

  /// Returns List<DropdownMenuItem<DbPowerZone>>
  Future<List<DropdownMenuItem<DbPowerZone>>> toDropDownMenu(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<DbPowerZone>> o)
          dropDownMenu]) async {
    _buildParameters();
    final dbpowerzonesFuture = _obj._mnDbPowerZone.toList(qparams);

    final data = await dbpowerzonesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<DbPowerZone>> items = []..add(DropdownMenuItem(
        value: DbPowerZone(),
        child: Text('Select DbPowerZone'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: DbPowerZone.fromMap(data[i] as Map<String, dynamic>),
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// Returns List<DropdownMenuItem<int>>
  Future<List<DropdownMenuItem<int>>> toDropDownMenuInt(
      String displayTextColumn,
      [VoidCallback Function(List<DropdownMenuItem<int>> o)
          dropDownMenu]) async {
    _buildParameters();
    qparams.selectColumns = ['id', displayTextColumn];
    final dbpowerzonesFuture = _obj._mnDbPowerZone.toList(qparams);

    final data = await dbpowerzonesFuture;
    final int count = data.length;
    final List<DropdownMenuItem<int>> items = []..add(DropdownMenuItem(
        value: 0,
        child: Text('Select DbPowerZone'),
      ));
    for (int i = 0; i < count; i++) {
      items.add(
        DropdownMenuItem(
          value: data[i]['id'] as int,
          child: Text(data[i][displayTextColumn].toString()),
        ),
      );
    }
    if (dropDownMenu != null) {
      dropDownMenu(items);
    }
    return items;
  }

  /// This method always returns Primary Key List<int>.
  /// <returns>List<int>
  Future<List<int>> toListPrimaryKey([bool buildParameters = true]) async {
    if (buildParameters) _buildParameters();
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _obj._mnDbPowerZone.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..
  ///
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  Future<List<dynamic>> toListObject(
      [VoidCallback Function(List<dynamic> o) listObject]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbPowerZone.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    if (listObject != null) {
      listObject(objectsData);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  ///
  /// Sample usage: await DbPowerZone.select(columnsToSelect: ['columnName']).toListString()
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o) listString]) async {
    _buildParameters();

    final objectFuture = _obj._mnDbPowerZone.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns[0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DbPowerZoneFilterBuilder

// region DbPowerZoneFields
class DbPowerZoneFields {
  static TableField _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField _fName;
  static TableField get name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'name', DbType.text);
  }

  static TableField _fLowerPercentage;
  static TableField get lowerPercentage {
    return _fLowerPercentage = _fLowerPercentage ??
        SqlSyntax.setField(
            _fLowerPercentage, 'lowerPercentage', DbType.integer);
  }

  static TableField _fUpperPercentage;
  static TableField get upperPercentage {
    return _fUpperPercentage = _fUpperPercentage ??
        SqlSyntax.setField(
            _fUpperPercentage, 'upperPercentage', DbType.integer);
  }

  static TableField _fLowerLimit;
  static TableField get lowerLimit {
    return _fLowerLimit = _fLowerLimit ??
        SqlSyntax.setField(_fLowerLimit, 'lowerLimit', DbType.integer);
  }

  static TableField _fUpperLimit;
  static TableField get upperLimit {
    return _fUpperLimit = _fUpperLimit ??
        SqlSyntax.setField(_fUpperLimit, 'upperLimit', DbType.integer);
  }

  static TableField _fColor;
  static TableField get color {
    return _fColor =
        _fColor ?? SqlSyntax.setField(_fColor, 'color', DbType.integer);
  }

  static TableField _fPowerZoneSchemataId;
  static TableField get powerZoneSchemataId {
    return _fPowerZoneSchemataId = _fPowerZoneSchemataId ??
        SqlSyntax.setField(
            _fPowerZoneSchemataId, 'powerZoneSchemataId', DbType.integer);
  }
}
// endregion DbPowerZoneFields

//region DbPowerZoneManager
class DbPowerZoneManager extends SqfEntityProvider {
  DbPowerZoneManager()
      : super(DbEncrateia(), tableName: _tableName, colId: _colId);
  static String _tableName = 'powerZone';
  static String _colId = 'id';
}

//endregion DbPowerZoneManager
class DbEncrateiaSequenceManager extends SqfEntityProvider {
  DbEncrateiaSequenceManager() : super(DbEncrateia());
}
// END OF ENTITIES
